// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: regulatormodule/regulatormodule.proto

#ifndef PROTOBUF_INCLUDED_regulatormodule_2fregulatormodule_2eproto
#define PROTOBUF_INCLUDED_regulatormodule_2fregulatormodule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "uml.pb.h"
#include <google/protobuf/wrappers.pb.h>
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_regulatormodule_2fregulatormodule_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_regulatormodule_2fregulatormodule_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_regulatormodule_2fregulatormodule_2eproto();
namespace regulatormodule {
class RegulatorCSG;
class RegulatorCSGDefaultTypeInternal;
extern RegulatorCSGDefaultTypeInternal _RegulatorCSG_default_instance_;
class RegulatorControl;
class RegulatorControlDefaultTypeInternal;
extern RegulatorControlDefaultTypeInternal _RegulatorControl_default_instance_;
class RegulatorControlATCC;
class RegulatorControlATCCDefaultTypeInternal;
extern RegulatorControlATCCDefaultTypeInternal _RegulatorControlATCC_default_instance_;
class RegulatorControlFSCC;
class RegulatorControlFSCCDefaultTypeInternal;
extern RegulatorControlFSCCDefaultTypeInternal _RegulatorControlFSCC_default_instance_;
class RegulatorControlProfile;
class RegulatorControlProfileDefaultTypeInternal;
extern RegulatorControlProfileDefaultTypeInternal _RegulatorControlProfile_default_instance_;
class RegulatorControlScheduleFSCH;
class RegulatorControlScheduleFSCHDefaultTypeInternal;
extern RegulatorControlScheduleFSCHDefaultTypeInternal _RegulatorControlScheduleFSCH_default_instance_;
class RegulatorEvent;
class RegulatorEventDefaultTypeInternal;
extern RegulatorEventDefaultTypeInternal _RegulatorEvent_default_instance_;
class RegulatorEventAndStatusANCR;
class RegulatorEventAndStatusANCRDefaultTypeInternal;
extern RegulatorEventAndStatusANCRDefaultTypeInternal _RegulatorEventAndStatusANCR_default_instance_;
class RegulatorEventAndStatusATCC;
class RegulatorEventAndStatusATCCDefaultTypeInternal;
extern RegulatorEventAndStatusATCCDefaultTypeInternal _RegulatorEventAndStatusATCC_default_instance_;
class RegulatorEventAndStatusPoint;
class RegulatorEventAndStatusPointDefaultTypeInternal;
extern RegulatorEventAndStatusPointDefaultTypeInternal _RegulatorEventAndStatusPoint_default_instance_;
class RegulatorEventProfile;
class RegulatorEventProfileDefaultTypeInternal;
extern RegulatorEventProfileDefaultTypeInternal _RegulatorEventProfile_default_instance_;
class RegulatorPoint;
class RegulatorPointDefaultTypeInternal;
extern RegulatorPointDefaultTypeInternal _RegulatorPoint_default_instance_;
class RegulatorReading;
class RegulatorReadingDefaultTypeInternal;
extern RegulatorReadingDefaultTypeInternal _RegulatorReading_default_instance_;
class RegulatorReadingProfile;
class RegulatorReadingProfileDefaultTypeInternal;
extern RegulatorReadingProfileDefaultTypeInternal _RegulatorReadingProfile_default_instance_;
class RegulatorStatus;
class RegulatorStatusDefaultTypeInternal;
extern RegulatorStatusDefaultTypeInternal _RegulatorStatus_default_instance_;
class RegulatorStatusProfile;
class RegulatorStatusProfileDefaultTypeInternal;
extern RegulatorStatusProfileDefaultTypeInternal _RegulatorStatusProfile_default_instance_;
class RegulatorSystem;
class RegulatorSystemDefaultTypeInternal;
extern RegulatorSystemDefaultTypeInternal _RegulatorSystem_default_instance_;
}  // namespace regulatormodule
namespace google {
namespace protobuf {
template<> ::regulatormodule::RegulatorCSG* Arena::CreateMaybeMessage<::regulatormodule::RegulatorCSG>(Arena*);
template<> ::regulatormodule::RegulatorControl* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControl>(Arena*);
template<> ::regulatormodule::RegulatorControlATCC* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlATCC>(Arena*);
template<> ::regulatormodule::RegulatorControlFSCC* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlFSCC>(Arena*);
template<> ::regulatormodule::RegulatorControlProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlProfile>(Arena*);
template<> ::regulatormodule::RegulatorControlScheduleFSCH* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlScheduleFSCH>(Arena*);
template<> ::regulatormodule::RegulatorEvent* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEvent>(Arena*);
template<> ::regulatormodule::RegulatorEventAndStatusANCR* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusANCR>(Arena*);
template<> ::regulatormodule::RegulatorEventAndStatusATCC* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusATCC>(Arena*);
template<> ::regulatormodule::RegulatorEventAndStatusPoint* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusPoint>(Arena*);
template<> ::regulatormodule::RegulatorEventProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEventProfile>(Arena*);
template<> ::regulatormodule::RegulatorPoint* Arena::CreateMaybeMessage<::regulatormodule::RegulatorPoint>(Arena*);
template<> ::regulatormodule::RegulatorReading* Arena::CreateMaybeMessage<::regulatormodule::RegulatorReading>(Arena*);
template<> ::regulatormodule::RegulatorReadingProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorReadingProfile>(Arena*);
template<> ::regulatormodule::RegulatorStatus* Arena::CreateMaybeMessage<::regulatormodule::RegulatorStatus>(Arena*);
template<> ::regulatormodule::RegulatorStatusProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorStatusProfile>(Arena*);
template<> ::regulatormodule::RegulatorSystem* Arena::CreateMaybeMessage<::regulatormodule::RegulatorSystem>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace regulatormodule {

// ===================================================================

class RegulatorControlATCC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlATCC) */ {
 public:
  RegulatorControlATCC();
  virtual ~RegulatorControlATCC();

  RegulatorControlATCC(const RegulatorControlATCC& from);

  inline RegulatorControlATCC& operator=(const RegulatorControlATCC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorControlATCC(RegulatorControlATCC&& from) noexcept
    : RegulatorControlATCC() {
    *this = ::std::move(from);
  }

  inline RegulatorControlATCC& operator=(RegulatorControlATCC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorControlATCC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorControlATCC* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlATCC*>(
               &_RegulatorControlATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RegulatorControlATCC* other);
  friend void swap(RegulatorControlATCC& a, RegulatorControlATCC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorControlATCC* New() const final {
    return CreateMaybeMessage<RegulatorControlATCC>(nullptr);
  }

  RegulatorControlATCC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorControlATCC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorControlATCC& from);
  void MergeFrom(const RegulatorControlATCC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlATCC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ASG BndCtr = 1;
  bool has_bndctr() const;
  void clear_bndctr();
  static const int kBndCtrFieldNumber = 1;
  const ::commonmodule::ASG& bndctr() const;
  ::commonmodule::ASG* release_bndctr();
  ::commonmodule::ASG* mutable_bndctr();
  void set_allocated_bndctr(::commonmodule::ASG* bndctr);

  // .commonmodule.ASG BndWid = 2;
  bool has_bndwid() const;
  void clear_bndwid();
  static const int kBndWidFieldNumber = 2;
  const ::commonmodule::ASG& bndwid() const;
  ::commonmodule::ASG* release_bndwid();
  ::commonmodule::ASG* mutable_bndwid();
  void set_allocated_bndwid(::commonmodule::ASG* bndwid);

  // .commonmodule.ControlING CtlDlTmms = 3;
  bool has_ctldltmms() const;
  void clear_ctldltmms();
  static const int kCtlDlTmmsFieldNumber = 3;
  const ::commonmodule::ControlING& ctldltmms() const;
  ::commonmodule::ControlING* release_ctldltmms();
  ::commonmodule::ControlING* mutable_ctldltmms();
  void set_allocated_ctldltmms(::commonmodule::ControlING* ctldltmms);

  // .commonmodule.ASG LDCR = 4;
  bool has_ldcr() const;
  void clear_ldcr();
  static const int kLDCRFieldNumber = 4;
  const ::commonmodule::ASG& ldcr() const;
  ::commonmodule::ASG* release_ldcr();
  ::commonmodule::ASG* mutable_ldcr();
  void set_allocated_ldcr(::commonmodule::ASG* ldcr);

  // .commonmodule.ASG LDCX = 5;
  bool has_ldcx() const;
  void clear_ldcx();
  static const int kLDCXFieldNumber = 5;
  const ::commonmodule::ASG& ldcx() const;
  ::commonmodule::ASG* release_ldcx();
  ::commonmodule::ASG* mutable_ldcx();
  void set_allocated_ldcx(::commonmodule::ASG* ldcx);

  // .commonmodule.ASG LDCZ = 6;
  bool has_ldcz() const;
  void clear_ldcz();
  static const int kLDCZFieldNumber = 6;
  const ::commonmodule::ASG& ldcz() const;
  ::commonmodule::ASG* release_ldcz();
  ::commonmodule::ASG* mutable_ldcz();
  void set_allocated_ldcz(::commonmodule::ASG* ldcz);

  // .commonmodule.ControlSPC ParOp = 7;
  bool has_parop() const;
  void clear_parop();
  static const int kParOpFieldNumber = 7;
  const ::commonmodule::ControlSPC& parop() const;
  ::commonmodule::ControlSPC* release_parop();
  ::commonmodule::ControlSPC* mutable_parop();
  void set_allocated_parop(::commonmodule::ControlSPC* parop);

  // .commonmodule.ControlISC TapPos = 8;
  bool has_tappos() const;
  void clear_tappos();
  static const int kTapPosFieldNumber = 8;
  const ::commonmodule::ControlISC& tappos() const;
  ::commonmodule::ControlISC* release_tappos();
  ::commonmodule::ControlISC* mutable_tappos();
  void set_allocated_tappos(::commonmodule::ControlISC* tappos);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlATCC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ASG* bndctr_;
  ::commonmodule::ASG* bndwid_;
  ::commonmodule::ControlING* ctldltmms_;
  ::commonmodule::ASG* ldcr_;
  ::commonmodule::ASG* ldcx_;
  ::commonmodule::ASG* ldcz_;
  ::commonmodule::ControlSPC* parop_;
  ::commonmodule::ControlISC* tappos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorPoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorPoint) */ {
 public:
  RegulatorPoint();
  virtual ~RegulatorPoint();

  RegulatorPoint(const RegulatorPoint& from);

  inline RegulatorPoint& operator=(const RegulatorPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorPoint(RegulatorPoint&& from) noexcept
    : RegulatorPoint() {
    *this = ::std::move(from);
  }

  inline RegulatorPoint& operator=(RegulatorPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorPoint* internal_default_instance() {
    return reinterpret_cast<const RegulatorPoint*>(
               &_RegulatorPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RegulatorPoint* other);
  friend void swap(RegulatorPoint& a, RegulatorPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorPoint* New() const final {
    return CreateMaybeMessage<RegulatorPoint>(nullptr);
  }

  RegulatorPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorPoint& from);
  void MergeFrom(const RegulatorPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .regulatormodule.RegulatorControlATCC control = 1;
  bool has_control() const;
  void clear_control();
  static const int kControlFieldNumber = 1;
  const ::regulatormodule::RegulatorControlATCC& control() const;
  ::regulatormodule::RegulatorControlATCC* release_control();
  ::regulatormodule::RegulatorControlATCC* mutable_control();
  void set_allocated_control(::regulatormodule::RegulatorControlATCC* control);

  // .google.protobuf.FloatValue pctVDroop = 2;
  bool has_pctvdroop() const;
  void clear_pctvdroop();
  static const int kPctVDroopFieldNumber = 2;
  const ::google::protobuf::FloatValue& pctvdroop() const;
  ::google::protobuf::FloatValue* release_pctvdroop();
  ::google::protobuf::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop);

  // .commonmodule.RampRate rampRates = 3;
  bool has_ramprates() const;
  void clear_ramprates();
  static const int kRampRatesFieldNumber = 3;
  const ::commonmodule::RampRate& ramprates() const;
  ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);

  // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 4;
  bool has_reactivepwrsetpointenabled() const;
  void clear_reactivepwrsetpointenabled();
  static const int kReactivePwrSetPointEnabledFieldNumber = 4;
  const ::commonmodule::ControlDPC& reactivepwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_reactivepwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled);

  // .commonmodule.ControlDPC reset = 5;
  bool has_reset() const;
  void clear_reset();
  static const int kResetFieldNumber = 5;
  const ::commonmodule::ControlDPC& reset() const;
  ::commonmodule::ControlDPC* release_reset();
  ::commonmodule::ControlDPC* mutable_reset();
  void set_allocated_reset(::commonmodule::ControlDPC* reset);

  // .commonmodule.Optional_StateKind state = 6;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 6;
  const ::commonmodule::Optional_StateKind& state() const;
  ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);

  // .commonmodule.ControlDPC voltageSetPointEnabled = 7;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled();
  static const int kVoltageSetPointEnabledFieldNumber = 7;
  const ::commonmodule::ControlDPC& voltagesetpointenabled() const;
  ::commonmodule::ControlDPC* release_voltagesetpointenabled();
  ::commonmodule::ControlDPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled);

  // .commonmodule.Timestamp startTime = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 8;
  const ::commonmodule::Timestamp& starttime() const;
  ::commonmodule::Timestamp* release_starttime();
  ::commonmodule::Timestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::Timestamp* starttime);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorPoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::regulatormodule::RegulatorControlATCC* control_;
  ::google::protobuf::FloatValue* pctvdroop_;
  ::commonmodule::RampRate* ramprates_;
  ::commonmodule::ControlDPC* reactivepwrsetpointenabled_;
  ::commonmodule::ControlDPC* reset_;
  ::commonmodule::Optional_StateKind* state_;
  ::commonmodule::ControlDPC* voltagesetpointenabled_;
  ::commonmodule::Timestamp* starttime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorCSG :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorCSG) */ {
 public:
  RegulatorCSG();
  virtual ~RegulatorCSG();

  RegulatorCSG(const RegulatorCSG& from);

  inline RegulatorCSG& operator=(const RegulatorCSG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorCSG(RegulatorCSG&& from) noexcept
    : RegulatorCSG() {
    *this = ::std::move(from);
  }

  inline RegulatorCSG& operator=(RegulatorCSG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorCSG& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorCSG* internal_default_instance() {
    return reinterpret_cast<const RegulatorCSG*>(
               &_RegulatorCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RegulatorCSG* other);
  friend void swap(RegulatorCSG& a, RegulatorCSG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorCSG* New() const final {
    return CreateMaybeMessage<RegulatorCSG>(nullptr);
  }

  RegulatorCSG* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorCSG>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorCSG& from);
  void MergeFrom(const RegulatorCSG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorCSG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .regulatormodule.RegulatorPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  void clear_crvpts();
  static const int kCrvPtsFieldNumber = 1;
  ::regulatormodule::RegulatorPoint* mutable_crvpts(int index);
  ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorPoint >*
      mutable_crvpts();
  const ::regulatormodule::RegulatorPoint& crvpts(int index) const;
  ::regulatormodule::RegulatorPoint* add_crvpts();
  const ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorPoint >&
      crvpts() const;

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorCSG)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorPoint > crvpts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorControlScheduleFSCH :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlScheduleFSCH) */ {
 public:
  RegulatorControlScheduleFSCH();
  virtual ~RegulatorControlScheduleFSCH();

  RegulatorControlScheduleFSCH(const RegulatorControlScheduleFSCH& from);

  inline RegulatorControlScheduleFSCH& operator=(const RegulatorControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorControlScheduleFSCH(RegulatorControlScheduleFSCH&& from) noexcept
    : RegulatorControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline RegulatorControlScheduleFSCH& operator=(RegulatorControlScheduleFSCH&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorControlScheduleFSCH& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlScheduleFSCH*>(
               &_RegulatorControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RegulatorControlScheduleFSCH* other);
  friend void swap(RegulatorControlScheduleFSCH& a, RegulatorControlScheduleFSCH& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorControlScheduleFSCH* New() const final {
    return CreateMaybeMessage<RegulatorControlScheduleFSCH>(nullptr);
  }

  RegulatorControlScheduleFSCH* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorControlScheduleFSCH>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorControlScheduleFSCH& from);
  void MergeFrom(const RegulatorControlScheduleFSCH& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlScheduleFSCH* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .regulatormodule.RegulatorCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  void clear_valdcsg();
  static const int kValDCSGFieldNumber = 1;
  const ::regulatormodule::RegulatorCSG& valdcsg() const;
  ::regulatormodule::RegulatorCSG* release_valdcsg();
  ::regulatormodule::RegulatorCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::regulatormodule::RegulatorCSG* valdcsg);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlScheduleFSCH)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::regulatormodule::RegulatorCSG* valdcsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorControlFSCC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlFSCC) */ {
 public:
  RegulatorControlFSCC();
  virtual ~RegulatorControlFSCC();

  RegulatorControlFSCC(const RegulatorControlFSCC& from);

  inline RegulatorControlFSCC& operator=(const RegulatorControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorControlFSCC(RegulatorControlFSCC&& from) noexcept
    : RegulatorControlFSCC() {
    *this = ::std::move(from);
  }

  inline RegulatorControlFSCC& operator=(RegulatorControlFSCC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorControlFSCC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorControlFSCC* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlFSCC*>(
               &_RegulatorControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RegulatorControlFSCC* other);
  friend void swap(RegulatorControlFSCC& a, RegulatorControlFSCC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorControlFSCC* New() const final {
    return CreateMaybeMessage<RegulatorControlFSCC>(nullptr);
  }

  RegulatorControlFSCC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorControlFSCC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorControlFSCC& from);
  void MergeFrom(const RegulatorControlFSCC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlFSCC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  void clear_controlfscc();
  static const int kControlFSCCFieldNumber = 1;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);

  // .regulatormodule.RegulatorControlScheduleFSCH regulatorControlScheduleFSCH = 2;
  bool has_regulatorcontrolschedulefsch() const;
  void clear_regulatorcontrolschedulefsch();
  static const int kRegulatorControlScheduleFSCHFieldNumber = 2;
  const ::regulatormodule::RegulatorControlScheduleFSCH& regulatorcontrolschedulefsch() const;
  ::regulatormodule::RegulatorControlScheduleFSCH* release_regulatorcontrolschedulefsch();
  ::regulatormodule::RegulatorControlScheduleFSCH* mutable_regulatorcontrolschedulefsch();
  void set_allocated_regulatorcontrolschedulefsch(::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlFSCC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlFSCC* controlfscc_;
  ::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorControl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControl) */ {
 public:
  RegulatorControl();
  virtual ~RegulatorControl();

  RegulatorControl(const RegulatorControl& from);

  inline RegulatorControl& operator=(const RegulatorControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorControl(RegulatorControl&& from) noexcept
    : RegulatorControl() {
    *this = ::std::move(from);
  }

  inline RegulatorControl& operator=(RegulatorControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorControl* internal_default_instance() {
    return reinterpret_cast<const RegulatorControl*>(
               &_RegulatorControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RegulatorControl* other);
  friend void swap(RegulatorControl& a, RegulatorControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorControl* New() const final {
    return CreateMaybeMessage<RegulatorControl>(nullptr);
  }

  RegulatorControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorControl& from);
  void MergeFrom(const RegulatorControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue();
  static const int kControlValueFieldNumber = 1;
  const ::commonmodule::ControlValue& controlvalue() const;
  ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);

  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 2;
  const ::commonmodule::CheckConditions& check() const;
  ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);

  // .regulatormodule.RegulatorControlFSCC regulatorControlFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorcontrolfscc() const;
  void clear_regulatorcontrolfscc();
  static const int kRegulatorControlFSCCFieldNumber = 3;
  const ::regulatormodule::RegulatorControlFSCC& regulatorcontrolfscc() const;
  ::regulatormodule::RegulatorControlFSCC* release_regulatorcontrolfscc();
  ::regulatormodule::RegulatorControlFSCC* mutable_regulatorcontrolfscc();
  void set_allocated_regulatorcontrolfscc(::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlValue* controlvalue_;
  ::commonmodule::CheckConditions* check_;
  ::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorSystem :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorSystem) */ {
 public:
  RegulatorSystem();
  virtual ~RegulatorSystem();

  RegulatorSystem(const RegulatorSystem& from);

  inline RegulatorSystem& operator=(const RegulatorSystem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorSystem(RegulatorSystem&& from) noexcept
    : RegulatorSystem() {
    *this = ::std::move(from);
  }

  inline RegulatorSystem& operator=(RegulatorSystem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorSystem* internal_default_instance() {
    return reinterpret_cast<const RegulatorSystem*>(
               &_RegulatorSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RegulatorSystem* other);
  friend void swap(RegulatorSystem& a, RegulatorSystem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorSystem* New() const final {
    return CreateMaybeMessage<RegulatorSystem>(nullptr);
  }

  RegulatorSystem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorSystem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorSystem& from);
  void MergeFrom(const RegulatorSystem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment();
  static const int kConductingEquipmentFieldNumber = 1;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorSystem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipment* conductingequipment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorControlProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlProfile) */ {
 public:
  RegulatorControlProfile();
  virtual ~RegulatorControlProfile();

  RegulatorControlProfile(const RegulatorControlProfile& from);

  inline RegulatorControlProfile& operator=(const RegulatorControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorControlProfile(RegulatorControlProfile&& from) noexcept
    : RegulatorControlProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorControlProfile& operator=(RegulatorControlProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorControlProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorControlProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlProfile*>(
               &_RegulatorControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RegulatorControlProfile* other);
  friend void swap(RegulatorControlProfile& a, RegulatorControlProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorControlProfile* New() const final {
    return CreateMaybeMessage<RegulatorControlProfile>(nullptr);
  }

  RegulatorControlProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorControlProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorControlProfile& from);
  void MergeFrom(const RegulatorControlProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo();
  static const int kControlMessageInfoFieldNumber = 1;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .regulatormodule.RegulatorControl regulatorControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorcontrol() const;
  void clear_regulatorcontrol();
  static const int kRegulatorControlFieldNumber = 3;
  const ::regulatormodule::RegulatorControl& regulatorcontrol() const;
  ::regulatormodule::RegulatorControl* release_regulatorcontrol();
  ::regulatormodule::RegulatorControl* mutable_regulatorcontrol();
  void set_allocated_regulatorcontrol(::regulatormodule::RegulatorControl* regulatorcontrol);

  // .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem();
  static const int kRegulatorSystemFieldNumber = 4;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlMessageInfo* controlmessageinfo_;
  ::commonmodule::IED* ied_;
  ::regulatormodule::RegulatorControl* regulatorcontrol_;
  ::regulatormodule::RegulatorSystem* regulatorsystem_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorEventAndStatusATCC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventAndStatusATCC) */ {
 public:
  RegulatorEventAndStatusATCC();
  virtual ~RegulatorEventAndStatusATCC();

  RegulatorEventAndStatusATCC(const RegulatorEventAndStatusATCC& from);

  inline RegulatorEventAndStatusATCC& operator=(const RegulatorEventAndStatusATCC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorEventAndStatusATCC(RegulatorEventAndStatusATCC&& from) noexcept
    : RegulatorEventAndStatusATCC() {
    *this = ::std::move(from);
  }

  inline RegulatorEventAndStatusATCC& operator=(RegulatorEventAndStatusATCC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorEventAndStatusATCC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorEventAndStatusATCC* internal_default_instance() {
    return reinterpret_cast<const RegulatorEventAndStatusATCC*>(
               &_RegulatorEventAndStatusATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RegulatorEventAndStatusATCC* other);
  friend void swap(RegulatorEventAndStatusATCC& a, RegulatorEventAndStatusATCC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorEventAndStatusATCC* New() const final {
    return CreateMaybeMessage<RegulatorEventAndStatusATCC>(nullptr);
  }

  RegulatorEventAndStatusATCC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorEventAndStatusATCC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorEventAndStatusATCC& from);
  void MergeFrom(const RegulatorEventAndStatusATCC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEventAndStatusATCC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ASG BndCtr = 1;
  bool has_bndctr() const;
  void clear_bndctr();
  static const int kBndCtrFieldNumber = 1;
  const ::commonmodule::ASG& bndctr() const;
  ::commonmodule::ASG* release_bndctr();
  ::commonmodule::ASG* mutable_bndctr();
  void set_allocated_bndctr(::commonmodule::ASG* bndctr);

  // .commonmodule.ASG BndWid = 2;
  bool has_bndwid() const;
  void clear_bndwid();
  static const int kBndWidFieldNumber = 2;
  const ::commonmodule::ASG& bndwid() const;
  ::commonmodule::ASG* release_bndwid();
  ::commonmodule::ASG* mutable_bndwid();
  void set_allocated_bndwid(::commonmodule::ASG* bndwid);

  // .commonmodule.ASG LDCR = 3;
  bool has_ldcr() const;
  void clear_ldcr();
  static const int kLDCRFieldNumber = 3;
  const ::commonmodule::ASG& ldcr() const;
  ::commonmodule::ASG* release_ldcr();
  ::commonmodule::ASG* mutable_ldcr();
  void set_allocated_ldcr(::commonmodule::ASG* ldcr);

  // .commonmodule.ASG LDCX = 4;
  bool has_ldcx() const;
  void clear_ldcx();
  static const int kLDCXFieldNumber = 4;
  const ::commonmodule::ASG& ldcx() const;
  ::commonmodule::ASG* release_ldcx();
  ::commonmodule::ASG* mutable_ldcx();
  void set_allocated_ldcx(::commonmodule::ASG* ldcx);

  // .commonmodule.ASG LDCZ = 5;
  bool has_ldcz() const;
  void clear_ldcz();
  static const int kLDCZFieldNumber = 5;
  const ::commonmodule::ASG& ldcz() const;
  ::commonmodule::ASG* release_ldcz();
  ::commonmodule::ASG* mutable_ldcz();
  void set_allocated_ldcz(::commonmodule::ASG* ldcz);

  // .commonmodule.StatusSPC ParOp = 6;
  bool has_parop() const;
  void clear_parop();
  static const int kParOpFieldNumber = 6;
  const ::commonmodule::StatusSPC& parop() const;
  ::commonmodule::StatusSPC* release_parop();
  ::commonmodule::StatusSPC* mutable_parop();
  void set_allocated_parop(::commonmodule::StatusSPC* parop);

  // .commonmodule.StatusSPS TapOpErr = 7;
  bool has_tapoperr() const;
  void clear_tapoperr();
  static const int kTapOpErrFieldNumber = 7;
  const ::commonmodule::StatusSPS& tapoperr() const;
  ::commonmodule::StatusSPS* release_tapoperr();
  ::commonmodule::StatusSPS* mutable_tapoperr();
  void set_allocated_tapoperr(::commonmodule::StatusSPS* tapoperr);

  // .commonmodule.StatusISC TapPos = 8;
  bool has_tappos() const;
  void clear_tappos();
  static const int kTapPosFieldNumber = 8;
  const ::commonmodule::StatusISC& tappos() const;
  ::commonmodule::StatusISC* release_tappos();
  ::commonmodule::StatusISC* mutable_tappos();
  void set_allocated_tappos(::commonmodule::StatusISC* tappos);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventAndStatusATCC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ASG* bndctr_;
  ::commonmodule::ASG* bndwid_;
  ::commonmodule::ASG* ldcr_;
  ::commonmodule::ASG* ldcx_;
  ::commonmodule::ASG* ldcz_;
  ::commonmodule::StatusSPC* parop_;
  ::commonmodule::StatusSPS* tapoperr_;
  ::commonmodule::StatusISC* tappos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorEventAndStatusPoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventAndStatusPoint) */ {
 public:
  RegulatorEventAndStatusPoint();
  virtual ~RegulatorEventAndStatusPoint();

  RegulatorEventAndStatusPoint(const RegulatorEventAndStatusPoint& from);

  inline RegulatorEventAndStatusPoint& operator=(const RegulatorEventAndStatusPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorEventAndStatusPoint(RegulatorEventAndStatusPoint&& from) noexcept
    : RegulatorEventAndStatusPoint() {
    *this = ::std::move(from);
  }

  inline RegulatorEventAndStatusPoint& operator=(RegulatorEventAndStatusPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorEventAndStatusPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorEventAndStatusPoint* internal_default_instance() {
    return reinterpret_cast<const RegulatorEventAndStatusPoint*>(
               &_RegulatorEventAndStatusPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(RegulatorEventAndStatusPoint* other);
  friend void swap(RegulatorEventAndStatusPoint& a, RegulatorEventAndStatusPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorEventAndStatusPoint* New() const final {
    return CreateMaybeMessage<RegulatorEventAndStatusPoint>(nullptr);
  }

  RegulatorEventAndStatusPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorEventAndStatusPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorEventAndStatusPoint& from);
  void MergeFrom(const RegulatorEventAndStatusPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEventAndStatusPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .regulatormodule.RegulatorEventAndStatusATCC eventAndStatus = 1;
  bool has_eventandstatus() const;
  void clear_eventandstatus();
  static const int kEventAndStatusFieldNumber = 1;
  const ::regulatormodule::RegulatorEventAndStatusATCC& eventandstatus() const;
  ::regulatormodule::RegulatorEventAndStatusATCC* release_eventandstatus();
  ::regulatormodule::RegulatorEventAndStatusATCC* mutable_eventandstatus();
  void set_allocated_eventandstatus(::regulatormodule::RegulatorEventAndStatusATCC* eventandstatus);

  // .google.protobuf.FloatValue pctVDroop = 2;
  bool has_pctvdroop() const;
  void clear_pctvdroop();
  static const int kPctVDroopFieldNumber = 2;
  const ::google::protobuf::FloatValue& pctvdroop() const;
  ::google::protobuf::FloatValue* release_pctvdroop();
  ::google::protobuf::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop);

  // .commonmodule.RampRate rampRates = 3;
  bool has_ramprates() const;
  void clear_ramprates();
  static const int kRampRatesFieldNumber = 3;
  const ::commonmodule::RampRate& ramprates() const;
  ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);

  // .commonmodule.StatusSPC reactivePwrSetPointEnabled = 4;
  bool has_reactivepwrsetpointenabled() const;
  void clear_reactivepwrsetpointenabled();
  static const int kReactivePwrSetPointEnabledFieldNumber = 4;
  const ::commonmodule::StatusSPC& reactivepwrsetpointenabled() const;
  ::commonmodule::StatusSPC* release_reactivepwrsetpointenabled();
  ::commonmodule::StatusSPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPC* reactivepwrsetpointenabled);

  // .commonmodule.Optional_StateKind state = 5;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  const ::commonmodule::Optional_StateKind& state() const;
  ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);

  // .commonmodule.StatusSPC voltageSetPointEnabled = 6;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled();
  static const int kVoltageSetPointEnabledFieldNumber = 6;
  const ::commonmodule::StatusSPC& voltagesetpointenabled() const;
  ::commonmodule::StatusSPC* release_voltagesetpointenabled();
  ::commonmodule::StatusSPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::StatusSPC* voltagesetpointenabled);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventAndStatusPoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::regulatormodule::RegulatorEventAndStatusATCC* eventandstatus_;
  ::google::protobuf::FloatValue* pctvdroop_;
  ::commonmodule::RampRate* ramprates_;
  ::commonmodule::StatusSPC* reactivepwrsetpointenabled_;
  ::commonmodule::Optional_StateKind* state_;
  ::commonmodule::StatusSPC* voltagesetpointenabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorEventAndStatusANCR :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventAndStatusANCR) */ {
 public:
  RegulatorEventAndStatusANCR();
  virtual ~RegulatorEventAndStatusANCR();

  RegulatorEventAndStatusANCR(const RegulatorEventAndStatusANCR& from);

  inline RegulatorEventAndStatusANCR& operator=(const RegulatorEventAndStatusANCR& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorEventAndStatusANCR(RegulatorEventAndStatusANCR&& from) noexcept
    : RegulatorEventAndStatusANCR() {
    *this = ::std::move(from);
  }

  inline RegulatorEventAndStatusANCR& operator=(RegulatorEventAndStatusANCR&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorEventAndStatusANCR& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorEventAndStatusANCR* internal_default_instance() {
    return reinterpret_cast<const RegulatorEventAndStatusANCR*>(
               &_RegulatorEventAndStatusANCR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RegulatorEventAndStatusANCR* other);
  friend void swap(RegulatorEventAndStatusANCR& a, RegulatorEventAndStatusANCR& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorEventAndStatusANCR* New() const final {
    return CreateMaybeMessage<RegulatorEventAndStatusANCR>(nullptr);
  }

  RegulatorEventAndStatusANCR* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorEventAndStatusANCR>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorEventAndStatusANCR& from);
  void MergeFrom(const RegulatorEventAndStatusANCR& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEventAndStatusANCR* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  void clear_dynamictest();
  static const int kDynamicTestFieldNumber = 2;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);

  // .regulatormodule.RegulatorEventAndStatusPoint PointStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pointstatus() const;
  void clear_pointstatus();
  static const int kPointStatusFieldNumber = 3;
  const ::regulatormodule::RegulatorEventAndStatusPoint& pointstatus() const;
  ::regulatormodule::RegulatorEventAndStatusPoint* release_pointstatus();
  ::regulatormodule::RegulatorEventAndStatusPoint* mutable_pointstatus();
  void set_allocated_pointstatus(::regulatormodule::RegulatorEventAndStatusPoint* pointstatus);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventAndStatusANCR)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::ENS_DynamicTestKind* dynamictest_;
  ::regulatormodule::RegulatorEventAndStatusPoint* pointstatus_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEvent) */ {
 public:
  RegulatorEvent();
  virtual ~RegulatorEvent();

  RegulatorEvent(const RegulatorEvent& from);

  inline RegulatorEvent& operator=(const RegulatorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorEvent(RegulatorEvent&& from) noexcept
    : RegulatorEvent() {
    *this = ::std::move(from);
  }

  inline RegulatorEvent& operator=(RegulatorEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorEvent* internal_default_instance() {
    return reinterpret_cast<const RegulatorEvent*>(
               &_RegulatorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RegulatorEvent* other);
  friend void swap(RegulatorEvent& a, RegulatorEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorEvent* New() const final {
    return CreateMaybeMessage<RegulatorEvent>(nullptr);
  }

  RegulatorEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorEvent& from);
  void MergeFrom(const RegulatorEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  void clear_eventvalue();
  static const int kEventValueFieldNumber = 1;
  const ::commonmodule::EventValue& eventvalue() const;
  ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);

  // .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatoreventandstatusancr() const;
  void clear_regulatoreventandstatusancr();
  static const int kRegulatorEventAndStatusANCRFieldNumber = 2;
  const ::regulatormodule::RegulatorEventAndStatusANCR& regulatoreventandstatusancr() const;
  ::regulatormodule::RegulatorEventAndStatusANCR* release_regulatoreventandstatusancr();
  ::regulatormodule::RegulatorEventAndStatusANCR* mutable_regulatoreventandstatusancr();
  void set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventValue* eventvalue_;
  ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorEventProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventProfile) */ {
 public:
  RegulatorEventProfile();
  virtual ~RegulatorEventProfile();

  RegulatorEventProfile(const RegulatorEventProfile& from);

  inline RegulatorEventProfile& operator=(const RegulatorEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorEventProfile(RegulatorEventProfile&& from) noexcept
    : RegulatorEventProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorEventProfile& operator=(RegulatorEventProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorEventProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorEventProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorEventProfile*>(
               &_RegulatorEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RegulatorEventProfile* other);
  friend void swap(RegulatorEventProfile& a, RegulatorEventProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorEventProfile* New() const final {
    return CreateMaybeMessage<RegulatorEventProfile>(nullptr);
  }

  RegulatorEventProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorEventProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorEventProfile& from);
  void MergeFrom(const RegulatorEventProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEventProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  void clear_eventmessageinfo();
  static const int kEventMessageInfoFieldNumber = 1;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .regulatormodule.RegulatorEvent regulatorEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorevent() const;
  void clear_regulatorevent();
  static const int kRegulatorEventFieldNumber = 3;
  const ::regulatormodule::RegulatorEvent& regulatorevent() const;
  ::regulatormodule::RegulatorEvent* release_regulatorevent();
  ::regulatormodule::RegulatorEvent* mutable_regulatorevent();
  void set_allocated_regulatorevent(::regulatormodule::RegulatorEvent* regulatorevent);

  // .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem();
  static const int kRegulatorSystemFieldNumber = 4;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventMessageInfo* eventmessageinfo_;
  ::commonmodule::IED* ied_;
  ::regulatormodule::RegulatorEvent* regulatorevent_;
  ::regulatormodule::RegulatorSystem* regulatorsystem_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorReading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorReading) */ {
 public:
  RegulatorReading();
  virtual ~RegulatorReading();

  RegulatorReading(const RegulatorReading& from);

  inline RegulatorReading& operator=(const RegulatorReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorReading(RegulatorReading&& from) noexcept
    : RegulatorReading() {
    *this = ::std::move(from);
  }

  inline RegulatorReading& operator=(RegulatorReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorReading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorReading* internal_default_instance() {
    return reinterpret_cast<const RegulatorReading*>(
               &_RegulatorReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RegulatorReading* other);
  friend void swap(RegulatorReading& a, RegulatorReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorReading* New() const final {
    return CreateMaybeMessage<RegulatorReading>(nullptr);
  }

  RegulatorReading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorReading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorReading& from);
  void MergeFrom(const RegulatorReading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  void clear_conductingequipmentterminalreading();
  static const int kConductingEquipmentTerminalReadingFieldNumber = 1;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);

  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  void clear_phasemmtn();
  static const int kPhaseMMTNFieldNumber = 2;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);

  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  void clear_readingmmtr();
  static const int kReadingMMTRFieldNumber = 3;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);

  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  void clear_readingmmxu();
  static const int kReadingMMXUFieldNumber = 4;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorReading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
  ::commonmodule::PhaseMMTN* phasemmtn_;
  ::commonmodule::ReadingMMTR* readingmmtr_;
  ::commonmodule::ReadingMMXU* readingmmxu_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorReadingProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorReadingProfile) */ {
 public:
  RegulatorReadingProfile();
  virtual ~RegulatorReadingProfile();

  RegulatorReadingProfile(const RegulatorReadingProfile& from);

  inline RegulatorReadingProfile& operator=(const RegulatorReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorReadingProfile(RegulatorReadingProfile&& from) noexcept
    : RegulatorReadingProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorReadingProfile& operator=(RegulatorReadingProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorReadingProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorReadingProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorReadingProfile*>(
               &_RegulatorReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RegulatorReadingProfile* other);
  friend void swap(RegulatorReadingProfile& a, RegulatorReadingProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorReadingProfile* New() const final {
    return CreateMaybeMessage<RegulatorReadingProfile>(nullptr);
  }

  RegulatorReadingProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorReadingProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorReadingProfile& from);
  void MergeFrom(const RegulatorReadingProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorReadingProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .regulatormodule.RegulatorReading regulatorReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
  int regulatorreading_size() const;
  void clear_regulatorreading();
  static const int kRegulatorReadingFieldNumber = 3;
  ::regulatormodule::RegulatorReading* mutable_regulatorreading(int index);
  ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorReading >*
      mutable_regulatorreading();
  const ::regulatormodule::RegulatorReading& regulatorreading(int index) const;
  ::regulatormodule::RegulatorReading* add_regulatorreading();
  const ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorReading >&
      regulatorreading() const;

  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  void clear_readingmessageinfo();
  static const int kReadingMessageInfoFieldNumber = 1;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem();
  static const int kRegulatorSystemFieldNumber = 4;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorReadingProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorReading > regulatorreading_;
  ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
  ::commonmodule::IED* ied_;
  ::regulatormodule::RegulatorSystem* regulatorsystem_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorStatus) */ {
 public:
  RegulatorStatus();
  virtual ~RegulatorStatus();

  RegulatorStatus(const RegulatorStatus& from);

  inline RegulatorStatus& operator=(const RegulatorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorStatus(RegulatorStatus&& from) noexcept
    : RegulatorStatus() {
    *this = ::std::move(from);
  }

  inline RegulatorStatus& operator=(RegulatorStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorStatus* internal_default_instance() {
    return reinterpret_cast<const RegulatorStatus*>(
               &_RegulatorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RegulatorStatus* other);
  friend void swap(RegulatorStatus& a, RegulatorStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorStatus* New() const final {
    return CreateMaybeMessage<RegulatorStatus>(nullptr);
  }

  RegulatorStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorStatus& from);
  void MergeFrom(const RegulatorStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  void clear_statusvalue();
  static const int kStatusValueFieldNumber = 1;
  const ::commonmodule::StatusValue& statusvalue() const;
  ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);

  // .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatoreventandstatusancr() const;
  void clear_regulatoreventandstatusancr();
  static const int kRegulatorEventAndStatusANCRFieldNumber = 2;
  const ::regulatormodule::RegulatorEventAndStatusANCR& regulatoreventandstatusancr() const;
  ::regulatormodule::RegulatorEventAndStatusANCR* release_regulatoreventandstatusancr();
  ::regulatormodule::RegulatorEventAndStatusANCR* mutable_regulatoreventandstatusancr();
  void set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusValue* statusvalue_;
  ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// -------------------------------------------------------------------

class RegulatorStatusProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorStatusProfile) */ {
 public:
  RegulatorStatusProfile();
  virtual ~RegulatorStatusProfile();

  RegulatorStatusProfile(const RegulatorStatusProfile& from);

  inline RegulatorStatusProfile& operator=(const RegulatorStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegulatorStatusProfile(RegulatorStatusProfile&& from) noexcept
    : RegulatorStatusProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorStatusProfile& operator=(RegulatorStatusProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegulatorStatusProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegulatorStatusProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorStatusProfile*>(
               &_RegulatorStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RegulatorStatusProfile* other);
  friend void swap(RegulatorStatusProfile& a, RegulatorStatusProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegulatorStatusProfile* New() const final {
    return CreateMaybeMessage<RegulatorStatusProfile>(nullptr);
  }

  RegulatorStatusProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegulatorStatusProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegulatorStatusProfile& from);
  void MergeFrom(const RegulatorStatusProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorStatusProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  void clear_statusmessageinfo();
  static const int kStatusMessageInfoFieldNumber = 1;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .regulatormodule.RegulatorStatus regulatorStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorstatus() const;
  void clear_regulatorstatus();
  static const int kRegulatorStatusFieldNumber = 3;
  const ::regulatormodule::RegulatorStatus& regulatorstatus() const;
  ::regulatormodule::RegulatorStatus* release_regulatorstatus();
  ::regulatormodule::RegulatorStatus* mutable_regulatorstatus();
  void set_allocated_regulatorstatus(::regulatormodule::RegulatorStatus* regulatorstatus);

  // .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem();
  static const int kRegulatorSystemFieldNumber = 4;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);

  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorStatusProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusMessageInfo* statusmessageinfo_;
  ::commonmodule::IED* ied_;
  ::regulatormodule::RegulatorStatus* regulatorstatus_;
  ::regulatormodule::RegulatorSystem* regulatorsystem_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegulatorControlATCC

// .commonmodule.ASG BndCtr = 1;
inline bool RegulatorControlATCC::has_bndctr() const {
  return this != internal_default_instance() && bndctr_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorControlATCC::bndctr() const {
  const ::commonmodule::ASG* p = bndctr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.BndCtr)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorControlATCC::release_bndctr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.BndCtr)
  
  ::commonmodule::ASG* temp = bndctr_;
  bndctr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorControlATCC::mutable_bndctr() {
  
  if (bndctr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    bndctr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.BndCtr)
  return bndctr_;
}
inline void RegulatorControlATCC::set_allocated_bndctr(::commonmodule::ASG* bndctr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bndctr_);
  }
  if (bndctr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bndctr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bndctr, submessage_arena);
    }
    
  } else {
    
  }
  bndctr_ = bndctr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.BndCtr)
}

// .commonmodule.ASG BndWid = 2;
inline bool RegulatorControlATCC::has_bndwid() const {
  return this != internal_default_instance() && bndwid_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorControlATCC::bndwid() const {
  const ::commonmodule::ASG* p = bndwid_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.BndWid)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorControlATCC::release_bndwid() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.BndWid)
  
  ::commonmodule::ASG* temp = bndwid_;
  bndwid_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorControlATCC::mutable_bndwid() {
  
  if (bndwid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    bndwid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.BndWid)
  return bndwid_;
}
inline void RegulatorControlATCC::set_allocated_bndwid(::commonmodule::ASG* bndwid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bndwid_);
  }
  if (bndwid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bndwid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bndwid, submessage_arena);
    }
    
  } else {
    
  }
  bndwid_ = bndwid;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.BndWid)
}

// .commonmodule.ControlING CtlDlTmms = 3;
inline bool RegulatorControlATCC::has_ctldltmms() const {
  return this != internal_default_instance() && ctldltmms_ != nullptr;
}
inline const ::commonmodule::ControlING& RegulatorControlATCC::ctldltmms() const {
  const ::commonmodule::ControlING* p = ctldltmms_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.CtlDlTmms)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlING*>(
      &::commonmodule::_ControlING_default_instance_);
}
inline ::commonmodule::ControlING* RegulatorControlATCC::release_ctldltmms() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.CtlDlTmms)
  
  ::commonmodule::ControlING* temp = ctldltmms_;
  ctldltmms_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* RegulatorControlATCC::mutable_ctldltmms() {
  
  if (ctldltmms_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlING>(GetArenaNoVirtual());
    ctldltmms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.CtlDlTmms)
  return ctldltmms_;
}
inline void RegulatorControlATCC::set_allocated_ctldltmms(::commonmodule::ControlING* ctldltmms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ctldltmms_);
  }
  if (ctldltmms) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ctldltmms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctldltmms, submessage_arena);
    }
    
  } else {
    
  }
  ctldltmms_ = ctldltmms;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.CtlDlTmms)
}

// .commonmodule.ASG LDCR = 4;
inline bool RegulatorControlATCC::has_ldcr() const {
  return this != internal_default_instance() && ldcr_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorControlATCC::ldcr() const {
  const ::commonmodule::ASG* p = ldcr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.LDCR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorControlATCC::release_ldcr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.LDCR)
  
  ::commonmodule::ASG* temp = ldcr_;
  ldcr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorControlATCC::mutable_ldcr() {
  
  if (ldcr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    ldcr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.LDCR)
  return ldcr_;
}
inline void RegulatorControlATCC::set_allocated_ldcr(::commonmodule::ASG* ldcr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ldcr_);
  }
  if (ldcr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ldcr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ldcr, submessage_arena);
    }
    
  } else {
    
  }
  ldcr_ = ldcr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.LDCR)
}

// .commonmodule.ASG LDCX = 5;
inline bool RegulatorControlATCC::has_ldcx() const {
  return this != internal_default_instance() && ldcx_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorControlATCC::ldcx() const {
  const ::commonmodule::ASG* p = ldcx_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.LDCX)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorControlATCC::release_ldcx() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.LDCX)
  
  ::commonmodule::ASG* temp = ldcx_;
  ldcx_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorControlATCC::mutable_ldcx() {
  
  if (ldcx_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    ldcx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.LDCX)
  return ldcx_;
}
inline void RegulatorControlATCC::set_allocated_ldcx(::commonmodule::ASG* ldcx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ldcx_);
  }
  if (ldcx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ldcx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ldcx, submessage_arena);
    }
    
  } else {
    
  }
  ldcx_ = ldcx;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.LDCX)
}

// .commonmodule.ASG LDCZ = 6;
inline bool RegulatorControlATCC::has_ldcz() const {
  return this != internal_default_instance() && ldcz_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorControlATCC::ldcz() const {
  const ::commonmodule::ASG* p = ldcz_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.LDCZ)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorControlATCC::release_ldcz() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.LDCZ)
  
  ::commonmodule::ASG* temp = ldcz_;
  ldcz_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorControlATCC::mutable_ldcz() {
  
  if (ldcz_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    ldcz_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.LDCZ)
  return ldcz_;
}
inline void RegulatorControlATCC::set_allocated_ldcz(::commonmodule::ASG* ldcz) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ldcz_);
  }
  if (ldcz) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ldcz = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ldcz, submessage_arena);
    }
    
  } else {
    
  }
  ldcz_ = ldcz;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.LDCZ)
}

// .commonmodule.ControlSPC ParOp = 7;
inline bool RegulatorControlATCC::has_parop() const {
  return this != internal_default_instance() && parop_ != nullptr;
}
inline const ::commonmodule::ControlSPC& RegulatorControlATCC::parop() const {
  const ::commonmodule::ControlSPC* p = parop_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.ParOp)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlSPC*>(
      &::commonmodule::_ControlSPC_default_instance_);
}
inline ::commonmodule::ControlSPC* RegulatorControlATCC::release_parop() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.ParOp)
  
  ::commonmodule::ControlSPC* temp = parop_;
  parop_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* RegulatorControlATCC::mutable_parop() {
  
  if (parop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaNoVirtual());
    parop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.ParOp)
  return parop_;
}
inline void RegulatorControlATCC::set_allocated_parop(::commonmodule::ControlSPC* parop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parop_);
  }
  if (parop) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parop, submessage_arena);
    }
    
  } else {
    
  }
  parop_ = parop;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.ParOp)
}

// .commonmodule.ControlISC TapPos = 8;
inline bool RegulatorControlATCC::has_tappos() const {
  return this != internal_default_instance() && tappos_ != nullptr;
}
inline const ::commonmodule::ControlISC& RegulatorControlATCC::tappos() const {
  const ::commonmodule::ControlISC* p = tappos_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.TapPos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlISC*>(
      &::commonmodule::_ControlISC_default_instance_);
}
inline ::commonmodule::ControlISC* RegulatorControlATCC::release_tappos() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.TapPos)
  
  ::commonmodule::ControlISC* temp = tappos_;
  tappos_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlISC* RegulatorControlATCC::mutable_tappos() {
  
  if (tappos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlISC>(GetArenaNoVirtual());
    tappos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.TapPos)
  return tappos_;
}
inline void RegulatorControlATCC::set_allocated_tappos(::commonmodule::ControlISC* tappos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tappos_);
  }
  if (tappos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tappos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tappos, submessage_arena);
    }
    
  } else {
    
  }
  tappos_ = tappos;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.TapPos)
}

// -------------------------------------------------------------------

// RegulatorPoint

// .regulatormodule.RegulatorControlATCC control = 1;
inline bool RegulatorPoint::has_control() const {
  return this != internal_default_instance() && control_ != nullptr;
}
inline void RegulatorPoint::clear_control() {
  if (GetArenaNoVirtual() == nullptr && control_ != nullptr) {
    delete control_;
  }
  control_ = nullptr;
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorPoint::control() const {
  const ::regulatormodule::RegulatorControlATCC* p = control_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.control)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorControlATCC*>(
      &::regulatormodule::_RegulatorControlATCC_default_instance_);
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorPoint::release_control() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.control)
  
  ::regulatormodule::RegulatorControlATCC* temp = control_;
  control_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorPoint::mutable_control() {
  
  if (control_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControlATCC>(GetArenaNoVirtual());
    control_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.control)
  return control_;
}
inline void RegulatorPoint::set_allocated_control(::regulatormodule::RegulatorControlATCC* control) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete control_;
  }
  if (control) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      control = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }
    
  } else {
    
  }
  control_ = control;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.control)
}

// .google.protobuf.FloatValue pctVDroop = 2;
inline bool RegulatorPoint::has_pctvdroop() const {
  return this != internal_default_instance() && pctvdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& RegulatorPoint::pctvdroop() const {
  const ::google::protobuf::FloatValue* p = pctvdroop_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.pctVDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* RegulatorPoint::release_pctvdroop() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.pctVDroop)
  
  ::google::protobuf::FloatValue* temp = pctvdroop_;
  pctvdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* RegulatorPoint::mutable_pctvdroop() {
  
  if (pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pctvdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.pctVDroop)
  return pctvdroop_;
}
inline void RegulatorPoint::set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pctvdroop_);
  }
  if (pctvdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pctvdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pctvdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }
    
  } else {
    
  }
  pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.pctVDroop)
}

// .commonmodule.RampRate rampRates = 3;
inline bool RegulatorPoint::has_ramprates() const {
  return this != internal_default_instance() && ramprates_ != nullptr;
}
inline const ::commonmodule::RampRate& RegulatorPoint::ramprates() const {
  const ::commonmodule::RampRate* p = ramprates_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.rampRates)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::RampRate*>(
      &::commonmodule::_RampRate_default_instance_);
}
inline ::commonmodule::RampRate* RegulatorPoint::release_ramprates() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.rampRates)
  
  ::commonmodule::RampRate* temp = ramprates_;
  ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* RegulatorPoint::mutable_ramprates() {
  
  if (ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaNoVirtual());
    ramprates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.rampRates)
  return ramprates_;
}
inline void RegulatorPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ramprates_);
  }
  if (ramprates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ramprates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }
    
  } else {
    
  }
  ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.rampRates)
}

// .commonmodule.ControlDPC reactivePwrSetPointEnabled = 4;
inline bool RegulatorPoint::has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && reactivepwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& RegulatorPoint::reactivepwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = reactivepwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.reactivePwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* RegulatorPoint::release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.reactivePwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = reactivepwrsetpointenabled_;
  reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* RegulatorPoint::mutable_reactivepwrsetpointenabled() {
  
  if (reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reactivepwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.reactivePwrSetPointEnabled)
  return reactivepwrsetpointenabled_;
}
inline void RegulatorPoint::set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.reactivePwrSetPointEnabled)
}

// .commonmodule.ControlDPC reset = 5;
inline bool RegulatorPoint::has_reset() const {
  return this != internal_default_instance() && reset_ != nullptr;
}
inline const ::commonmodule::ControlDPC& RegulatorPoint::reset() const {
  const ::commonmodule::ControlDPC* p = reset_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.reset)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* RegulatorPoint::release_reset() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.reset)
  
  ::commonmodule::ControlDPC* temp = reset_;
  reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* RegulatorPoint::mutable_reset() {
  
  if (reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.reset)
  return reset_;
}
inline void RegulatorPoint::set_allocated_reset(::commonmodule::ControlDPC* reset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reset_);
  }
  if (reset) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }
    
  } else {
    
  }
  reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.reset)
}

// .commonmodule.Optional_StateKind state = 6;
inline bool RegulatorPoint::has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline const ::commonmodule::Optional_StateKind& RegulatorPoint::state() const {
  const ::commonmodule::Optional_StateKind* p = state_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.state)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_StateKind*>(
      &::commonmodule::_Optional_StateKind_default_instance_);
}
inline ::commonmodule::Optional_StateKind* RegulatorPoint::release_state() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.state)
  
  ::commonmodule::Optional_StateKind* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* RegulatorPoint::mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.state)
  return state_;
}
inline void RegulatorPoint::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.state)
}

// .commonmodule.ControlDPC voltageSetPointEnabled = 7;
inline bool RegulatorPoint::has_voltagesetpointenabled() const {
  return this != internal_default_instance() && voltagesetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& RegulatorPoint::voltagesetpointenabled() const {
  const ::commonmodule::ControlDPC* p = voltagesetpointenabled_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.voltageSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* RegulatorPoint::release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.voltageSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = voltagesetpointenabled_;
  voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* RegulatorPoint::mutable_voltagesetpointenabled() {
  
  if (voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    voltagesetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.voltageSetPointEnabled)
  return voltagesetpointenabled_;
}
inline void RegulatorPoint::set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.voltageSetPointEnabled)
}

// .commonmodule.Timestamp startTime = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorPoint::has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline const ::commonmodule::Timestamp& RegulatorPoint::starttime() const {
  const ::commonmodule::Timestamp* p = starttime_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.startTime)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* RegulatorPoint::release_starttime() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.startTime)
  
  ::commonmodule::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* RegulatorPoint::mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    starttime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.startTime)
  return starttime_;
}
inline void RegulatorPoint::set_allocated_starttime(::commonmodule::Timestamp* starttime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starttime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.startTime)
}

// -------------------------------------------------------------------

// RegulatorCSG

// repeated .regulatormodule.RegulatorPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int RegulatorCSG::crvpts_size() const {
  return crvpts_.size();
}
inline void RegulatorCSG::clear_crvpts() {
  crvpts_.Clear();
}
inline ::regulatormodule::RegulatorPoint* RegulatorCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorCSG.crvPts)
  return crvpts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorPoint >*
RegulatorCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:regulatormodule.RegulatorCSG.crvPts)
  return &crvpts_;
}
inline const ::regulatormodule::RegulatorPoint& RegulatorCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorCSG.crvPts)
  return crvpts_.Get(index);
}
inline ::regulatormodule::RegulatorPoint* RegulatorCSG::add_crvpts() {
  // @@protoc_insertion_point(field_add:regulatormodule.RegulatorCSG.crvPts)
  return crvpts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorPoint >&
RegulatorCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:regulatormodule.RegulatorCSG.crvPts)
  return crvpts_;
}

// -------------------------------------------------------------------

// RegulatorControlScheduleFSCH

// .regulatormodule.RegulatorCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlScheduleFSCH::has_valdcsg() const {
  return this != internal_default_instance() && valdcsg_ != nullptr;
}
inline void RegulatorControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaNoVirtual() == nullptr && valdcsg_ != nullptr) {
    delete valdcsg_;
  }
  valdcsg_ = nullptr;
}
inline const ::regulatormodule::RegulatorCSG& RegulatorControlScheduleFSCH::valdcsg() const {
  const ::regulatormodule::RegulatorCSG* p = valdcsg_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorCSG*>(
      &::regulatormodule::_RegulatorCSG_default_instance_);
}
inline ::regulatormodule::RegulatorCSG* RegulatorControlScheduleFSCH::release_valdcsg() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  
  ::regulatormodule::RegulatorCSG* temp = valdcsg_;
  valdcsg_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorCSG* RegulatorControlScheduleFSCH::mutable_valdcsg() {
  
  if (valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorCSG>(GetArenaNoVirtual());
    valdcsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  return valdcsg_;
}
inline void RegulatorControlScheduleFSCH::set_allocated_valdcsg(::regulatormodule::RegulatorCSG* valdcsg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete valdcsg_;
  }
  if (valdcsg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      valdcsg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }
    
  } else {
    
  }
  valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// RegulatorControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlFSCC::has_controlfscc() const {
  return this != internal_default_instance() && controlfscc_ != nullptr;
}
inline const ::commonmodule::ControlFSCC& RegulatorControlFSCC::controlfscc() const {
  const ::commonmodule::ControlFSCC* p = controlfscc_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlFSCC.controlFSCC)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlFSCC*>(
      &::commonmodule::_ControlFSCC_default_instance_);
}
inline ::commonmodule::ControlFSCC* RegulatorControlFSCC::release_controlfscc() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = controlfscc_;
  controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* RegulatorControlFSCC::mutable_controlfscc() {
  
  if (controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaNoVirtual());
    controlfscc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlFSCC.controlFSCC)
  return controlfscc_;
}
inline void RegulatorControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlfscc_);
  }
  if (controlfscc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlfscc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }
    
  } else {
    
  }
  controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlFSCC.controlFSCC)
}

// .regulatormodule.RegulatorControlScheduleFSCH regulatorControlScheduleFSCH = 2;
inline bool RegulatorControlFSCC::has_regulatorcontrolschedulefsch() const {
  return this != internal_default_instance() && regulatorcontrolschedulefsch_ != nullptr;
}
inline void RegulatorControlFSCC::clear_regulatorcontrolschedulefsch() {
  if (GetArenaNoVirtual() == nullptr && regulatorcontrolschedulefsch_ != nullptr) {
    delete regulatorcontrolschedulefsch_;
  }
  regulatorcontrolschedulefsch_ = nullptr;
}
inline const ::regulatormodule::RegulatorControlScheduleFSCH& RegulatorControlFSCC::regulatorcontrolschedulefsch() const {
  const ::regulatormodule::RegulatorControlScheduleFSCH* p = regulatorcontrolschedulefsch_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorControlScheduleFSCH*>(
      &::regulatormodule::_RegulatorControlScheduleFSCH_default_instance_);
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* RegulatorControlFSCC::release_regulatorcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  
  ::regulatormodule::RegulatorControlScheduleFSCH* temp = regulatorcontrolschedulefsch_;
  regulatorcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* RegulatorControlFSCC::mutable_regulatorcontrolschedulefsch() {
  
  if (regulatorcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControlScheduleFSCH>(GetArenaNoVirtual());
    regulatorcontrolschedulefsch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  return regulatorcontrolschedulefsch_;
}
inline void RegulatorControlFSCC::set_allocated_regulatorcontrolschedulefsch(::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorcontrolschedulefsch_;
  }
  if (regulatorcontrolschedulefsch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorcontrolschedulefsch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorcontrolschedulefsch, submessage_arena);
    }
    
  } else {
    
  }
  regulatorcontrolschedulefsch_ = regulatorcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
}

// -------------------------------------------------------------------

// RegulatorControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControl::has_controlvalue() const {
  return this != internal_default_instance() && controlvalue_ != nullptr;
}
inline const ::commonmodule::ControlValue& RegulatorControl::controlvalue() const {
  const ::commonmodule::ControlValue* p = controlvalue_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.controlValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlValue*>(
      &::commonmodule::_ControlValue_default_instance_);
}
inline ::commonmodule::ControlValue* RegulatorControl::release_controlvalue() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.controlValue)
  
  ::commonmodule::ControlValue* temp = controlvalue_;
  controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* RegulatorControl::mutable_controlvalue() {
  
  if (controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaNoVirtual());
    controlvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.controlValue)
  return controlvalue_;
}
inline void RegulatorControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlvalue_);
  }
  if (controlvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }
    
  } else {
    
  }
  controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool RegulatorControl::has_check() const {
  return this != internal_default_instance() && check_ != nullptr;
}
inline const ::commonmodule::CheckConditions& RegulatorControl::check() const {
  const ::commonmodule::CheckConditions* p = check_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.check)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CheckConditions*>(
      &::commonmodule::_CheckConditions_default_instance_);
}
inline ::commonmodule::CheckConditions* RegulatorControl::release_check() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.check)
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* RegulatorControl::mutable_check() {
  
  if (check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaNoVirtual());
    check_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.check)
  return check_;
}
inline void RegulatorControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(check_);
  }
  if (check) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.check)
}

// .regulatormodule.RegulatorControlFSCC regulatorControlFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControl::has_regulatorcontrolfscc() const {
  return this != internal_default_instance() && regulatorcontrolfscc_ != nullptr;
}
inline void RegulatorControl::clear_regulatorcontrolfscc() {
  if (GetArenaNoVirtual() == nullptr && regulatorcontrolfscc_ != nullptr) {
    delete regulatorcontrolfscc_;
  }
  regulatorcontrolfscc_ = nullptr;
}
inline const ::regulatormodule::RegulatorControlFSCC& RegulatorControl::regulatorcontrolfscc() const {
  const ::regulatormodule::RegulatorControlFSCC* p = regulatorcontrolfscc_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.regulatorControlFSCC)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorControlFSCC*>(
      &::regulatormodule::_RegulatorControlFSCC_default_instance_);
}
inline ::regulatormodule::RegulatorControlFSCC* RegulatorControl::release_regulatorcontrolfscc() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.regulatorControlFSCC)
  
  ::regulatormodule::RegulatorControlFSCC* temp = regulatorcontrolfscc_;
  regulatorcontrolfscc_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlFSCC* RegulatorControl::mutable_regulatorcontrolfscc() {
  
  if (regulatorcontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControlFSCC>(GetArenaNoVirtual());
    regulatorcontrolfscc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.regulatorControlFSCC)
  return regulatorcontrolfscc_;
}
inline void RegulatorControl::set_allocated_regulatorcontrolfscc(::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorcontrolfscc_;
  }
  if (regulatorcontrolfscc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorcontrolfscc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorcontrolfscc, submessage_arena);
    }
    
  } else {
    
  }
  regulatorcontrolfscc_ = regulatorcontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.regulatorControlFSCC)
}

// -------------------------------------------------------------------

// RegulatorSystem

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorSystem::has_conductingequipment() const {
  return this != internal_default_instance() && conductingequipment_ != nullptr;
}
inline const ::commonmodule::ConductingEquipment& RegulatorSystem::conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = conductingequipment_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorSystem.conductingEquipment)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipment*>(
      &::commonmodule::_ConductingEquipment_default_instance_);
}
inline ::commonmodule::ConductingEquipment* RegulatorSystem::release_conductingequipment() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorSystem.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = conductingequipment_;
  conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* RegulatorSystem::mutable_conductingequipment() {
  
  if (conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaNoVirtual());
    conductingequipment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorSystem.conductingEquipment)
  return conductingequipment_;
}
inline void RegulatorSystem::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipment_);
  }
  if (conductingequipment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorSystem.conductingEquipment)
}

// -------------------------------------------------------------------

// RegulatorControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlProfile::has_controlmessageinfo() const {
  return this != internal_default_instance() && controlmessageinfo_ != nullptr;
}
inline const ::commonmodule::ControlMessageInfo& RegulatorControlProfile::controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = controlmessageinfo_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlMessageInfo*>(
      &::commonmodule::_ControlMessageInfo_default_instance_);
}
inline ::commonmodule::ControlMessageInfo* RegulatorControlProfile::release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* RegulatorControlProfile::mutable_controlmessageinfo() {
  
  if (controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaNoVirtual());
    controlmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  return controlmessageinfo_;
}
inline void RegulatorControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.controlMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& RegulatorControlProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* RegulatorControlProfile::release_ied() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* RegulatorControlProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.ied)
  return ied_;
}
inline void RegulatorControlProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.ied)
}

// .regulatormodule.RegulatorControl regulatorControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlProfile::has_regulatorcontrol() const {
  return this != internal_default_instance() && regulatorcontrol_ != nullptr;
}
inline void RegulatorControlProfile::clear_regulatorcontrol() {
  if (GetArenaNoVirtual() == nullptr && regulatorcontrol_ != nullptr) {
    delete regulatorcontrol_;
  }
  regulatorcontrol_ = nullptr;
}
inline const ::regulatormodule::RegulatorControl& RegulatorControlProfile::regulatorcontrol() const {
  const ::regulatormodule::RegulatorControl* p = regulatorcontrol_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.regulatorControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorControl*>(
      &::regulatormodule::_RegulatorControl_default_instance_);
}
inline ::regulatormodule::RegulatorControl* RegulatorControlProfile::release_regulatorcontrol() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.regulatorControl)
  
  ::regulatormodule::RegulatorControl* temp = regulatorcontrol_;
  regulatorcontrol_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControl* RegulatorControlProfile::mutable_regulatorcontrol() {
  
  if (regulatorcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControl>(GetArenaNoVirtual());
    regulatorcontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.regulatorControl)
  return regulatorcontrol_;
}
inline void RegulatorControlProfile::set_allocated_regulatorcontrol(::regulatormodule::RegulatorControl* regulatorcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorcontrol_;
  }
  if (regulatorcontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorcontrol, submessage_arena);
    }
    
  } else {
    
  }
  regulatorcontrol_ = regulatorcontrol;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.regulatorControl)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlProfile::has_regulatorsystem() const {
  return this != internal_default_instance() && regulatorsystem_ != nullptr;
}
inline void RegulatorControlProfile::clear_regulatorsystem() {
  if (GetArenaNoVirtual() == nullptr && regulatorsystem_ != nullptr) {
    delete regulatorsystem_;
  }
  regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorControlProfile::regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = regulatorsystem_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.regulatorSystem)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorSystem*>(
      &::regulatormodule::_RegulatorSystem_default_instance_);
}
inline ::regulatormodule::RegulatorSystem* RegulatorControlProfile::release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = regulatorsystem_;
  regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorControlProfile::mutable_regulatorsystem() {
  
  if (regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaNoVirtual());
    regulatorsystem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.regulatorSystem)
  return regulatorsystem_;
}
inline void RegulatorControlProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorsystem_;
  }
  if (regulatorsystem) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorsystem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }
    
  } else {
    
  }
  regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorEventAndStatusATCC

// .commonmodule.ASG BndCtr = 1;
inline bool RegulatorEventAndStatusATCC::has_bndctr() const {
  return this != internal_default_instance() && bndctr_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::bndctr() const {
  const ::commonmodule::ASG* p = bndctr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_bndctr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  
  ::commonmodule::ASG* temp = bndctr_;
  bndctr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_bndctr() {
  
  if (bndctr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    bndctr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  return bndctr_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndctr(::commonmodule::ASG* bndctr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bndctr_);
  }
  if (bndctr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bndctr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bndctr, submessage_arena);
    }
    
  } else {
    
  }
  bndctr_ = bndctr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
}

// .commonmodule.ASG BndWid = 2;
inline bool RegulatorEventAndStatusATCC::has_bndwid() const {
  return this != internal_default_instance() && bndwid_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::bndwid() const {
  const ::commonmodule::ASG* p = bndwid_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_bndwid() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  
  ::commonmodule::ASG* temp = bndwid_;
  bndwid_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_bndwid() {
  
  if (bndwid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    bndwid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  return bndwid_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndwid(::commonmodule::ASG* bndwid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bndwid_);
  }
  if (bndwid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bndwid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bndwid, submessage_arena);
    }
    
  } else {
    
  }
  bndwid_ = bndwid;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
}

// .commonmodule.ASG LDCR = 3;
inline bool RegulatorEventAndStatusATCC::has_ldcr() const {
  return this != internal_default_instance() && ldcr_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::ldcr() const {
  const ::commonmodule::ASG* p = ldcr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_ldcr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  
  ::commonmodule::ASG* temp = ldcr_;
  ldcr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_ldcr() {
  
  if (ldcr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    ldcr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  return ldcr_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ldcr(::commonmodule::ASG* ldcr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ldcr_);
  }
  if (ldcr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ldcr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ldcr, submessage_arena);
    }
    
  } else {
    
  }
  ldcr_ = ldcr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
}

// .commonmodule.ASG LDCX = 4;
inline bool RegulatorEventAndStatusATCC::has_ldcx() const {
  return this != internal_default_instance() && ldcx_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::ldcx() const {
  const ::commonmodule::ASG* p = ldcx_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_ldcx() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  
  ::commonmodule::ASG* temp = ldcx_;
  ldcx_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_ldcx() {
  
  if (ldcx_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    ldcx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  return ldcx_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ldcx(::commonmodule::ASG* ldcx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ldcx_);
  }
  if (ldcx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ldcx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ldcx, submessage_arena);
    }
    
  } else {
    
  }
  ldcx_ = ldcx;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
}

// .commonmodule.ASG LDCZ = 5;
inline bool RegulatorEventAndStatusATCC::has_ldcz() const {
  return this != internal_default_instance() && ldcz_ != nullptr;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::ldcz() const {
  const ::commonmodule::ASG* p = ldcz_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.LDCZ)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ASG*>(
      &::commonmodule::_ASG_default_instance_);
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_ldcz() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.LDCZ)
  
  ::commonmodule::ASG* temp = ldcz_;
  ldcz_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_ldcz() {
  
  if (ldcz_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaNoVirtual());
    ldcz_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.LDCZ)
  return ldcz_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ldcz(::commonmodule::ASG* ldcz) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ldcz_);
  }
  if (ldcz) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ldcz = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ldcz, submessage_arena);
    }
    
  } else {
    
  }
  ldcz_ = ldcz;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCZ)
}

// .commonmodule.StatusSPC ParOp = 6;
inline bool RegulatorEventAndStatusATCC::has_parop() const {
  return this != internal_default_instance() && parop_ != nullptr;
}
inline const ::commonmodule::StatusSPC& RegulatorEventAndStatusATCC::parop() const {
  const ::commonmodule::StatusSPC* p = parop_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPC*>(
      &::commonmodule::_StatusSPC_default_instance_);
}
inline ::commonmodule::StatusSPC* RegulatorEventAndStatusATCC::release_parop() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  
  ::commonmodule::StatusSPC* temp = parop_;
  parop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPC* RegulatorEventAndStatusATCC::mutable_parop() {
  
  if (parop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPC>(GetArenaNoVirtual());
    parop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  return parop_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_parop(::commonmodule::StatusSPC* parop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parop_);
  }
  if (parop) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parop, submessage_arena);
    }
    
  } else {
    
  }
  parop_ = parop;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
}

// .commonmodule.StatusSPS TapOpErr = 7;
inline bool RegulatorEventAndStatusATCC::has_tapoperr() const {
  return this != internal_default_instance() && tapoperr_ != nullptr;
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::tapoperr() const {
  const ::commonmodule::StatusSPS* p = tapoperr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::release_tapoperr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  
  ::commonmodule::StatusSPS* temp = tapoperr_;
  tapoperr_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::mutable_tapoperr() {
  
  if (tapoperr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    tapoperr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  return tapoperr_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_tapoperr(::commonmodule::StatusSPS* tapoperr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tapoperr_);
  }
  if (tapoperr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tapoperr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tapoperr, submessage_arena);
    }
    
  } else {
    
  }
  tapoperr_ = tapoperr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
}

// .commonmodule.StatusISC TapPos = 8;
inline bool RegulatorEventAndStatusATCC::has_tappos() const {
  return this != internal_default_instance() && tappos_ != nullptr;
}
inline const ::commonmodule::StatusISC& RegulatorEventAndStatusATCC::tappos() const {
  const ::commonmodule::StatusISC* p = tappos_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusISC*>(
      &::commonmodule::_StatusISC_default_instance_);
}
inline ::commonmodule::StatusISC* RegulatorEventAndStatusATCC::release_tappos() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  
  ::commonmodule::StatusISC* temp = tappos_;
  tappos_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusISC* RegulatorEventAndStatusATCC::mutable_tappos() {
  
  if (tappos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusISC>(GetArenaNoVirtual());
    tappos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  return tappos_;
}
inline void RegulatorEventAndStatusATCC::set_allocated_tappos(::commonmodule::StatusISC* tappos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tappos_);
  }
  if (tappos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tappos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tappos, submessage_arena);
    }
    
  } else {
    
  }
  tappos_ = tappos;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
}

// -------------------------------------------------------------------

// RegulatorEventAndStatusPoint

// .regulatormodule.RegulatorEventAndStatusATCC eventAndStatus = 1;
inline bool RegulatorEventAndStatusPoint::has_eventandstatus() const {
  return this != internal_default_instance() && eventandstatus_ != nullptr;
}
inline void RegulatorEventAndStatusPoint::clear_eventandstatus() {
  if (GetArenaNoVirtual() == nullptr && eventandstatus_ != nullptr) {
    delete eventandstatus_;
  }
  eventandstatus_ = nullptr;
}
inline const ::regulatormodule::RegulatorEventAndStatusATCC& RegulatorEventAndStatusPoint::eventandstatus() const {
  const ::regulatormodule::RegulatorEventAndStatusATCC* p = eventandstatus_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusPoint.eventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusATCC*>(
      &::regulatormodule::_RegulatorEventAndStatusATCC_default_instance_);
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* RegulatorEventAndStatusPoint::release_eventandstatus() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusPoint.eventAndStatus)
  
  ::regulatormodule::RegulatorEventAndStatusATCC* temp = eventandstatus_;
  eventandstatus_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* RegulatorEventAndStatusPoint::mutable_eventandstatus() {
  
  if (eventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusATCC>(GetArenaNoVirtual());
    eventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusPoint.eventAndStatus)
  return eventandstatus_;
}
inline void RegulatorEventAndStatusPoint::set_allocated_eventandstatus(::regulatormodule::RegulatorEventAndStatusATCC* eventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete eventandstatus_;
  }
  if (eventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  eventandstatus_ = eventandstatus;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusPoint.eventAndStatus)
}

// .google.protobuf.FloatValue pctVDroop = 2;
inline bool RegulatorEventAndStatusPoint::has_pctvdroop() const {
  return this != internal_default_instance() && pctvdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& RegulatorEventAndStatusPoint::pctvdroop() const {
  const ::google::protobuf::FloatValue* p = pctvdroop_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusPoint.pctVDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* RegulatorEventAndStatusPoint::release_pctvdroop() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusPoint.pctVDroop)
  
  ::google::protobuf::FloatValue* temp = pctvdroop_;
  pctvdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* RegulatorEventAndStatusPoint::mutable_pctvdroop() {
  
  if (pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pctvdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusPoint.pctVDroop)
  return pctvdroop_;
}
inline void RegulatorEventAndStatusPoint::set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pctvdroop_);
  }
  if (pctvdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pctvdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pctvdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }
    
  } else {
    
  }
  pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusPoint.pctVDroop)
}

// .commonmodule.RampRate rampRates = 3;
inline bool RegulatorEventAndStatusPoint::has_ramprates() const {
  return this != internal_default_instance() && ramprates_ != nullptr;
}
inline const ::commonmodule::RampRate& RegulatorEventAndStatusPoint::ramprates() const {
  const ::commonmodule::RampRate* p = ramprates_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusPoint.rampRates)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::RampRate*>(
      &::commonmodule::_RampRate_default_instance_);
}
inline ::commonmodule::RampRate* RegulatorEventAndStatusPoint::release_ramprates() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusPoint.rampRates)
  
  ::commonmodule::RampRate* temp = ramprates_;
  ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* RegulatorEventAndStatusPoint::mutable_ramprates() {
  
  if (ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaNoVirtual());
    ramprates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusPoint.rampRates)
  return ramprates_;
}
inline void RegulatorEventAndStatusPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ramprates_);
  }
  if (ramprates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ramprates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }
    
  } else {
    
  }
  ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusPoint.rampRates)
}

// .commonmodule.StatusSPC reactivePwrSetPointEnabled = 4;
inline bool RegulatorEventAndStatusPoint::has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && reactivepwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::StatusSPC& RegulatorEventAndStatusPoint::reactivepwrsetpointenabled() const {
  const ::commonmodule::StatusSPC* p = reactivepwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusPoint.reactivePwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPC*>(
      &::commonmodule::_StatusSPC_default_instance_);
}
inline ::commonmodule::StatusSPC* RegulatorEventAndStatusPoint::release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusPoint.reactivePwrSetPointEnabled)
  
  ::commonmodule::StatusSPC* temp = reactivepwrsetpointenabled_;
  reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPC* RegulatorEventAndStatusPoint::mutable_reactivepwrsetpointenabled() {
  
  if (reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPC>(GetArenaNoVirtual());
    reactivepwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusPoint.reactivePwrSetPointEnabled)
  return reactivepwrsetpointenabled_;
}
inline void RegulatorEventAndStatusPoint::set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPC* reactivepwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusPoint.reactivePwrSetPointEnabled)
}

// .commonmodule.Optional_StateKind state = 5;
inline bool RegulatorEventAndStatusPoint::has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline const ::commonmodule::Optional_StateKind& RegulatorEventAndStatusPoint::state() const {
  const ::commonmodule::Optional_StateKind* p = state_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusPoint.state)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_StateKind*>(
      &::commonmodule::_Optional_StateKind_default_instance_);
}
inline ::commonmodule::Optional_StateKind* RegulatorEventAndStatusPoint::release_state() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusPoint.state)
  
  ::commonmodule::Optional_StateKind* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* RegulatorEventAndStatusPoint::mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusPoint.state)
  return state_;
}
inline void RegulatorEventAndStatusPoint::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusPoint.state)
}

// .commonmodule.StatusSPC voltageSetPointEnabled = 6;
inline bool RegulatorEventAndStatusPoint::has_voltagesetpointenabled() const {
  return this != internal_default_instance() && voltagesetpointenabled_ != nullptr;
}
inline const ::commonmodule::StatusSPC& RegulatorEventAndStatusPoint::voltagesetpointenabled() const {
  const ::commonmodule::StatusSPC* p = voltagesetpointenabled_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusPoint.voltageSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPC*>(
      &::commonmodule::_StatusSPC_default_instance_);
}
inline ::commonmodule::StatusSPC* RegulatorEventAndStatusPoint::release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusPoint.voltageSetPointEnabled)
  
  ::commonmodule::StatusSPC* temp = voltagesetpointenabled_;
  voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPC* RegulatorEventAndStatusPoint::mutable_voltagesetpointenabled() {
  
  if (voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPC>(GetArenaNoVirtual());
    voltagesetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusPoint.voltageSetPointEnabled)
  return voltagesetpointenabled_;
}
inline void RegulatorEventAndStatusPoint::set_allocated_voltagesetpointenabled(::commonmodule::StatusSPC* voltagesetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusPoint.voltageSetPointEnabled)
}

// -------------------------------------------------------------------

// RegulatorEventAndStatusANCR

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEventAndStatusANCR::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& RegulatorEventAndStatusANCR::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* RegulatorEventAndStatusANCR::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* RegulatorEventAndStatusANCR::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void RegulatorEventAndStatusANCR::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool RegulatorEventAndStatusANCR::has_dynamictest() const {
  return this != internal_default_instance() && dynamictest_ != nullptr;
}
inline const ::commonmodule::ENS_DynamicTestKind& RegulatorEventAndStatusANCR::dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = dynamictest_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind*>(
      &::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline ::commonmodule::ENS_DynamicTestKind* RegulatorEventAndStatusANCR::release_dynamictest() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = dynamictest_;
  dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* RegulatorEventAndStatusANCR::mutable_dynamictest() {
  
  if (dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaNoVirtual());
    dynamictest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  return dynamictest_;
}
inline void RegulatorEventAndStatusANCR::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dynamictest_);
  }
  if (dynamictest) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamictest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }
    
  } else {
    
  }
  dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
}

// .regulatormodule.RegulatorEventAndStatusPoint PointStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventAndStatusANCR::has_pointstatus() const {
  return this != internal_default_instance() && pointstatus_ != nullptr;
}
inline void RegulatorEventAndStatusANCR::clear_pointstatus() {
  if (GetArenaNoVirtual() == nullptr && pointstatus_ != nullptr) {
    delete pointstatus_;
  }
  pointstatus_ = nullptr;
}
inline const ::regulatormodule::RegulatorEventAndStatusPoint& RegulatorEventAndStatusANCR::pointstatus() const {
  const ::regulatormodule::RegulatorEventAndStatusPoint* p = pointstatus_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusPoint*>(
      &::regulatormodule::_RegulatorEventAndStatusPoint_default_instance_);
}
inline ::regulatormodule::RegulatorEventAndStatusPoint* RegulatorEventAndStatusANCR::release_pointstatus() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  
  ::regulatormodule::RegulatorEventAndStatusPoint* temp = pointstatus_;
  pointstatus_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusPoint* RegulatorEventAndStatusANCR::mutable_pointstatus() {
  
  if (pointstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusPoint>(GetArenaNoVirtual());
    pointstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  return pointstatus_;
}
inline void RegulatorEventAndStatusANCR::set_allocated_pointstatus(::regulatormodule::RegulatorEventAndStatusPoint* pointstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pointstatus_;
  }
  if (pointstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pointstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pointstatus, submessage_arena);
    }
    
  } else {
    
  }
  pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
}

// -------------------------------------------------------------------

// RegulatorEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEvent::has_eventvalue() const {
  return this != internal_default_instance() && eventvalue_ != nullptr;
}
inline const ::commonmodule::EventValue& RegulatorEvent::eventvalue() const {
  const ::commonmodule::EventValue* p = eventvalue_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEvent.eventValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventValue*>(
      &::commonmodule::_EventValue_default_instance_);
}
inline ::commonmodule::EventValue* RegulatorEvent::release_eventvalue() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEvent.eventValue)
  
  ::commonmodule::EventValue* temp = eventvalue_;
  eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* RegulatorEvent::mutable_eventvalue() {
  
  if (eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaNoVirtual());
    eventvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEvent.eventValue)
  return eventvalue_;
}
inline void RegulatorEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventvalue_);
  }
  if (eventvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }
    
  } else {
    
  }
  eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEvent.eventValue)
}

// .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEvent::has_regulatoreventandstatusancr() const {
  return this != internal_default_instance() && regulatoreventandstatusancr_ != nullptr;
}
inline void RegulatorEvent::clear_regulatoreventandstatusancr() {
  if (GetArenaNoVirtual() == nullptr && regulatoreventandstatusancr_ != nullptr) {
    delete regulatoreventandstatusancr_;
  }
  regulatoreventandstatusancr_ = nullptr;
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorEvent::regulatoreventandstatusancr() const {
  const ::regulatormodule::RegulatorEventAndStatusANCR* p = regulatoreventandstatusancr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusANCR*>(
      &::regulatormodule::_RegulatorEventAndStatusANCR_default_instance_);
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorEvent::release_regulatoreventandstatusancr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = regulatoreventandstatusancr_;
  regulatoreventandstatusancr_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorEvent::mutable_regulatoreventandstatusancr() {
  
  if (regulatoreventandstatusancr_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusANCR>(GetArenaNoVirtual());
    regulatoreventandstatusancr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  return regulatoreventandstatusancr_;
}
inline void RegulatorEvent::set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatoreventandstatusancr_;
  }
  if (regulatoreventandstatusancr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatoreventandstatusancr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatoreventandstatusancr, submessage_arena);
    }
    
  } else {
    
  }
  regulatoreventandstatusancr_ = regulatoreventandstatusancr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
}

// -------------------------------------------------------------------

// RegulatorEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEventProfile::has_eventmessageinfo() const {
  return this != internal_default_instance() && eventmessageinfo_ != nullptr;
}
inline const ::commonmodule::EventMessageInfo& RegulatorEventProfile::eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = eventmessageinfo_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventMessageInfo*>(
      &::commonmodule::_EventMessageInfo_default_instance_);
}
inline ::commonmodule::EventMessageInfo* RegulatorEventProfile::release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* RegulatorEventProfile::mutable_eventmessageinfo() {
  
  if (eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaNoVirtual());
    eventmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  return eventmessageinfo_;
}
inline void RegulatorEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.eventMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& RegulatorEventProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* RegulatorEventProfile::release_ied() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* RegulatorEventProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.ied)
  return ied_;
}
inline void RegulatorEventProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.ied)
}

// .regulatormodule.RegulatorEvent regulatorEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventProfile::has_regulatorevent() const {
  return this != internal_default_instance() && regulatorevent_ != nullptr;
}
inline void RegulatorEventProfile::clear_regulatorevent() {
  if (GetArenaNoVirtual() == nullptr && regulatorevent_ != nullptr) {
    delete regulatorevent_;
  }
  regulatorevent_ = nullptr;
}
inline const ::regulatormodule::RegulatorEvent& RegulatorEventProfile::regulatorevent() const {
  const ::regulatormodule::RegulatorEvent* p = regulatorevent_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.regulatorEvent)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorEvent*>(
      &::regulatormodule::_RegulatorEvent_default_instance_);
}
inline ::regulatormodule::RegulatorEvent* RegulatorEventProfile::release_regulatorevent() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.regulatorEvent)
  
  ::regulatormodule::RegulatorEvent* temp = regulatorevent_;
  regulatorevent_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEvent* RegulatorEventProfile::mutable_regulatorevent() {
  
  if (regulatorevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEvent>(GetArenaNoVirtual());
    regulatorevent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.regulatorEvent)
  return regulatorevent_;
}
inline void RegulatorEventProfile::set_allocated_regulatorevent(::regulatormodule::RegulatorEvent* regulatorevent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorevent_;
  }
  if (regulatorevent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorevent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorevent, submessage_arena);
    }
    
  } else {
    
  }
  regulatorevent_ = regulatorevent;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.regulatorEvent)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventProfile::has_regulatorsystem() const {
  return this != internal_default_instance() && regulatorsystem_ != nullptr;
}
inline void RegulatorEventProfile::clear_regulatorsystem() {
  if (GetArenaNoVirtual() == nullptr && regulatorsystem_ != nullptr) {
    delete regulatorsystem_;
  }
  regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorEventProfile::regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = regulatorsystem_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.regulatorSystem)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorSystem*>(
      &::regulatormodule::_RegulatorSystem_default_instance_);
}
inline ::regulatormodule::RegulatorSystem* RegulatorEventProfile::release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = regulatorsystem_;
  regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorEventProfile::mutable_regulatorsystem() {
  
  if (regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaNoVirtual());
    regulatorsystem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.regulatorSystem)
  return regulatorsystem_;
}
inline void RegulatorEventProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorsystem_;
  }
  if (regulatorsystem) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorsystem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }
    
  } else {
    
  }
  regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorReading::has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && conductingequipmentterminalreading_ != nullptr;
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& RegulatorReading::conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = conductingequipmentterminalreading_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading*>(
      &::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline ::commonmodule::ConductingEquipmentTerminalReading* RegulatorReading::release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = conductingequipmentterminalreading_;
  conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* RegulatorReading::mutable_conductingequipmentterminalreading() {
  
  if (conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaNoVirtual());
    conductingequipmentterminalreading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  return conductingequipmentterminalreading_;
}
inline void RegulatorReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool RegulatorReading::has_phasemmtn() const {
  return this != internal_default_instance() && phasemmtn_ != nullptr;
}
inline const ::commonmodule::PhaseMMTN& RegulatorReading::phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = phasemmtn_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.phaseMMTN)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::PhaseMMTN*>(
      &::commonmodule::_PhaseMMTN_default_instance_);
}
inline ::commonmodule::PhaseMMTN* RegulatorReading::release_phasemmtn() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = phasemmtn_;
  phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* RegulatorReading::mutable_phasemmtn() {
  
  if (phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaNoVirtual());
    phasemmtn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.phaseMMTN)
  return phasemmtn_;
}
inline void RegulatorReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(phasemmtn_);
  }
  if (phasemmtn) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phasemmtn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }
    
  } else {
    
  }
  phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool RegulatorReading::has_readingmmtr() const {
  return this != internal_default_instance() && readingmmtr_ != nullptr;
}
inline const ::commonmodule::ReadingMMTR& RegulatorReading::readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = readingmmtr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.readingMMTR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTR*>(
      &::commonmodule::_ReadingMMTR_default_instance_);
}
inline ::commonmodule::ReadingMMTR* RegulatorReading::release_readingmmtr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = readingmmtr_;
  readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* RegulatorReading::mutable_readingmmtr() {
  
  if (readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaNoVirtual());
    readingmmtr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.readingMMTR)
  return readingmmtr_;
}
inline void RegulatorReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmtr_);
  }
  if (readingmmtr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmtr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }
    
  } else {
    
  }
  readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool RegulatorReading::has_readingmmxu() const {
  return this != internal_default_instance() && readingmmxu_ != nullptr;
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = readingmmxu_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.readingMMXU)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMXU*>(
      &::commonmodule::_ReadingMMXU_default_instance_);
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::release_readingmmxu() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = readingmmxu_;
  readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::mutable_readingmmxu() {
  
  if (readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaNoVirtual());
    readingmmxu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.readingMMXU)
  return readingmmxu_;
}
inline void RegulatorReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmxu_);
  }
  if (readingmmxu) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmxu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }
    
  } else {
    
  }
  readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.readingMMXU)
}

// -------------------------------------------------------------------

// RegulatorReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorReadingProfile::has_readingmessageinfo() const {
  return this != internal_default_instance() && readingmessageinfo_ != nullptr;
}
inline const ::commonmodule::ReadingMessageInfo& RegulatorReadingProfile::readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = readingmessageinfo_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMessageInfo*>(
      &::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline ::commonmodule::ReadingMessageInfo* RegulatorReadingProfile::release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = readingmessageinfo_;
  readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* RegulatorReadingProfile::mutable_readingmessageinfo() {
  
  if (readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaNoVirtual());
    readingmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  return readingmessageinfo_;
}
inline void RegulatorReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorReadingProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& RegulatorReadingProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* RegulatorReadingProfile::release_ied() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReadingProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* RegulatorReadingProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.ied)
  return ied_;
}
inline void RegulatorReadingProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReadingProfile.ied)
}

// repeated .regulatormodule.RegulatorReading regulatorReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
inline int RegulatorReadingProfile::regulatorreading_size() const {
  return regulatorreading_.size();
}
inline void RegulatorReadingProfile::clear_regulatorreading() {
  regulatorreading_.Clear();
}
inline ::regulatormodule::RegulatorReading* RegulatorReadingProfile::mutable_regulatorreading(int index) {
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return regulatorreading_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorReading >*
RegulatorReadingProfile::mutable_regulatorreading() {
  // @@protoc_insertion_point(field_mutable_list:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return &regulatorreading_;
}
inline const ::regulatormodule::RegulatorReading& RegulatorReadingProfile::regulatorreading(int index) const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return regulatorreading_.Get(index);
}
inline ::regulatormodule::RegulatorReading* RegulatorReadingProfile::add_regulatorreading() {
  // @@protoc_insertion_point(field_add:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return regulatorreading_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorReading >&
RegulatorReadingProfile::regulatorreading() const {
  // @@protoc_insertion_point(field_list:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return regulatorreading_;
}

// .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorReadingProfile::has_regulatorsystem() const {
  return this != internal_default_instance() && regulatorsystem_ != nullptr;
}
inline void RegulatorReadingProfile::clear_regulatorsystem() {
  if (GetArenaNoVirtual() == nullptr && regulatorsystem_ != nullptr) {
    delete regulatorsystem_;
  }
  regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorReadingProfile::regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = regulatorsystem_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorSystem*>(
      &::regulatormodule::_RegulatorSystem_default_instance_);
}
inline ::regulatormodule::RegulatorSystem* RegulatorReadingProfile::release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = regulatorsystem_;
  regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorReadingProfile::mutable_regulatorsystem() {
  
  if (regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaNoVirtual());
    regulatorsystem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  return regulatorsystem_;
}
inline void RegulatorReadingProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorsystem_;
  }
  if (regulatorsystem) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorsystem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }
    
  } else {
    
  }
  regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReadingProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorStatus::has_statusvalue() const {
  return this != internal_default_instance() && statusvalue_ != nullptr;
}
inline const ::commonmodule::StatusValue& RegulatorStatus::statusvalue() const {
  const ::commonmodule::StatusValue* p = statusvalue_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatus.statusValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusValue*>(
      &::commonmodule::_StatusValue_default_instance_);
}
inline ::commonmodule::StatusValue* RegulatorStatus::release_statusvalue() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = statusvalue_;
  statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* RegulatorStatus::mutable_statusvalue() {
  
  if (statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaNoVirtual());
    statusvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatus.statusValue)
  return statusvalue_;
}
inline void RegulatorStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusvalue_);
  }
  if (statusvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }
    
  } else {
    
  }
  statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatus.statusValue)
}

// .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatus::has_regulatoreventandstatusancr() const {
  return this != internal_default_instance() && regulatoreventandstatusancr_ != nullptr;
}
inline void RegulatorStatus::clear_regulatoreventandstatusancr() {
  if (GetArenaNoVirtual() == nullptr && regulatoreventandstatusancr_ != nullptr) {
    delete regulatoreventandstatusancr_;
  }
  regulatoreventandstatusancr_ = nullptr;
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorStatus::regulatoreventandstatusancr() const {
  const ::regulatormodule::RegulatorEventAndStatusANCR* p = regulatoreventandstatusancr_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusANCR*>(
      &::regulatormodule::_RegulatorEventAndStatusANCR_default_instance_);
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorStatus::release_regulatoreventandstatusancr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = regulatoreventandstatusancr_;
  regulatoreventandstatusancr_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorStatus::mutable_regulatoreventandstatusancr() {
  
  if (regulatoreventandstatusancr_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusANCR>(GetArenaNoVirtual());
    regulatoreventandstatusancr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  return regulatoreventandstatusancr_;
}
inline void RegulatorStatus::set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatoreventandstatusancr_;
  }
  if (regulatoreventandstatusancr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatoreventandstatusancr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatoreventandstatusancr, submessage_arena);
    }
    
  } else {
    
  }
  regulatoreventandstatusancr_ = regulatoreventandstatusancr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
}

// -------------------------------------------------------------------

// RegulatorStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorStatusProfile::has_statusmessageinfo() const {
  return this != internal_default_instance() && statusmessageinfo_ != nullptr;
}
inline const ::commonmodule::StatusMessageInfo& RegulatorStatusProfile::statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = statusmessageinfo_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusMessageInfo*>(
      &::commonmodule::_StatusMessageInfo_default_instance_);
}
inline ::commonmodule::StatusMessageInfo* RegulatorStatusProfile::release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = statusmessageinfo_;
  statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* RegulatorStatusProfile::mutable_statusmessageinfo() {
  
  if (statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaNoVirtual());
    statusmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  return statusmessageinfo_;
}
inline void RegulatorStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatusProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& RegulatorStatusProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* RegulatorStatusProfile::release_ied() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* RegulatorStatusProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.ied)
  return ied_;
}
inline void RegulatorStatusProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.ied)
}

// .regulatormodule.RegulatorStatus regulatorStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatusProfile::has_regulatorstatus() const {
  return this != internal_default_instance() && regulatorstatus_ != nullptr;
}
inline void RegulatorStatusProfile::clear_regulatorstatus() {
  if (GetArenaNoVirtual() == nullptr && regulatorstatus_ != nullptr) {
    delete regulatorstatus_;
  }
  regulatorstatus_ = nullptr;
}
inline const ::regulatormodule::RegulatorStatus& RegulatorStatusProfile::regulatorstatus() const {
  const ::regulatormodule::RegulatorStatus* p = regulatorstatus_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorStatus*>(
      &::regulatormodule::_RegulatorStatus_default_instance_);
}
inline ::regulatormodule::RegulatorStatus* RegulatorStatusProfile::release_regulatorstatus() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  
  ::regulatormodule::RegulatorStatus* temp = regulatorstatus_;
  regulatorstatus_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorStatus* RegulatorStatusProfile::mutable_regulatorstatus() {
  
  if (regulatorstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorStatus>(GetArenaNoVirtual());
    regulatorstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  return regulatorstatus_;
}
inline void RegulatorStatusProfile::set_allocated_regulatorstatus(::regulatormodule::RegulatorStatus* regulatorstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorstatus_;
  }
  if (regulatorstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorstatus, submessage_arena);
    }
    
  } else {
    
  }
  regulatorstatus_ = regulatorstatus;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorStatus)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatusProfile::has_regulatorsystem() const {
  return this != internal_default_instance() && regulatorsystem_ != nullptr;
}
inline void RegulatorStatusProfile::clear_regulatorsystem() {
  if (GetArenaNoVirtual() == nullptr && regulatorsystem_ != nullptr) {
    delete regulatorsystem_;
  }
  regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorStatusProfile::regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = regulatorsystem_;
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  return p != nullptr ? *p : *reinterpret_cast<const ::regulatormodule::RegulatorSystem*>(
      &::regulatormodule::_RegulatorSystem_default_instance_);
}
inline ::regulatormodule::RegulatorSystem* RegulatorStatusProfile::release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = regulatorsystem_;
  regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorStatusProfile::mutable_regulatorsystem() {
  
  if (regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaNoVirtual());
    regulatorsystem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  return regulatorsystem_;
}
inline void RegulatorStatusProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regulatorsystem_;
  }
  if (regulatorsystem) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regulatorsystem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }
    
  } else {
    
  }
  regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorSystem)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace regulatormodule

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_regulatormodule_2fregulatormodule_2eproto
