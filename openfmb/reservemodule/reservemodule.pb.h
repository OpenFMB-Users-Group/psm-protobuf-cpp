// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: reservemodule/reservemodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_reservemodule_2freservemodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_reservemodule_2freservemodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_reservemodule_2freservemodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_reservemodule_2freservemodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_reservemodule_2freservemodule_2eproto;
namespace reservemodule {
class AllocatedMargin;
struct AllocatedMarginDefaultTypeInternal;
extern AllocatedMarginDefaultTypeInternal _AllocatedMargin_default_instance_;
class ReserveAvailability;
struct ReserveAvailabilityDefaultTypeInternal;
extern ReserveAvailabilityDefaultTypeInternal _ReserveAvailability_default_instance_;
class ReserveAvailabilityProfile;
struct ReserveAvailabilityProfileDefaultTypeInternal;
extern ReserveAvailabilityProfileDefaultTypeInternal _ReserveAvailabilityProfile_default_instance_;
class ReserveMargin;
struct ReserveMarginDefaultTypeInternal;
extern ReserveMarginDefaultTypeInternal _ReserveMargin_default_instance_;
class ReserveRequest;
struct ReserveRequestDefaultTypeInternal;
extern ReserveRequestDefaultTypeInternal _ReserveRequest_default_instance_;
class ReserveRequestProfile;
struct ReserveRequestProfileDefaultTypeInternal;
extern ReserveRequestProfileDefaultTypeInternal _ReserveRequestProfile_default_instance_;
}  // namespace reservemodule
PROTOBUF_NAMESPACE_OPEN
template <>
::reservemodule::AllocatedMargin* Arena::CreateMaybeMessage<::reservemodule::AllocatedMargin>(Arena*);
template <>
::reservemodule::ReserveAvailability* Arena::CreateMaybeMessage<::reservemodule::ReserveAvailability>(Arena*);
template <>
::reservemodule::ReserveAvailabilityProfile* Arena::CreateMaybeMessage<::reservemodule::ReserveAvailabilityProfile>(Arena*);
template <>
::reservemodule::ReserveMargin* Arena::CreateMaybeMessage<::reservemodule::ReserveMargin>(Arena*);
template <>
::reservemodule::ReserveRequest* Arena::CreateMaybeMessage<::reservemodule::ReserveRequest>(Arena*);
template <>
::reservemodule::ReserveRequestProfile* Arena::CreateMaybeMessage<::reservemodule::ReserveRequestProfile>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace reservemodule {

// ===================================================================


// -------------------------------------------------------------------

class ReserveMargin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:reservemodule.ReserveMargin) */ {
 public:
  inline ReserveMargin() : ReserveMargin(nullptr) {}
  ~ReserveMargin() override;
  explicit PROTOBUF_CONSTEXPR ReserveMargin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReserveMargin(const ReserveMargin& from);
  ReserveMargin(ReserveMargin&& from) noexcept
    : ReserveMargin() {
    *this = ::std::move(from);
  }

  inline ReserveMargin& operator=(const ReserveMargin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveMargin& operator=(ReserveMargin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveMargin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReserveMargin* internal_default_instance() {
    return reinterpret_cast<const ReserveMargin*>(
               &_ReserveMargin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReserveMargin& a, ReserveMargin& b) {
    a.Swap(&b);
  }
  inline void Swap(ReserveMargin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveMargin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveMargin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReserveMargin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReserveMargin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReserveMargin& from) {
    ReserveMargin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReserveMargin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "reservemodule.ReserveMargin";
  }
  protected:
  explicit ReserveMargin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kAFieldNumber = 2,
    kVAFieldNumber = 3,
    kVArFieldNumber = 4,
    kWFieldNumber = 5,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.PMG A = 2;
  bool has_a() const;
  private:
  bool _internal_has_a() const;

  public:
  void clear_a() ;
  const ::commonmodule::PMG& a() const;
  PROTOBUF_NODISCARD ::commonmodule::PMG* release_a();
  ::commonmodule::PMG* mutable_a();
  void set_allocated_a(::commonmodule::PMG* a);
  private:
  const ::commonmodule::PMG& _internal_a() const;
  ::commonmodule::PMG* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::commonmodule::PMG* a);
  ::commonmodule::PMG* unsafe_arena_release_a();
  // .commonmodule.PMG VA = 3;
  bool has_va() const;
  private:
  bool _internal_has_va() const;

  public:
  void clear_va() ;
  const ::commonmodule::PMG& va() const;
  PROTOBUF_NODISCARD ::commonmodule::PMG* release_va();
  ::commonmodule::PMG* mutable_va();
  void set_allocated_va(::commonmodule::PMG* va);
  private:
  const ::commonmodule::PMG& _internal_va() const;
  ::commonmodule::PMG* _internal_mutable_va();
  public:
  void unsafe_arena_set_allocated_va(
      ::commonmodule::PMG* va);
  ::commonmodule::PMG* unsafe_arena_release_va();
  // .commonmodule.PMG VAr = 4;
  bool has_var() const;
  private:
  bool _internal_has_var() const;

  public:
  void clear_var() ;
  const ::commonmodule::PMG& var() const;
  PROTOBUF_NODISCARD ::commonmodule::PMG* release_var();
  ::commonmodule::PMG* mutable_var();
  void set_allocated_var(::commonmodule::PMG* var);
  private:
  const ::commonmodule::PMG& _internal_var() const;
  ::commonmodule::PMG* _internal_mutable_var();
  public:
  void unsafe_arena_set_allocated_var(
      ::commonmodule::PMG* var);
  ::commonmodule::PMG* unsafe_arena_release_var();
  // .commonmodule.PMG W = 5;
  bool has_w() const;
  private:
  bool _internal_has_w() const;

  public:
  void clear_w() ;
  const ::commonmodule::PMG& w() const;
  PROTOBUF_NODISCARD ::commonmodule::PMG* release_w();
  ::commonmodule::PMG* mutable_w();
  void set_allocated_w(::commonmodule::PMG* w);
  private:
  const ::commonmodule::PMG& _internal_w() const;
  ::commonmodule::PMG* _internal_mutable_w();
  public:
  void unsafe_arena_set_allocated_w(
      ::commonmodule::PMG* w);
  ::commonmodule::PMG* unsafe_arena_release_w();
  // @@protoc_insertion_point(class_scope:reservemodule.ReserveMargin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::PMG* a_;
    ::commonmodule::PMG* va_;
    ::commonmodule::PMG* var_;
    ::commonmodule::PMG* w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_reservemodule_2freservemodule_2eproto;
};// -------------------------------------------------------------------

class ReserveAvailability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:reservemodule.ReserveAvailability) */ {
 public:
  inline ReserveAvailability() : ReserveAvailability(nullptr) {}
  ~ReserveAvailability() override;
  explicit PROTOBUF_CONSTEXPR ReserveAvailability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReserveAvailability(const ReserveAvailability& from);
  ReserveAvailability(ReserveAvailability&& from) noexcept
    : ReserveAvailability() {
    *this = ::std::move(from);
  }

  inline ReserveAvailability& operator=(const ReserveAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveAvailability& operator=(ReserveAvailability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveAvailability& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReserveAvailability* internal_default_instance() {
    return reinterpret_cast<const ReserveAvailability*>(
               &_ReserveAvailability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReserveAvailability& a, ReserveAvailability& b) {
    a.Swap(&b);
  }
  inline void Swap(ReserveAvailability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveAvailability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveAvailability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReserveAvailability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReserveAvailability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReserveAvailability& from) {
    ReserveAvailability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReserveAvailability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "reservemodule.ReserveAvailability";
  }
  protected:
  explicit ReserveAvailability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncrementalMarginFieldNumber = 1,
    kMarginFieldNumber = 2,
    kStandbyMarginFieldNumber = 3,
  };
  // .reservemodule.ReserveMargin incrementalMargin = 1;
  bool has_incrementalmargin() const;
  private:
  bool _internal_has_incrementalmargin() const;

  public:
  void clear_incrementalmargin() ;
  const ::reservemodule::ReserveMargin& incrementalmargin() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveMargin* release_incrementalmargin();
  ::reservemodule::ReserveMargin* mutable_incrementalmargin();
  void set_allocated_incrementalmargin(::reservemodule::ReserveMargin* incrementalmargin);
  private:
  const ::reservemodule::ReserveMargin& _internal_incrementalmargin() const;
  ::reservemodule::ReserveMargin* _internal_mutable_incrementalmargin();
  public:
  void unsafe_arena_set_allocated_incrementalmargin(
      ::reservemodule::ReserveMargin* incrementalmargin);
  ::reservemodule::ReserveMargin* unsafe_arena_release_incrementalmargin();
  // .reservemodule.ReserveMargin margin = 2;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;

  public:
  void clear_margin() ;
  const ::reservemodule::ReserveMargin& margin() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveMargin* release_margin();
  ::reservemodule::ReserveMargin* mutable_margin();
  void set_allocated_margin(::reservemodule::ReserveMargin* margin);
  private:
  const ::reservemodule::ReserveMargin& _internal_margin() const;
  ::reservemodule::ReserveMargin* _internal_mutable_margin();
  public:
  void unsafe_arena_set_allocated_margin(
      ::reservemodule::ReserveMargin* margin);
  ::reservemodule::ReserveMargin* unsafe_arena_release_margin();
  // .reservemodule.ReserveMargin standbyMargin = 3;
  bool has_standbymargin() const;
  private:
  bool _internal_has_standbymargin() const;

  public:
  void clear_standbymargin() ;
  const ::reservemodule::ReserveMargin& standbymargin() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveMargin* release_standbymargin();
  ::reservemodule::ReserveMargin* mutable_standbymargin();
  void set_allocated_standbymargin(::reservemodule::ReserveMargin* standbymargin);
  private:
  const ::reservemodule::ReserveMargin& _internal_standbymargin() const;
  ::reservemodule::ReserveMargin* _internal_mutable_standbymargin();
  public:
  void unsafe_arena_set_allocated_standbymargin(
      ::reservemodule::ReserveMargin* standbymargin);
  ::reservemodule::ReserveMargin* unsafe_arena_release_standbymargin();
  // @@protoc_insertion_point(class_scope:reservemodule.ReserveAvailability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::reservemodule::ReserveMargin* incrementalmargin_;
    ::reservemodule::ReserveMargin* margin_;
    ::reservemodule::ReserveMargin* standbymargin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_reservemodule_2freservemodule_2eproto;
};// -------------------------------------------------------------------

class AllocatedMargin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:reservemodule.AllocatedMargin) */ {
 public:
  inline AllocatedMargin() : AllocatedMargin(nullptr) {}
  ~AllocatedMargin() override;
  explicit PROTOBUF_CONSTEXPR AllocatedMargin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocatedMargin(const AllocatedMargin& from);
  AllocatedMargin(AllocatedMargin&& from) noexcept
    : AllocatedMargin() {
    *this = ::std::move(from);
  }

  inline AllocatedMargin& operator=(const AllocatedMargin& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocatedMargin& operator=(AllocatedMargin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocatedMargin& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocatedMargin* internal_default_instance() {
    return reinterpret_cast<const AllocatedMargin*>(
               &_AllocatedMargin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AllocatedMargin& a, AllocatedMargin& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocatedMargin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocatedMargin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocatedMargin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocatedMargin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocatedMargin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocatedMargin& from) {
    AllocatedMargin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocatedMargin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "reservemodule.AllocatedMargin";
  }
  protected:
  explicit AllocatedMargin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIDFieldNumber = 1,
    kAllocatedMarginFieldNumber = 2,
    kAllocatedStandbyMarginFieldNumber = 3,
  };
  // string requestID = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_requestid() ;
  const std::string& requestid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* ptr);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // .reservemodule.ReserveMargin allocatedMargin = 2;
  bool has_allocatedmargin() const;
  private:
  bool _internal_has_allocatedmargin() const;

  public:
  void clear_allocatedmargin() ;
  const ::reservemodule::ReserveMargin& allocatedmargin() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveMargin* release_allocatedmargin();
  ::reservemodule::ReserveMargin* mutable_allocatedmargin();
  void set_allocated_allocatedmargin(::reservemodule::ReserveMargin* allocatedmargin);
  private:
  const ::reservemodule::ReserveMargin& _internal_allocatedmargin() const;
  ::reservemodule::ReserveMargin* _internal_mutable_allocatedmargin();
  public:
  void unsafe_arena_set_allocated_allocatedmargin(
      ::reservemodule::ReserveMargin* allocatedmargin);
  ::reservemodule::ReserveMargin* unsafe_arena_release_allocatedmargin();
  // .reservemodule.ReserveMargin allocatedStandbyMargin = 3;
  bool has_allocatedstandbymargin() const;
  private:
  bool _internal_has_allocatedstandbymargin() const;

  public:
  void clear_allocatedstandbymargin() ;
  const ::reservemodule::ReserveMargin& allocatedstandbymargin() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveMargin* release_allocatedstandbymargin();
  ::reservemodule::ReserveMargin* mutable_allocatedstandbymargin();
  void set_allocated_allocatedstandbymargin(::reservemodule::ReserveMargin* allocatedstandbymargin);
  private:
  const ::reservemodule::ReserveMargin& _internal_allocatedstandbymargin() const;
  ::reservemodule::ReserveMargin* _internal_mutable_allocatedstandbymargin();
  public:
  void unsafe_arena_set_allocated_allocatedstandbymargin(
      ::reservemodule::ReserveMargin* allocatedstandbymargin);
  ::reservemodule::ReserveMargin* unsafe_arena_release_allocatedstandbymargin();
  // @@protoc_insertion_point(class_scope:reservemodule.AllocatedMargin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requestid_;
    ::reservemodule::ReserveMargin* allocatedmargin_;
    ::reservemodule::ReserveMargin* allocatedstandbymargin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_reservemodule_2freservemodule_2eproto;
};// -------------------------------------------------------------------

class ReserveAvailabilityProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:reservemodule.ReserveAvailabilityProfile) */ {
 public:
  inline ReserveAvailabilityProfile() : ReserveAvailabilityProfile(nullptr) {}
  ~ReserveAvailabilityProfile() override;
  explicit PROTOBUF_CONSTEXPR ReserveAvailabilityProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReserveAvailabilityProfile(const ReserveAvailabilityProfile& from);
  ReserveAvailabilityProfile(ReserveAvailabilityProfile&& from) noexcept
    : ReserveAvailabilityProfile() {
    *this = ::std::move(from);
  }

  inline ReserveAvailabilityProfile& operator=(const ReserveAvailabilityProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveAvailabilityProfile& operator=(ReserveAvailabilityProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveAvailabilityProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReserveAvailabilityProfile* internal_default_instance() {
    return reinterpret_cast<const ReserveAvailabilityProfile*>(
               &_ReserveAvailabilityProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReserveAvailabilityProfile& a, ReserveAvailabilityProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ReserveAvailabilityProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveAvailabilityProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveAvailabilityProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReserveAvailabilityProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReserveAvailabilityProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReserveAvailabilityProfile& from) {
    ReserveAvailabilityProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReserveAvailabilityProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "reservemodule.ReserveAvailabilityProfile";
  }
  protected:
  explicit ReserveAvailabilityProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kAllocatedMarginFieldNumber = 2,
    kRequesterCircuitSegmentServiceFieldNumber = 3,
    kReserveAvailabilityFieldNumber = 4,
    kResponderCircuitSegmentServiceFieldNumber = 5,
    kTiePointFieldNumber = 6,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .reservemodule.AllocatedMargin allocatedMargin = 2;
  bool has_allocatedmargin() const;
  private:
  bool _internal_has_allocatedmargin() const;

  public:
  void clear_allocatedmargin() ;
  const ::reservemodule::AllocatedMargin& allocatedmargin() const;
  PROTOBUF_NODISCARD ::reservemodule::AllocatedMargin* release_allocatedmargin();
  ::reservemodule::AllocatedMargin* mutable_allocatedmargin();
  void set_allocated_allocatedmargin(::reservemodule::AllocatedMargin* allocatedmargin);
  private:
  const ::reservemodule::AllocatedMargin& _internal_allocatedmargin() const;
  ::reservemodule::AllocatedMargin* _internal_mutable_allocatedmargin();
  public:
  void unsafe_arena_set_allocated_allocatedmargin(
      ::reservemodule::AllocatedMargin* allocatedmargin);
  ::reservemodule::AllocatedMargin* unsafe_arena_release_allocatedmargin();
  // .commonmodule.ApplicationSystem requesterCircuitSegmentService = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_requestercircuitsegmentservice() const;
  private:
  bool _internal_has_requestercircuitsegmentservice() const;

  public:
  void clear_requestercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& requestercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_requestercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_requestercircuitsegmentservice();
  void set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_requestercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_requestercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_requestercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_requestercircuitsegmentservice();
  // .reservemodule.ReserveAvailability reserveAvailability = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_reserveavailability() const;
  private:
  bool _internal_has_reserveavailability() const;

  public:
  void clear_reserveavailability() ;
  const ::reservemodule::ReserveAvailability& reserveavailability() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveAvailability* release_reserveavailability();
  ::reservemodule::ReserveAvailability* mutable_reserveavailability();
  void set_allocated_reserveavailability(::reservemodule::ReserveAvailability* reserveavailability);
  private:
  const ::reservemodule::ReserveAvailability& _internal_reserveavailability() const;
  ::reservemodule::ReserveAvailability* _internal_mutable_reserveavailability();
  public:
  void unsafe_arena_set_allocated_reserveavailability(
      ::reservemodule::ReserveAvailability* reserveavailability);
  ::reservemodule::ReserveAvailability* unsafe_arena_release_reserveavailability();
  // .commonmodule.ApplicationSystem responderCircuitSegmentService = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_respondercircuitsegmentservice() const;
  private:
  bool _internal_has_respondercircuitsegmentservice() const;

  public:
  void clear_respondercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& respondercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_respondercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_respondercircuitsegmentservice();
  void set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_respondercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_respondercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_respondercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_respondercircuitsegmentservice();
  // .commonmodule.ConductingEquipment tiePoint = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_tiepoint() const;
  private:
  bool _internal_has_tiepoint() const;

  public:
  void clear_tiepoint() ;
  const ::commonmodule::ConductingEquipment& tiepoint() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_tiepoint();
  ::commonmodule::ConductingEquipment* mutable_tiepoint();
  void set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint);
  private:
  const ::commonmodule::ConductingEquipment& _internal_tiepoint() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_tiepoint();
  public:
  void unsafe_arena_set_allocated_tiepoint(
      ::commonmodule::ConductingEquipment* tiepoint);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_tiepoint();
  // @@protoc_insertion_point(class_scope:reservemodule.ReserveAvailabilityProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::reservemodule::AllocatedMargin* allocatedmargin_;
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice_;
    ::reservemodule::ReserveAvailability* reserveavailability_;
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice_;
    ::commonmodule::ConductingEquipment* tiepoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_reservemodule_2freservemodule_2eproto;
};// -------------------------------------------------------------------

class ReserveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:reservemodule.ReserveRequest) */ {
 public:
  inline ReserveRequest() : ReserveRequest(nullptr) {}
  ~ReserveRequest() override;
  explicit PROTOBUF_CONSTEXPR ReserveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReserveRequest(const ReserveRequest& from);
  ReserveRequest(ReserveRequest&& from) noexcept
    : ReserveRequest() {
    *this = ::std::move(from);
  }

  inline ReserveRequest& operator=(const ReserveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveRequest& operator=(ReserveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReserveRequest* internal_default_instance() {
    return reinterpret_cast<const ReserveRequest*>(
               &_ReserveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReserveRequest& a, ReserveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReserveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReserveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReserveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReserveRequest& from) {
    ReserveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReserveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "reservemodule.ReserveRequest";
  }
  protected:
  explicit ReserveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIDFieldNumber = 1,
    kMarginFieldNumber = 2,
    kStandbyMarginFieldNumber = 3,
  };
  // string requestID = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_requestid() ;
  const std::string& requestid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* ptr);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // .reservemodule.ReserveMargin margin = 2;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;

  public:
  void clear_margin() ;
  const ::reservemodule::ReserveMargin& margin() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveMargin* release_margin();
  ::reservemodule::ReserveMargin* mutable_margin();
  void set_allocated_margin(::reservemodule::ReserveMargin* margin);
  private:
  const ::reservemodule::ReserveMargin& _internal_margin() const;
  ::reservemodule::ReserveMargin* _internal_mutable_margin();
  public:
  void unsafe_arena_set_allocated_margin(
      ::reservemodule::ReserveMargin* margin);
  ::reservemodule::ReserveMargin* unsafe_arena_release_margin();
  // .reservemodule.ReserveMargin standbyMargin = 3;
  bool has_standbymargin() const;
  private:
  bool _internal_has_standbymargin() const;

  public:
  void clear_standbymargin() ;
  const ::reservemodule::ReserveMargin& standbymargin() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveMargin* release_standbymargin();
  ::reservemodule::ReserveMargin* mutable_standbymargin();
  void set_allocated_standbymargin(::reservemodule::ReserveMargin* standbymargin);
  private:
  const ::reservemodule::ReserveMargin& _internal_standbymargin() const;
  ::reservemodule::ReserveMargin* _internal_mutable_standbymargin();
  public:
  void unsafe_arena_set_allocated_standbymargin(
      ::reservemodule::ReserveMargin* standbymargin);
  ::reservemodule::ReserveMargin* unsafe_arena_release_standbymargin();
  // @@protoc_insertion_point(class_scope:reservemodule.ReserveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requestid_;
    ::reservemodule::ReserveMargin* margin_;
    ::reservemodule::ReserveMargin* standbymargin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_reservemodule_2freservemodule_2eproto;
};// -------------------------------------------------------------------

class ReserveRequestProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:reservemodule.ReserveRequestProfile) */ {
 public:
  inline ReserveRequestProfile() : ReserveRequestProfile(nullptr) {}
  ~ReserveRequestProfile() override;
  explicit PROTOBUF_CONSTEXPR ReserveRequestProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReserveRequestProfile(const ReserveRequestProfile& from);
  ReserveRequestProfile(ReserveRequestProfile&& from) noexcept
    : ReserveRequestProfile() {
    *this = ::std::move(from);
  }

  inline ReserveRequestProfile& operator=(const ReserveRequestProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveRequestProfile& operator=(ReserveRequestProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReserveRequestProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReserveRequestProfile* internal_default_instance() {
    return reinterpret_cast<const ReserveRequestProfile*>(
               &_ReserveRequestProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReserveRequestProfile& a, ReserveRequestProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ReserveRequestProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReserveRequestProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReserveRequestProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReserveRequestProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReserveRequestProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReserveRequestProfile& from) {
    ReserveRequestProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReserveRequestProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "reservemodule.ReserveRequestProfile";
  }
  protected:
  explicit ReserveRequestProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kRequesterCircuitSegmentServiceFieldNumber = 2,
    kReserveRequestFieldNumber = 3,
    kResponderCircuitSegmentServiceFieldNumber = 4,
    kTiePointFieldNumber = 5,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .commonmodule.ApplicationSystem requesterCircuitSegmentService = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_requestercircuitsegmentservice() const;
  private:
  bool _internal_has_requestercircuitsegmentservice() const;

  public:
  void clear_requestercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& requestercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_requestercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_requestercircuitsegmentservice();
  void set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_requestercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_requestercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_requestercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_requestercircuitsegmentservice();
  // .reservemodule.ReserveRequest reserveRequest = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_reserverequest() const;
  private:
  bool _internal_has_reserverequest() const;

  public:
  void clear_reserverequest() ;
  const ::reservemodule::ReserveRequest& reserverequest() const;
  PROTOBUF_NODISCARD ::reservemodule::ReserveRequest* release_reserverequest();
  ::reservemodule::ReserveRequest* mutable_reserverequest();
  void set_allocated_reserverequest(::reservemodule::ReserveRequest* reserverequest);
  private:
  const ::reservemodule::ReserveRequest& _internal_reserverequest() const;
  ::reservemodule::ReserveRequest* _internal_mutable_reserverequest();
  public:
  void unsafe_arena_set_allocated_reserverequest(
      ::reservemodule::ReserveRequest* reserverequest);
  ::reservemodule::ReserveRequest* unsafe_arena_release_reserverequest();
  // .commonmodule.ApplicationSystem responderCircuitSegmentService = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_respondercircuitsegmentservice() const;
  private:
  bool _internal_has_respondercircuitsegmentservice() const;

  public:
  void clear_respondercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& respondercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_respondercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_respondercircuitsegmentservice();
  void set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_respondercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_respondercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_respondercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_respondercircuitsegmentservice();
  // .commonmodule.ConductingEquipment tiePoint = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_tiepoint() const;
  private:
  bool _internal_has_tiepoint() const;

  public:
  void clear_tiepoint() ;
  const ::commonmodule::ConductingEquipment& tiepoint() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_tiepoint();
  ::commonmodule::ConductingEquipment* mutable_tiepoint();
  void set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint);
  private:
  const ::commonmodule::ConductingEquipment& _internal_tiepoint() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_tiepoint();
  public:
  void unsafe_arena_set_allocated_tiepoint(
      ::commonmodule::ConductingEquipment* tiepoint);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_tiepoint();
  // @@protoc_insertion_point(class_scope:reservemodule.ReserveRequestProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice_;
    ::reservemodule::ReserveRequest* reserverequest_;
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice_;
    ::commonmodule::ConductingEquipment* tiepoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_reservemodule_2freservemodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ReserveMargin

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReserveMargin::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool ReserveMargin::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline const ::commonmodule::LogicalNode& ReserveMargin::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& ReserveMargin::logicalnode() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveMargin.logicalNode)
  return _internal_logicalnode();
}
inline void ReserveMargin::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveMargin.logicalNode)
}
inline ::commonmodule::LogicalNode* ReserveMargin::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* ReserveMargin::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveMargin.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* ReserveMargin::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* ReserveMargin::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveMargin.logicalNode)
  return _msg;
}
inline void ReserveMargin::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode));
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveMargin.logicalNode)
}

// .commonmodule.PMG A = 2;
inline bool ReserveMargin::_internal_has_a() const {
  return this != internal_default_instance() && _impl_.a_ != nullptr;
}
inline bool ReserveMargin::has_a() const {
  return _internal_has_a();
}
inline const ::commonmodule::PMG& ReserveMargin::_internal_a() const {
  const ::commonmodule::PMG* p = _impl_.a_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PMG&>(
      ::commonmodule::_PMG_default_instance_);
}
inline const ::commonmodule::PMG& ReserveMargin::a() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveMargin.A)
  return _internal_a();
}
inline void ReserveMargin::unsafe_arena_set_allocated_a(
    ::commonmodule::PMG* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a_);
  }
  _impl_.a_ = a;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveMargin.A)
}
inline ::commonmodule::PMG* ReserveMargin::release_a() {
  
  ::commonmodule::PMG* temp = _impl_.a_;
  _impl_.a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveMargin.A)
  
  ::commonmodule::PMG* temp = _impl_.a_;
  _impl_.a_ = nullptr;
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::_internal_mutable_a() {
  
  if (_impl_.a_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PMG>(GetArenaForAllocation());
    _impl_.a_ = p;
  }
  return _impl_.a_;
}
inline ::commonmodule::PMG* ReserveMargin::mutable_a() {
  ::commonmodule::PMG* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveMargin.A)
  return _msg;
}
inline void ReserveMargin::set_allocated_a(::commonmodule::PMG* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a_);
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a));
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }

  } else {

  }
  _impl_.a_ = a;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveMargin.A)
}

// .commonmodule.PMG VA = 3;
inline bool ReserveMargin::_internal_has_va() const {
  return this != internal_default_instance() && _impl_.va_ != nullptr;
}
inline bool ReserveMargin::has_va() const {
  return _internal_has_va();
}
inline const ::commonmodule::PMG& ReserveMargin::_internal_va() const {
  const ::commonmodule::PMG* p = _impl_.va_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PMG&>(
      ::commonmodule::_PMG_default_instance_);
}
inline const ::commonmodule::PMG& ReserveMargin::va() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveMargin.VA)
  return _internal_va();
}
inline void ReserveMargin::unsafe_arena_set_allocated_va(
    ::commonmodule::PMG* va) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.va_);
  }
  _impl_.va_ = va;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveMargin.VA)
}
inline ::commonmodule::PMG* ReserveMargin::release_va() {
  
  ::commonmodule::PMG* temp = _impl_.va_;
  _impl_.va_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::unsafe_arena_release_va() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveMargin.VA)
  
  ::commonmodule::PMG* temp = _impl_.va_;
  _impl_.va_ = nullptr;
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::_internal_mutable_va() {
  
  if (_impl_.va_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PMG>(GetArenaForAllocation());
    _impl_.va_ = p;
  }
  return _impl_.va_;
}
inline ::commonmodule::PMG* ReserveMargin::mutable_va() {
  ::commonmodule::PMG* _msg = _internal_mutable_va();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveMargin.VA)
  return _msg;
}
inline void ReserveMargin::set_allocated_va(::commonmodule::PMG* va) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.va_);
  }
  if (va) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(va));
    if (message_arena != submessage_arena) {
      va = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, va, submessage_arena);
    }

  } else {

  }
  _impl_.va_ = va;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveMargin.VA)
}

// .commonmodule.PMG VAr = 4;
inline bool ReserveMargin::_internal_has_var() const {
  return this != internal_default_instance() && _impl_.var_ != nullptr;
}
inline bool ReserveMargin::has_var() const {
  return _internal_has_var();
}
inline const ::commonmodule::PMG& ReserveMargin::_internal_var() const {
  const ::commonmodule::PMG* p = _impl_.var_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PMG&>(
      ::commonmodule::_PMG_default_instance_);
}
inline const ::commonmodule::PMG& ReserveMargin::var() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveMargin.VAr)
  return _internal_var();
}
inline void ReserveMargin::unsafe_arena_set_allocated_var(
    ::commonmodule::PMG* var) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.var_);
  }
  _impl_.var_ = var;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveMargin.VAr)
}
inline ::commonmodule::PMG* ReserveMargin::release_var() {
  
  ::commonmodule::PMG* temp = _impl_.var_;
  _impl_.var_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveMargin.VAr)
  
  ::commonmodule::PMG* temp = _impl_.var_;
  _impl_.var_ = nullptr;
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::_internal_mutable_var() {
  
  if (_impl_.var_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PMG>(GetArenaForAllocation());
    _impl_.var_ = p;
  }
  return _impl_.var_;
}
inline ::commonmodule::PMG* ReserveMargin::mutable_var() {
  ::commonmodule::PMG* _msg = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveMargin.VAr)
  return _msg;
}
inline void ReserveMargin::set_allocated_var(::commonmodule::PMG* var) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.var_);
  }
  if (var) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(var));
    if (message_arena != submessage_arena) {
      var = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, var, submessage_arena);
    }

  } else {

  }
  _impl_.var_ = var;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveMargin.VAr)
}

// .commonmodule.PMG W = 5;
inline bool ReserveMargin::_internal_has_w() const {
  return this != internal_default_instance() && _impl_.w_ != nullptr;
}
inline bool ReserveMargin::has_w() const {
  return _internal_has_w();
}
inline const ::commonmodule::PMG& ReserveMargin::_internal_w() const {
  const ::commonmodule::PMG* p = _impl_.w_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PMG&>(
      ::commonmodule::_PMG_default_instance_);
}
inline const ::commonmodule::PMG& ReserveMargin::w() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveMargin.W)
  return _internal_w();
}
inline void ReserveMargin::unsafe_arena_set_allocated_w(
    ::commonmodule::PMG* w) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.w_);
  }
  _impl_.w_ = w;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveMargin.W)
}
inline ::commonmodule::PMG* ReserveMargin::release_w() {
  
  ::commonmodule::PMG* temp = _impl_.w_;
  _impl_.w_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::unsafe_arena_release_w() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveMargin.W)
  
  ::commonmodule::PMG* temp = _impl_.w_;
  _impl_.w_ = nullptr;
  return temp;
}
inline ::commonmodule::PMG* ReserveMargin::_internal_mutable_w() {
  
  if (_impl_.w_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PMG>(GetArenaForAllocation());
    _impl_.w_ = p;
  }
  return _impl_.w_;
}
inline ::commonmodule::PMG* ReserveMargin::mutable_w() {
  ::commonmodule::PMG* _msg = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveMargin.W)
  return _msg;
}
inline void ReserveMargin::set_allocated_w(::commonmodule::PMG* w) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.w_);
  }
  if (w) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(w));
    if (message_arena != submessage_arena) {
      w = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, w, submessage_arena);
    }

  } else {

  }
  _impl_.w_ = w;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveMargin.W)
}

// -------------------------------------------------------------------

// ReserveAvailability

// .reservemodule.ReserveMargin incrementalMargin = 1;
inline bool ReserveAvailability::_internal_has_incrementalmargin() const {
  return this != internal_default_instance() && _impl_.incrementalmargin_ != nullptr;
}
inline bool ReserveAvailability::has_incrementalmargin() const {
  return _internal_has_incrementalmargin();
}
inline void ReserveAvailability::clear_incrementalmargin() {
  if (GetArenaForAllocation() == nullptr && _impl_.incrementalmargin_ != nullptr) {
    delete _impl_.incrementalmargin_;
  }
  _impl_.incrementalmargin_ = nullptr;
}
inline const ::reservemodule::ReserveMargin& ReserveAvailability::_internal_incrementalmargin() const {
  const ::reservemodule::ReserveMargin* p = _impl_.incrementalmargin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveMargin&>(
      ::reservemodule::_ReserveMargin_default_instance_);
}
inline const ::reservemodule::ReserveMargin& ReserveAvailability::incrementalmargin() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailability.incrementalMargin)
  return _internal_incrementalmargin();
}
inline void ReserveAvailability::unsafe_arena_set_allocated_incrementalmargin(
    ::reservemodule::ReserveMargin* incrementalmargin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.incrementalmargin_);
  }
  _impl_.incrementalmargin_ = incrementalmargin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailability.incrementalMargin)
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::release_incrementalmargin() {
  
  ::reservemodule::ReserveMargin* temp = _impl_.incrementalmargin_;
  _impl_.incrementalmargin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::unsafe_arena_release_incrementalmargin() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailability.incrementalMargin)
  
  ::reservemodule::ReserveMargin* temp = _impl_.incrementalmargin_;
  _impl_.incrementalmargin_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::_internal_mutable_incrementalmargin() {
  
  if (_impl_.incrementalmargin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveMargin>(GetArenaForAllocation());
    _impl_.incrementalmargin_ = p;
  }
  return _impl_.incrementalmargin_;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::mutable_incrementalmargin() {
  ::reservemodule::ReserveMargin* _msg = _internal_mutable_incrementalmargin();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailability.incrementalMargin)
  return _msg;
}
inline void ReserveAvailability::set_allocated_incrementalmargin(::reservemodule::ReserveMargin* incrementalmargin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.incrementalmargin_;
  }
  if (incrementalmargin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(incrementalmargin);
    if (message_arena != submessage_arena) {
      incrementalmargin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, incrementalmargin, submessage_arena);
    }

  } else {

  }
  _impl_.incrementalmargin_ = incrementalmargin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailability.incrementalMargin)
}

// .reservemodule.ReserveMargin margin = 2;
inline bool ReserveAvailability::_internal_has_margin() const {
  return this != internal_default_instance() && _impl_.margin_ != nullptr;
}
inline bool ReserveAvailability::has_margin() const {
  return _internal_has_margin();
}
inline void ReserveAvailability::clear_margin() {
  if (GetArenaForAllocation() == nullptr && _impl_.margin_ != nullptr) {
    delete _impl_.margin_;
  }
  _impl_.margin_ = nullptr;
}
inline const ::reservemodule::ReserveMargin& ReserveAvailability::_internal_margin() const {
  const ::reservemodule::ReserveMargin* p = _impl_.margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveMargin&>(
      ::reservemodule::_ReserveMargin_default_instance_);
}
inline const ::reservemodule::ReserveMargin& ReserveAvailability::margin() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailability.margin)
  return _internal_margin();
}
inline void ReserveAvailability::unsafe_arena_set_allocated_margin(
    ::reservemodule::ReserveMargin* margin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.margin_);
  }
  _impl_.margin_ = margin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailability.margin)
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::release_margin() {
  
  ::reservemodule::ReserveMargin* temp = _impl_.margin_;
  _impl_.margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::unsafe_arena_release_margin() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailability.margin)
  
  ::reservemodule::ReserveMargin* temp = _impl_.margin_;
  _impl_.margin_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::_internal_mutable_margin() {
  
  if (_impl_.margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveMargin>(GetArenaForAllocation());
    _impl_.margin_ = p;
  }
  return _impl_.margin_;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::mutable_margin() {
  ::reservemodule::ReserveMargin* _msg = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailability.margin)
  return _msg;
}
inline void ReserveAvailability::set_allocated_margin(::reservemodule::ReserveMargin* margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.margin_;
  }
  if (margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(margin);
    if (message_arena != submessage_arena) {
      margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, margin, submessage_arena);
    }

  } else {

  }
  _impl_.margin_ = margin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailability.margin)
}

// .reservemodule.ReserveMargin standbyMargin = 3;
inline bool ReserveAvailability::_internal_has_standbymargin() const {
  return this != internal_default_instance() && _impl_.standbymargin_ != nullptr;
}
inline bool ReserveAvailability::has_standbymargin() const {
  return _internal_has_standbymargin();
}
inline void ReserveAvailability::clear_standbymargin() {
  if (GetArenaForAllocation() == nullptr && _impl_.standbymargin_ != nullptr) {
    delete _impl_.standbymargin_;
  }
  _impl_.standbymargin_ = nullptr;
}
inline const ::reservemodule::ReserveMargin& ReserveAvailability::_internal_standbymargin() const {
  const ::reservemodule::ReserveMargin* p = _impl_.standbymargin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveMargin&>(
      ::reservemodule::_ReserveMargin_default_instance_);
}
inline const ::reservemodule::ReserveMargin& ReserveAvailability::standbymargin() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailability.standbyMargin)
  return _internal_standbymargin();
}
inline void ReserveAvailability::unsafe_arena_set_allocated_standbymargin(
    ::reservemodule::ReserveMargin* standbymargin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.standbymargin_);
  }
  _impl_.standbymargin_ = standbymargin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailability.standbyMargin)
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::release_standbymargin() {
  
  ::reservemodule::ReserveMargin* temp = _impl_.standbymargin_;
  _impl_.standbymargin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::unsafe_arena_release_standbymargin() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailability.standbyMargin)
  
  ::reservemodule::ReserveMargin* temp = _impl_.standbymargin_;
  _impl_.standbymargin_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::_internal_mutable_standbymargin() {
  
  if (_impl_.standbymargin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveMargin>(GetArenaForAllocation());
    _impl_.standbymargin_ = p;
  }
  return _impl_.standbymargin_;
}
inline ::reservemodule::ReserveMargin* ReserveAvailability::mutable_standbymargin() {
  ::reservemodule::ReserveMargin* _msg = _internal_mutable_standbymargin();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailability.standbyMargin)
  return _msg;
}
inline void ReserveAvailability::set_allocated_standbymargin(::reservemodule::ReserveMargin* standbymargin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.standbymargin_;
  }
  if (standbymargin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(standbymargin);
    if (message_arena != submessage_arena) {
      standbymargin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, standbymargin, submessage_arena);
    }

  } else {

  }
  _impl_.standbymargin_ = standbymargin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailability.standbyMargin)
}

// -------------------------------------------------------------------

// AllocatedMargin

// string requestID = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void AllocatedMargin::clear_requestid() {
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& AllocatedMargin::requestid() const {
  // @@protoc_insertion_point(field_get:reservemodule.AllocatedMargin.requestID)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocatedMargin::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:reservemodule.AllocatedMargin.requestID)
}
inline std::string* AllocatedMargin::mutable_requestid() {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:reservemodule.AllocatedMargin.requestID)
  return _s;
}
inline const std::string& AllocatedMargin::_internal_requestid() const {
  return _impl_.requestid_.Get();
}
inline void AllocatedMargin::_internal_set_requestid(const std::string& value) {
  ;


  _impl_.requestid_.Set(value, GetArenaForAllocation());
}
inline std::string* AllocatedMargin::_internal_mutable_requestid() {
  ;
  return _impl_.requestid_.Mutable( GetArenaForAllocation());
}
inline std::string* AllocatedMargin::release_requestid() {
  // @@protoc_insertion_point(field_release:reservemodule.AllocatedMargin.requestID)
  return _impl_.requestid_.Release();
}
inline void AllocatedMargin::set_allocated_requestid(std::string* value) {
  _impl_.requestid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:reservemodule.AllocatedMargin.requestID)
}

// .reservemodule.ReserveMargin allocatedMargin = 2;
inline bool AllocatedMargin::_internal_has_allocatedmargin() const {
  return this != internal_default_instance() && _impl_.allocatedmargin_ != nullptr;
}
inline bool AllocatedMargin::has_allocatedmargin() const {
  return _internal_has_allocatedmargin();
}
inline void AllocatedMargin::clear_allocatedmargin() {
  if (GetArenaForAllocation() == nullptr && _impl_.allocatedmargin_ != nullptr) {
    delete _impl_.allocatedmargin_;
  }
  _impl_.allocatedmargin_ = nullptr;
}
inline const ::reservemodule::ReserveMargin& AllocatedMargin::_internal_allocatedmargin() const {
  const ::reservemodule::ReserveMargin* p = _impl_.allocatedmargin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveMargin&>(
      ::reservemodule::_ReserveMargin_default_instance_);
}
inline const ::reservemodule::ReserveMargin& AllocatedMargin::allocatedmargin() const {
  // @@protoc_insertion_point(field_get:reservemodule.AllocatedMargin.allocatedMargin)
  return _internal_allocatedmargin();
}
inline void AllocatedMargin::unsafe_arena_set_allocated_allocatedmargin(
    ::reservemodule::ReserveMargin* allocatedmargin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allocatedmargin_);
  }
  _impl_.allocatedmargin_ = allocatedmargin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.AllocatedMargin.allocatedMargin)
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::release_allocatedmargin() {
  
  ::reservemodule::ReserveMargin* temp = _impl_.allocatedmargin_;
  _impl_.allocatedmargin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::unsafe_arena_release_allocatedmargin() {
  // @@protoc_insertion_point(field_release:reservemodule.AllocatedMargin.allocatedMargin)
  
  ::reservemodule::ReserveMargin* temp = _impl_.allocatedmargin_;
  _impl_.allocatedmargin_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::_internal_mutable_allocatedmargin() {
  
  if (_impl_.allocatedmargin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveMargin>(GetArenaForAllocation());
    _impl_.allocatedmargin_ = p;
  }
  return _impl_.allocatedmargin_;
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::mutable_allocatedmargin() {
  ::reservemodule::ReserveMargin* _msg = _internal_mutable_allocatedmargin();
  // @@protoc_insertion_point(field_mutable:reservemodule.AllocatedMargin.allocatedMargin)
  return _msg;
}
inline void AllocatedMargin::set_allocated_allocatedmargin(::reservemodule::ReserveMargin* allocatedmargin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allocatedmargin_;
  }
  if (allocatedmargin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allocatedmargin);
    if (message_arena != submessage_arena) {
      allocatedmargin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allocatedmargin, submessage_arena);
    }

  } else {

  }
  _impl_.allocatedmargin_ = allocatedmargin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.AllocatedMargin.allocatedMargin)
}

// .reservemodule.ReserveMargin allocatedStandbyMargin = 3;
inline bool AllocatedMargin::_internal_has_allocatedstandbymargin() const {
  return this != internal_default_instance() && _impl_.allocatedstandbymargin_ != nullptr;
}
inline bool AllocatedMargin::has_allocatedstandbymargin() const {
  return _internal_has_allocatedstandbymargin();
}
inline void AllocatedMargin::clear_allocatedstandbymargin() {
  if (GetArenaForAllocation() == nullptr && _impl_.allocatedstandbymargin_ != nullptr) {
    delete _impl_.allocatedstandbymargin_;
  }
  _impl_.allocatedstandbymargin_ = nullptr;
}
inline const ::reservemodule::ReserveMargin& AllocatedMargin::_internal_allocatedstandbymargin() const {
  const ::reservemodule::ReserveMargin* p = _impl_.allocatedstandbymargin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveMargin&>(
      ::reservemodule::_ReserveMargin_default_instance_);
}
inline const ::reservemodule::ReserveMargin& AllocatedMargin::allocatedstandbymargin() const {
  // @@protoc_insertion_point(field_get:reservemodule.AllocatedMargin.allocatedStandbyMargin)
  return _internal_allocatedstandbymargin();
}
inline void AllocatedMargin::unsafe_arena_set_allocated_allocatedstandbymargin(
    ::reservemodule::ReserveMargin* allocatedstandbymargin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allocatedstandbymargin_);
  }
  _impl_.allocatedstandbymargin_ = allocatedstandbymargin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.AllocatedMargin.allocatedStandbyMargin)
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::release_allocatedstandbymargin() {
  
  ::reservemodule::ReserveMargin* temp = _impl_.allocatedstandbymargin_;
  _impl_.allocatedstandbymargin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::unsafe_arena_release_allocatedstandbymargin() {
  // @@protoc_insertion_point(field_release:reservemodule.AllocatedMargin.allocatedStandbyMargin)
  
  ::reservemodule::ReserveMargin* temp = _impl_.allocatedstandbymargin_;
  _impl_.allocatedstandbymargin_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::_internal_mutable_allocatedstandbymargin() {
  
  if (_impl_.allocatedstandbymargin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveMargin>(GetArenaForAllocation());
    _impl_.allocatedstandbymargin_ = p;
  }
  return _impl_.allocatedstandbymargin_;
}
inline ::reservemodule::ReserveMargin* AllocatedMargin::mutable_allocatedstandbymargin() {
  ::reservemodule::ReserveMargin* _msg = _internal_mutable_allocatedstandbymargin();
  // @@protoc_insertion_point(field_mutable:reservemodule.AllocatedMargin.allocatedStandbyMargin)
  return _msg;
}
inline void AllocatedMargin::set_allocated_allocatedstandbymargin(::reservemodule::ReserveMargin* allocatedstandbymargin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allocatedstandbymargin_;
  }
  if (allocatedstandbymargin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allocatedstandbymargin);
    if (message_arena != submessage_arena) {
      allocatedstandbymargin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allocatedstandbymargin, submessage_arena);
    }

  } else {

  }
  _impl_.allocatedstandbymargin_ = allocatedstandbymargin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.AllocatedMargin.allocatedStandbyMargin)
}

// -------------------------------------------------------------------

// ReserveAvailabilityProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ReserveAvailabilityProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool ReserveAvailabilityProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& ReserveAvailabilityProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& ReserveAvailabilityProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailabilityProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void ReserveAvailabilityProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailabilityProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* ReserveAvailabilityProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ReserveAvailabilityProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailabilityProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ReserveAvailabilityProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* ReserveAvailabilityProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailabilityProfile.controlMessageInfo)
  return _msg;
}
inline void ReserveAvailabilityProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailabilityProfile.controlMessageInfo)
}

// .reservemodule.AllocatedMargin allocatedMargin = 2;
inline bool ReserveAvailabilityProfile::_internal_has_allocatedmargin() const {
  return this != internal_default_instance() && _impl_.allocatedmargin_ != nullptr;
}
inline bool ReserveAvailabilityProfile::has_allocatedmargin() const {
  return _internal_has_allocatedmargin();
}
inline void ReserveAvailabilityProfile::clear_allocatedmargin() {
  if (GetArenaForAllocation() == nullptr && _impl_.allocatedmargin_ != nullptr) {
    delete _impl_.allocatedmargin_;
  }
  _impl_.allocatedmargin_ = nullptr;
}
inline const ::reservemodule::AllocatedMargin& ReserveAvailabilityProfile::_internal_allocatedmargin() const {
  const ::reservemodule::AllocatedMargin* p = _impl_.allocatedmargin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::AllocatedMargin&>(
      ::reservemodule::_AllocatedMargin_default_instance_);
}
inline const ::reservemodule::AllocatedMargin& ReserveAvailabilityProfile::allocatedmargin() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailabilityProfile.allocatedMargin)
  return _internal_allocatedmargin();
}
inline void ReserveAvailabilityProfile::unsafe_arena_set_allocated_allocatedmargin(
    ::reservemodule::AllocatedMargin* allocatedmargin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allocatedmargin_);
  }
  _impl_.allocatedmargin_ = allocatedmargin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailabilityProfile.allocatedMargin)
}
inline ::reservemodule::AllocatedMargin* ReserveAvailabilityProfile::release_allocatedmargin() {
  
  ::reservemodule::AllocatedMargin* temp = _impl_.allocatedmargin_;
  _impl_.allocatedmargin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::AllocatedMargin* ReserveAvailabilityProfile::unsafe_arena_release_allocatedmargin() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailabilityProfile.allocatedMargin)
  
  ::reservemodule::AllocatedMargin* temp = _impl_.allocatedmargin_;
  _impl_.allocatedmargin_ = nullptr;
  return temp;
}
inline ::reservemodule::AllocatedMargin* ReserveAvailabilityProfile::_internal_mutable_allocatedmargin() {
  
  if (_impl_.allocatedmargin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::AllocatedMargin>(GetArenaForAllocation());
    _impl_.allocatedmargin_ = p;
  }
  return _impl_.allocatedmargin_;
}
inline ::reservemodule::AllocatedMargin* ReserveAvailabilityProfile::mutable_allocatedmargin() {
  ::reservemodule::AllocatedMargin* _msg = _internal_mutable_allocatedmargin();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailabilityProfile.allocatedMargin)
  return _msg;
}
inline void ReserveAvailabilityProfile::set_allocated_allocatedmargin(::reservemodule::AllocatedMargin* allocatedmargin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allocatedmargin_;
  }
  if (allocatedmargin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allocatedmargin);
    if (message_arena != submessage_arena) {
      allocatedmargin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allocatedmargin, submessage_arena);
    }

  } else {

  }
  _impl_.allocatedmargin_ = allocatedmargin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailabilityProfile.allocatedMargin)
}

// .commonmodule.ApplicationSystem requesterCircuitSegmentService = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveAvailabilityProfile::_internal_has_requestercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.requestercircuitsegmentservice_ != nullptr;
}
inline bool ReserveAvailabilityProfile::has_requestercircuitsegmentservice() const {
  return _internal_has_requestercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& ReserveAvailabilityProfile::_internal_requestercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.requestercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& ReserveAvailabilityProfile::requestercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailabilityProfile.requesterCircuitSegmentService)
  return _internal_requestercircuitsegmentservice();
}
inline void ReserveAvailabilityProfile::unsafe_arena_set_allocated_requestercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailabilityProfile.requesterCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::release_requestercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::unsafe_arena_release_requestercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailabilityProfile.requesterCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::_internal_mutable_requestercircuitsegmentservice() {
  
  if (_impl_.requestercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.requestercircuitsegmentservice_ = p;
  }
  return _impl_.requestercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::mutable_requestercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_requestercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailabilityProfile.requesterCircuitSegmentService)
  return _msg;
}
inline void ReserveAvailabilityProfile::set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  if (requestercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requestercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      requestercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailabilityProfile.requesterCircuitSegmentService)
}

// .reservemodule.ReserveAvailability reserveAvailability = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveAvailabilityProfile::_internal_has_reserveavailability() const {
  return this != internal_default_instance() && _impl_.reserveavailability_ != nullptr;
}
inline bool ReserveAvailabilityProfile::has_reserveavailability() const {
  return _internal_has_reserveavailability();
}
inline void ReserveAvailabilityProfile::clear_reserveavailability() {
  if (GetArenaForAllocation() == nullptr && _impl_.reserveavailability_ != nullptr) {
    delete _impl_.reserveavailability_;
  }
  _impl_.reserveavailability_ = nullptr;
}
inline const ::reservemodule::ReserveAvailability& ReserveAvailabilityProfile::_internal_reserveavailability() const {
  const ::reservemodule::ReserveAvailability* p = _impl_.reserveavailability_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveAvailability&>(
      ::reservemodule::_ReserveAvailability_default_instance_);
}
inline const ::reservemodule::ReserveAvailability& ReserveAvailabilityProfile::reserveavailability() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailabilityProfile.reserveAvailability)
  return _internal_reserveavailability();
}
inline void ReserveAvailabilityProfile::unsafe_arena_set_allocated_reserveavailability(
    ::reservemodule::ReserveAvailability* reserveavailability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reserveavailability_);
  }
  _impl_.reserveavailability_ = reserveavailability;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailabilityProfile.reserveAvailability)
}
inline ::reservemodule::ReserveAvailability* ReserveAvailabilityProfile::release_reserveavailability() {
  
  ::reservemodule::ReserveAvailability* temp = _impl_.reserveavailability_;
  _impl_.reserveavailability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveAvailability* ReserveAvailabilityProfile::unsafe_arena_release_reserveavailability() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailabilityProfile.reserveAvailability)
  
  ::reservemodule::ReserveAvailability* temp = _impl_.reserveavailability_;
  _impl_.reserveavailability_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveAvailability* ReserveAvailabilityProfile::_internal_mutable_reserveavailability() {
  
  if (_impl_.reserveavailability_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveAvailability>(GetArenaForAllocation());
    _impl_.reserveavailability_ = p;
  }
  return _impl_.reserveavailability_;
}
inline ::reservemodule::ReserveAvailability* ReserveAvailabilityProfile::mutable_reserveavailability() {
  ::reservemodule::ReserveAvailability* _msg = _internal_mutable_reserveavailability();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailabilityProfile.reserveAvailability)
  return _msg;
}
inline void ReserveAvailabilityProfile::set_allocated_reserveavailability(::reservemodule::ReserveAvailability* reserveavailability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reserveavailability_;
  }
  if (reserveavailability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reserveavailability);
    if (message_arena != submessage_arena) {
      reserveavailability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reserveavailability, submessage_arena);
    }

  } else {

  }
  _impl_.reserveavailability_ = reserveavailability;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailabilityProfile.reserveAvailability)
}

// .commonmodule.ApplicationSystem responderCircuitSegmentService = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveAvailabilityProfile::_internal_has_respondercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.respondercircuitsegmentservice_ != nullptr;
}
inline bool ReserveAvailabilityProfile::has_respondercircuitsegmentservice() const {
  return _internal_has_respondercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& ReserveAvailabilityProfile::_internal_respondercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.respondercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& ReserveAvailabilityProfile::respondercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailabilityProfile.responderCircuitSegmentService)
  return _internal_respondercircuitsegmentservice();
}
inline void ReserveAvailabilityProfile::unsafe_arena_set_allocated_respondercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailabilityProfile.responderCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::release_respondercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::unsafe_arena_release_respondercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailabilityProfile.responderCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::_internal_mutable_respondercircuitsegmentservice() {
  
  if (_impl_.respondercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.respondercircuitsegmentservice_ = p;
  }
  return _impl_.respondercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* ReserveAvailabilityProfile::mutable_respondercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_respondercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailabilityProfile.responderCircuitSegmentService)
  return _msg;
}
inline void ReserveAvailabilityProfile::set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  if (respondercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(respondercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      respondercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, respondercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailabilityProfile.responderCircuitSegmentService)
}

// .commonmodule.ConductingEquipment tiePoint = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveAvailabilityProfile::_internal_has_tiepoint() const {
  return this != internal_default_instance() && _impl_.tiepoint_ != nullptr;
}
inline bool ReserveAvailabilityProfile::has_tiepoint() const {
  return _internal_has_tiepoint();
}
inline const ::commonmodule::ConductingEquipment& ReserveAvailabilityProfile::_internal_tiepoint() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.tiepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& ReserveAvailabilityProfile::tiepoint() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveAvailabilityProfile.tiePoint)
  return _internal_tiepoint();
}
inline void ReserveAvailabilityProfile::unsafe_arena_set_allocated_tiepoint(
    ::commonmodule::ConductingEquipment* tiepoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveAvailabilityProfile.tiePoint)
}
inline ::commonmodule::ConductingEquipment* ReserveAvailabilityProfile::release_tiepoint() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* ReserveAvailabilityProfile::unsafe_arena_release_tiepoint() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveAvailabilityProfile.tiePoint)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* ReserveAvailabilityProfile::_internal_mutable_tiepoint() {
  
  if (_impl_.tiepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.tiepoint_ = p;
  }
  return _impl_.tiepoint_;
}
inline ::commonmodule::ConductingEquipment* ReserveAvailabilityProfile::mutable_tiepoint() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_tiepoint();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveAvailabilityProfile.tiePoint)
  return _msg;
}
inline void ReserveAvailabilityProfile::set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  if (tiepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tiepoint));
    if (message_arena != submessage_arena) {
      tiepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tiepoint, submessage_arena);
    }

  } else {

  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveAvailabilityProfile.tiePoint)
}

// -------------------------------------------------------------------

// ReserveRequest

// string requestID = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ReserveRequest::clear_requestid() {
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& ReserveRequest::requestid() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequest.requestID)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReserveRequest::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:reservemodule.ReserveRequest.requestID)
}
inline std::string* ReserveRequest::mutable_requestid() {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequest.requestID)
  return _s;
}
inline const std::string& ReserveRequest::_internal_requestid() const {
  return _impl_.requestid_.Get();
}
inline void ReserveRequest::_internal_set_requestid(const std::string& value) {
  ;


  _impl_.requestid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReserveRequest::_internal_mutable_requestid() {
  ;
  return _impl_.requestid_.Mutable( GetArenaForAllocation());
}
inline std::string* ReserveRequest::release_requestid() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequest.requestID)
  return _impl_.requestid_.Release();
}
inline void ReserveRequest::set_allocated_requestid(std::string* value) {
  _impl_.requestid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequest.requestID)
}

// .reservemodule.ReserveMargin margin = 2;
inline bool ReserveRequest::_internal_has_margin() const {
  return this != internal_default_instance() && _impl_.margin_ != nullptr;
}
inline bool ReserveRequest::has_margin() const {
  return _internal_has_margin();
}
inline void ReserveRequest::clear_margin() {
  if (GetArenaForAllocation() == nullptr && _impl_.margin_ != nullptr) {
    delete _impl_.margin_;
  }
  _impl_.margin_ = nullptr;
}
inline const ::reservemodule::ReserveMargin& ReserveRequest::_internal_margin() const {
  const ::reservemodule::ReserveMargin* p = _impl_.margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveMargin&>(
      ::reservemodule::_ReserveMargin_default_instance_);
}
inline const ::reservemodule::ReserveMargin& ReserveRequest::margin() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequest.margin)
  return _internal_margin();
}
inline void ReserveRequest::unsafe_arena_set_allocated_margin(
    ::reservemodule::ReserveMargin* margin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.margin_);
  }
  _impl_.margin_ = margin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveRequest.margin)
}
inline ::reservemodule::ReserveMargin* ReserveRequest::release_margin() {
  
  ::reservemodule::ReserveMargin* temp = _impl_.margin_;
  _impl_.margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveRequest::unsafe_arena_release_margin() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequest.margin)
  
  ::reservemodule::ReserveMargin* temp = _impl_.margin_;
  _impl_.margin_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveRequest::_internal_mutable_margin() {
  
  if (_impl_.margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveMargin>(GetArenaForAllocation());
    _impl_.margin_ = p;
  }
  return _impl_.margin_;
}
inline ::reservemodule::ReserveMargin* ReserveRequest::mutable_margin() {
  ::reservemodule::ReserveMargin* _msg = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequest.margin)
  return _msg;
}
inline void ReserveRequest::set_allocated_margin(::reservemodule::ReserveMargin* margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.margin_;
  }
  if (margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(margin);
    if (message_arena != submessage_arena) {
      margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, margin, submessage_arena);
    }

  } else {

  }
  _impl_.margin_ = margin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequest.margin)
}

// .reservemodule.ReserveMargin standbyMargin = 3;
inline bool ReserveRequest::_internal_has_standbymargin() const {
  return this != internal_default_instance() && _impl_.standbymargin_ != nullptr;
}
inline bool ReserveRequest::has_standbymargin() const {
  return _internal_has_standbymargin();
}
inline void ReserveRequest::clear_standbymargin() {
  if (GetArenaForAllocation() == nullptr && _impl_.standbymargin_ != nullptr) {
    delete _impl_.standbymargin_;
  }
  _impl_.standbymargin_ = nullptr;
}
inline const ::reservemodule::ReserveMargin& ReserveRequest::_internal_standbymargin() const {
  const ::reservemodule::ReserveMargin* p = _impl_.standbymargin_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveMargin&>(
      ::reservemodule::_ReserveMargin_default_instance_);
}
inline const ::reservemodule::ReserveMargin& ReserveRequest::standbymargin() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequest.standbyMargin)
  return _internal_standbymargin();
}
inline void ReserveRequest::unsafe_arena_set_allocated_standbymargin(
    ::reservemodule::ReserveMargin* standbymargin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.standbymargin_);
  }
  _impl_.standbymargin_ = standbymargin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveRequest.standbyMargin)
}
inline ::reservemodule::ReserveMargin* ReserveRequest::release_standbymargin() {
  
  ::reservemodule::ReserveMargin* temp = _impl_.standbymargin_;
  _impl_.standbymargin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveRequest::unsafe_arena_release_standbymargin() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequest.standbyMargin)
  
  ::reservemodule::ReserveMargin* temp = _impl_.standbymargin_;
  _impl_.standbymargin_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveMargin* ReserveRequest::_internal_mutable_standbymargin() {
  
  if (_impl_.standbymargin_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveMargin>(GetArenaForAllocation());
    _impl_.standbymargin_ = p;
  }
  return _impl_.standbymargin_;
}
inline ::reservemodule::ReserveMargin* ReserveRequest::mutable_standbymargin() {
  ::reservemodule::ReserveMargin* _msg = _internal_mutable_standbymargin();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequest.standbyMargin)
  return _msg;
}
inline void ReserveRequest::set_allocated_standbymargin(::reservemodule::ReserveMargin* standbymargin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.standbymargin_;
  }
  if (standbymargin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(standbymargin);
    if (message_arena != submessage_arena) {
      standbymargin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, standbymargin, submessage_arena);
    }

  } else {

  }
  _impl_.standbymargin_ = standbymargin;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequest.standbyMargin)
}

// -------------------------------------------------------------------

// ReserveRequestProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ReserveRequestProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool ReserveRequestProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& ReserveRequestProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& ReserveRequestProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequestProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void ReserveRequestProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveRequestProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* ReserveRequestProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ReserveRequestProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequestProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ReserveRequestProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* ReserveRequestProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequestProfile.controlMessageInfo)
  return _msg;
}
inline void ReserveRequestProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequestProfile.controlMessageInfo)
}

// .commonmodule.ApplicationSystem requesterCircuitSegmentService = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveRequestProfile::_internal_has_requestercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.requestercircuitsegmentservice_ != nullptr;
}
inline bool ReserveRequestProfile::has_requestercircuitsegmentservice() const {
  return _internal_has_requestercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& ReserveRequestProfile::_internal_requestercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.requestercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& ReserveRequestProfile::requestercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequestProfile.requesterCircuitSegmentService)
  return _internal_requestercircuitsegmentservice();
}
inline void ReserveRequestProfile::unsafe_arena_set_allocated_requestercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveRequestProfile.requesterCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::release_requestercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::unsafe_arena_release_requestercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequestProfile.requesterCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::_internal_mutable_requestercircuitsegmentservice() {
  
  if (_impl_.requestercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.requestercircuitsegmentservice_ = p;
  }
  return _impl_.requestercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::mutable_requestercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_requestercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequestProfile.requesterCircuitSegmentService)
  return _msg;
}
inline void ReserveRequestProfile::set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  if (requestercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requestercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      requestercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequestProfile.requesterCircuitSegmentService)
}

// .reservemodule.ReserveRequest reserveRequest = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveRequestProfile::_internal_has_reserverequest() const {
  return this != internal_default_instance() && _impl_.reserverequest_ != nullptr;
}
inline bool ReserveRequestProfile::has_reserverequest() const {
  return _internal_has_reserverequest();
}
inline void ReserveRequestProfile::clear_reserverequest() {
  if (GetArenaForAllocation() == nullptr && _impl_.reserverequest_ != nullptr) {
    delete _impl_.reserverequest_;
  }
  _impl_.reserverequest_ = nullptr;
}
inline const ::reservemodule::ReserveRequest& ReserveRequestProfile::_internal_reserverequest() const {
  const ::reservemodule::ReserveRequest* p = _impl_.reserverequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::reservemodule::ReserveRequest&>(
      ::reservemodule::_ReserveRequest_default_instance_);
}
inline const ::reservemodule::ReserveRequest& ReserveRequestProfile::reserverequest() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequestProfile.reserveRequest)
  return _internal_reserverequest();
}
inline void ReserveRequestProfile::unsafe_arena_set_allocated_reserverequest(
    ::reservemodule::ReserveRequest* reserverequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reserverequest_);
  }
  _impl_.reserverequest_ = reserverequest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveRequestProfile.reserveRequest)
}
inline ::reservemodule::ReserveRequest* ReserveRequestProfile::release_reserverequest() {
  
  ::reservemodule::ReserveRequest* temp = _impl_.reserverequest_;
  _impl_.reserverequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reservemodule::ReserveRequest* ReserveRequestProfile::unsafe_arena_release_reserverequest() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequestProfile.reserveRequest)
  
  ::reservemodule::ReserveRequest* temp = _impl_.reserverequest_;
  _impl_.reserverequest_ = nullptr;
  return temp;
}
inline ::reservemodule::ReserveRequest* ReserveRequestProfile::_internal_mutable_reserverequest() {
  
  if (_impl_.reserverequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::reservemodule::ReserveRequest>(GetArenaForAllocation());
    _impl_.reserverequest_ = p;
  }
  return _impl_.reserverequest_;
}
inline ::reservemodule::ReserveRequest* ReserveRequestProfile::mutable_reserverequest() {
  ::reservemodule::ReserveRequest* _msg = _internal_mutable_reserverequest();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequestProfile.reserveRequest)
  return _msg;
}
inline void ReserveRequestProfile::set_allocated_reserverequest(::reservemodule::ReserveRequest* reserverequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reserverequest_;
  }
  if (reserverequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reserverequest);
    if (message_arena != submessage_arena) {
      reserverequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reserverequest, submessage_arena);
    }

  } else {

  }
  _impl_.reserverequest_ = reserverequest;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequestProfile.reserveRequest)
}

// .commonmodule.ApplicationSystem responderCircuitSegmentService = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveRequestProfile::_internal_has_respondercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.respondercircuitsegmentservice_ != nullptr;
}
inline bool ReserveRequestProfile::has_respondercircuitsegmentservice() const {
  return _internal_has_respondercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& ReserveRequestProfile::_internal_respondercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.respondercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& ReserveRequestProfile::respondercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequestProfile.responderCircuitSegmentService)
  return _internal_respondercircuitsegmentservice();
}
inline void ReserveRequestProfile::unsafe_arena_set_allocated_respondercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveRequestProfile.responderCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::release_respondercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::unsafe_arena_release_respondercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequestProfile.responderCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::_internal_mutable_respondercircuitsegmentservice() {
  
  if (_impl_.respondercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.respondercircuitsegmentservice_ = p;
  }
  return _impl_.respondercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* ReserveRequestProfile::mutable_respondercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_respondercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequestProfile.responderCircuitSegmentService)
  return _msg;
}
inline void ReserveRequestProfile::set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  if (respondercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(respondercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      respondercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, respondercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequestProfile.responderCircuitSegmentService)
}

// .commonmodule.ConductingEquipment tiePoint = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ReserveRequestProfile::_internal_has_tiepoint() const {
  return this != internal_default_instance() && _impl_.tiepoint_ != nullptr;
}
inline bool ReserveRequestProfile::has_tiepoint() const {
  return _internal_has_tiepoint();
}
inline const ::commonmodule::ConductingEquipment& ReserveRequestProfile::_internal_tiepoint() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.tiepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& ReserveRequestProfile::tiepoint() const {
  // @@protoc_insertion_point(field_get:reservemodule.ReserveRequestProfile.tiePoint)
  return _internal_tiepoint();
}
inline void ReserveRequestProfile::unsafe_arena_set_allocated_tiepoint(
    ::commonmodule::ConductingEquipment* tiepoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reservemodule.ReserveRequestProfile.tiePoint)
}
inline ::commonmodule::ConductingEquipment* ReserveRequestProfile::release_tiepoint() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* ReserveRequestProfile::unsafe_arena_release_tiepoint() {
  // @@protoc_insertion_point(field_release:reservemodule.ReserveRequestProfile.tiePoint)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* ReserveRequestProfile::_internal_mutable_tiepoint() {
  
  if (_impl_.tiepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.tiepoint_ = p;
  }
  return _impl_.tiepoint_;
}
inline ::commonmodule::ConductingEquipment* ReserveRequestProfile::mutable_tiepoint() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_tiepoint();
  // @@protoc_insertion_point(field_mutable:reservemodule.ReserveRequestProfile.tiePoint)
  return _msg;
}
inline void ReserveRequestProfile::set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  if (tiepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tiepoint));
    if (message_arena != submessage_arena) {
      tiepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tiepoint, submessage_arena);
    }

  } else {

  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_set_allocated:reservemodule.ReserveRequestProfile.tiePoint)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace reservemodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_reservemodule_2freservemodule_2eproto_2epb_2eh
