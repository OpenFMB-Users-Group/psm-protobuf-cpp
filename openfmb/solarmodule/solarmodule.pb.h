// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: solarmodule/solarmodule.proto

#ifndef PROTOBUF_INCLUDED_solarmodule_2fsolarmodule_2eproto
#define PROTOBUF_INCLUDED_solarmodule_2fsolarmodule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "uml.pb.h"
#include <google/protobuf/wrappers.pb.h>
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_solarmodule_2fsolarmodule_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_solarmodule_2fsolarmodule_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_solarmodule_2fsolarmodule_2eproto();
namespace solarmodule {
class SolarCSG;
class SolarCSGDefaultTypeInternal;
extern SolarCSGDefaultTypeInternal _SolarCSG_default_instance_;
class SolarControl;
class SolarControlDefaultTypeInternal;
extern SolarControlDefaultTypeInternal _SolarControl_default_instance_;
class SolarControlFSCC;
class SolarControlFSCCDefaultTypeInternal;
extern SolarControlFSCCDefaultTypeInternal _SolarControlFSCC_default_instance_;
class SolarControlProfile;
class SolarControlProfileDefaultTypeInternal;
extern SolarControlProfileDefaultTypeInternal _SolarControlProfile_default_instance_;
class SolarControlScheduleFSCH;
class SolarControlScheduleFSCHDefaultTypeInternal;
extern SolarControlScheduleFSCHDefaultTypeInternal _SolarControlScheduleFSCH_default_instance_;
class SolarEvent;
class SolarEventDefaultTypeInternal;
extern SolarEventDefaultTypeInternal _SolarEvent_default_instance_;
class SolarEventAndStatusZGEN;
class SolarEventAndStatusZGENDefaultTypeInternal;
extern SolarEventAndStatusZGENDefaultTypeInternal _SolarEventAndStatusZGEN_default_instance_;
class SolarEventProfile;
class SolarEventProfileDefaultTypeInternal;
extern SolarEventProfileDefaultTypeInternal _SolarEventProfile_default_instance_;
class SolarEventZGEN;
class SolarEventZGENDefaultTypeInternal;
extern SolarEventZGENDefaultTypeInternal _SolarEventZGEN_default_instance_;
class SolarInverter;
class SolarInverterDefaultTypeInternal;
extern SolarInverterDefaultTypeInternal _SolarInverter_default_instance_;
class SolarPoint;
class SolarPointDefaultTypeInternal;
extern SolarPointDefaultTypeInternal _SolarPoint_default_instance_;
class SolarPointStatus;
class SolarPointStatusDefaultTypeInternal;
extern SolarPointStatusDefaultTypeInternal _SolarPointStatus_default_instance_;
class SolarReading;
class SolarReadingDefaultTypeInternal;
extern SolarReadingDefaultTypeInternal _SolarReading_default_instance_;
class SolarReadingProfile;
class SolarReadingProfileDefaultTypeInternal;
extern SolarReadingProfileDefaultTypeInternal _SolarReadingProfile_default_instance_;
class SolarStatus;
class SolarStatusDefaultTypeInternal;
extern SolarStatusDefaultTypeInternal _SolarStatus_default_instance_;
class SolarStatusProfile;
class SolarStatusProfileDefaultTypeInternal;
extern SolarStatusProfileDefaultTypeInternal _SolarStatusProfile_default_instance_;
class SolarStatusZGEN;
class SolarStatusZGENDefaultTypeInternal;
extern SolarStatusZGENDefaultTypeInternal _SolarStatusZGEN_default_instance_;
}  // namespace solarmodule
namespace google {
namespace protobuf {
template<> ::solarmodule::SolarCSG* Arena::CreateMaybeMessage<::solarmodule::SolarCSG>(Arena*);
template<> ::solarmodule::SolarControl* Arena::CreateMaybeMessage<::solarmodule::SolarControl>(Arena*);
template<> ::solarmodule::SolarControlFSCC* Arena::CreateMaybeMessage<::solarmodule::SolarControlFSCC>(Arena*);
template<> ::solarmodule::SolarControlProfile* Arena::CreateMaybeMessage<::solarmodule::SolarControlProfile>(Arena*);
template<> ::solarmodule::SolarControlScheduleFSCH* Arena::CreateMaybeMessage<::solarmodule::SolarControlScheduleFSCH>(Arena*);
template<> ::solarmodule::SolarEvent* Arena::CreateMaybeMessage<::solarmodule::SolarEvent>(Arena*);
template<> ::solarmodule::SolarEventAndStatusZGEN* Arena::CreateMaybeMessage<::solarmodule::SolarEventAndStatusZGEN>(Arena*);
template<> ::solarmodule::SolarEventProfile* Arena::CreateMaybeMessage<::solarmodule::SolarEventProfile>(Arena*);
template<> ::solarmodule::SolarEventZGEN* Arena::CreateMaybeMessage<::solarmodule::SolarEventZGEN>(Arena*);
template<> ::solarmodule::SolarInverter* Arena::CreateMaybeMessage<::solarmodule::SolarInverter>(Arena*);
template<> ::solarmodule::SolarPoint* Arena::CreateMaybeMessage<::solarmodule::SolarPoint>(Arena*);
template<> ::solarmodule::SolarPointStatus* Arena::CreateMaybeMessage<::solarmodule::SolarPointStatus>(Arena*);
template<> ::solarmodule::SolarReading* Arena::CreateMaybeMessage<::solarmodule::SolarReading>(Arena*);
template<> ::solarmodule::SolarReadingProfile* Arena::CreateMaybeMessage<::solarmodule::SolarReadingProfile>(Arena*);
template<> ::solarmodule::SolarStatus* Arena::CreateMaybeMessage<::solarmodule::SolarStatus>(Arena*);
template<> ::solarmodule::SolarStatusProfile* Arena::CreateMaybeMessage<::solarmodule::SolarStatusProfile>(Arena*);
template<> ::solarmodule::SolarStatusZGEN* Arena::CreateMaybeMessage<::solarmodule::SolarStatusZGEN>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace solarmodule {

// ===================================================================

class SolarPoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarPoint) */ {
 public:
  SolarPoint();
  virtual ~SolarPoint();

  SolarPoint(const SolarPoint& from);

  inline SolarPoint& operator=(const SolarPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarPoint(SolarPoint&& from) noexcept
    : SolarPoint() {
    *this = ::std::move(from);
  }

  inline SolarPoint& operator=(SolarPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarPoint* internal_default_instance() {
    return reinterpret_cast<const SolarPoint*>(
               &_SolarPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SolarPoint* other);
  friend void swap(SolarPoint& a, SolarPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarPoint* New() const final {
    return CreateMaybeMessage<SolarPoint>(nullptr);
  }

  SolarPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarPoint& from);
  void MergeFrom(const SolarPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlDPC frequencySetPointEnabled = 1;
  bool has_frequencysetpointenabled() const;
  void clear_frequencysetpointenabled();
  static const int kFrequencySetPointEnabledFieldNumber = 1;
  const ::commonmodule::ControlDPC& frequencysetpointenabled() const;
  ::commonmodule::ControlDPC* release_frequencysetpointenabled();
  ::commonmodule::ControlDPC* mutable_frequencysetpointenabled();
  void set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled);

  // .commonmodule.ENG_GridConnectModeKind mode = 2;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);

  // .google.protobuf.FloatValue pctHzDroop = 3;
  bool has_pcthzdroop() const;
  void clear_pcthzdroop();
  static const int kPctHzDroopFieldNumber = 3;
  const ::google::protobuf::FloatValue& pcthzdroop() const;
  ::google::protobuf::FloatValue* release_pcthzdroop();
  ::google::protobuf::FloatValue* mutable_pcthzdroop();
  void set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop);

  // .google.protobuf.FloatValue pctVDroop = 4;
  bool has_pctvdroop() const;
  void clear_pctvdroop();
  static const int kPctVDroopFieldNumber = 4;
  const ::google::protobuf::FloatValue& pctvdroop() const;
  ::google::protobuf::FloatValue* release_pctvdroop();
  ::google::protobuf::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop);

  // .commonmodule.RampRate rampRates = 5;
  bool has_ramprates() const;
  void clear_ramprates();
  static const int kRampRatesFieldNumber = 5;
  const ::commonmodule::RampRate& ramprates() const;
  ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);

  // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;
  bool has_reactivepwrsetpointenabled() const;
  void clear_reactivepwrsetpointenabled();
  static const int kReactivePwrSetPointEnabledFieldNumber = 6;
  const ::commonmodule::ControlDPC& reactivepwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_reactivepwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled);

  // .commonmodule.ControlDPC realPwrSetPointEnabled = 7;
  bool has_realpwrsetpointenabled() const;
  void clear_realpwrsetpointenabled();
  static const int kRealPwrSetPointEnabledFieldNumber = 7;
  const ::commonmodule::ControlDPC& realpwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_realpwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled);

  // .commonmodule.ControlDPC reset = 8;
  bool has_reset() const;
  void clear_reset();
  static const int kResetFieldNumber = 8;
  const ::commonmodule::ControlDPC& reset() const;
  ::commonmodule::ControlDPC* release_reset();
  ::commonmodule::ControlDPC* mutable_reset();
  void set_allocated_reset(::commonmodule::ControlDPC* reset);

  // .commonmodule.Optional_StateKind state = 9;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 9;
  const ::commonmodule::Optional_StateKind& state() const;
  ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);

  // .commonmodule.ControlDPC voltageSetPointEnabled = 10;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled();
  static const int kVoltageSetPointEnabledFieldNumber = 10;
  const ::commonmodule::ControlDPC& voltagesetpointenabled() const;
  ::commonmodule::ControlDPC* release_voltagesetpointenabled();
  ::commonmodule::ControlDPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled);

  // .commonmodule.ControlTimestamp startTime = 11 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 11;
  const ::commonmodule::ControlTimestamp& starttime() const;
  ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarPoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlDPC* frequencysetpointenabled_;
  ::commonmodule::ENG_GridConnectModeKind* mode_;
  ::google::protobuf::FloatValue* pcthzdroop_;
  ::google::protobuf::FloatValue* pctvdroop_;
  ::commonmodule::RampRate* ramprates_;
  ::commonmodule::ControlDPC* reactivepwrsetpointenabled_;
  ::commonmodule::ControlDPC* realpwrsetpointenabled_;
  ::commonmodule::ControlDPC* reset_;
  ::commonmodule::Optional_StateKind* state_;
  ::commonmodule::ControlDPC* voltagesetpointenabled_;
  ::commonmodule::ControlTimestamp* starttime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarCSG :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCSG) */ {
 public:
  SolarCSG();
  virtual ~SolarCSG();

  SolarCSG(const SolarCSG& from);

  inline SolarCSG& operator=(const SolarCSG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarCSG(SolarCSG&& from) noexcept
    : SolarCSG() {
    *this = ::std::move(from);
  }

  inline SolarCSG& operator=(SolarCSG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarCSG& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarCSG* internal_default_instance() {
    return reinterpret_cast<const SolarCSG*>(
               &_SolarCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SolarCSG* other);
  friend void swap(SolarCSG& a, SolarCSG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarCSG* New() const final {
    return CreateMaybeMessage<SolarCSG>(nullptr);
  }

  SolarCSG* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarCSG>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarCSG& from);
  void MergeFrom(const SolarCSG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCSG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .solarmodule.SolarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  void clear_crvpts();
  static const int kCrvPtsFieldNumber = 1;
  ::solarmodule::SolarPoint* mutable_crvpts(int index);
  ::google::protobuf::RepeatedPtrField< ::solarmodule::SolarPoint >*
      mutable_crvpts();
  const ::solarmodule::SolarPoint& crvpts(int index) const;
  ::solarmodule::SolarPoint* add_crvpts();
  const ::google::protobuf::RepeatedPtrField< ::solarmodule::SolarPoint >&
      crvpts() const;

  // @@protoc_insertion_point(class_scope:solarmodule.SolarCSG)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::solarmodule::SolarPoint > crvpts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarControlScheduleFSCH :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControlScheduleFSCH) */ {
 public:
  SolarControlScheduleFSCH();
  virtual ~SolarControlScheduleFSCH();

  SolarControlScheduleFSCH(const SolarControlScheduleFSCH& from);

  inline SolarControlScheduleFSCH& operator=(const SolarControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarControlScheduleFSCH(SolarControlScheduleFSCH&& from) noexcept
    : SolarControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline SolarControlScheduleFSCH& operator=(SolarControlScheduleFSCH&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarControlScheduleFSCH& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const SolarControlScheduleFSCH*>(
               &_SolarControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SolarControlScheduleFSCH* other);
  friend void swap(SolarControlScheduleFSCH& a, SolarControlScheduleFSCH& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarControlScheduleFSCH* New() const final {
    return CreateMaybeMessage<SolarControlScheduleFSCH>(nullptr);
  }

  SolarControlScheduleFSCH* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarControlScheduleFSCH>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarControlScheduleFSCH& from);
  void MergeFrom(const SolarControlScheduleFSCH& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControlScheduleFSCH* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .solarmodule.SolarCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  void clear_valdcsg();
  static const int kValDCSGFieldNumber = 1;
  const ::solarmodule::SolarCSG& valdcsg() const;
  ::solarmodule::SolarCSG* release_valdcsg();
  ::solarmodule::SolarCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::solarmodule::SolarCSG* valdcsg);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarControlScheduleFSCH)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::solarmodule::SolarCSG* valdcsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarControlFSCC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControlFSCC) */ {
 public:
  SolarControlFSCC();
  virtual ~SolarControlFSCC();

  SolarControlFSCC(const SolarControlFSCC& from);

  inline SolarControlFSCC& operator=(const SolarControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarControlFSCC(SolarControlFSCC&& from) noexcept
    : SolarControlFSCC() {
    *this = ::std::move(from);
  }

  inline SolarControlFSCC& operator=(SolarControlFSCC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarControlFSCC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarControlFSCC* internal_default_instance() {
    return reinterpret_cast<const SolarControlFSCC*>(
               &_SolarControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SolarControlFSCC* other);
  friend void swap(SolarControlFSCC& a, SolarControlFSCC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarControlFSCC* New() const final {
    return CreateMaybeMessage<SolarControlFSCC>(nullptr);
  }

  SolarControlFSCC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarControlFSCC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarControlFSCC& from);
  void MergeFrom(const SolarControlFSCC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControlFSCC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  void clear_controlfscc();
  static const int kControlFSCCFieldNumber = 1;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);

  // .solarmodule.SolarControlScheduleFSCH SolarControlScheduleFSCH = 2;
  bool has_solarcontrolschedulefsch() const;
  void clear_solarcontrolschedulefsch();
  static const int kSolarControlScheduleFSCHFieldNumber = 2;
  const ::solarmodule::SolarControlScheduleFSCH& solarcontrolschedulefsch() const;
  ::solarmodule::SolarControlScheduleFSCH* release_solarcontrolschedulefsch();
  ::solarmodule::SolarControlScheduleFSCH* mutable_solarcontrolschedulefsch();
  void set_allocated_solarcontrolschedulefsch(::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarControlFSCC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlFSCC* controlfscc_;
  ::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarControl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControl) */ {
 public:
  SolarControl();
  virtual ~SolarControl();

  SolarControl(const SolarControl& from);

  inline SolarControl& operator=(const SolarControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarControl(SolarControl&& from) noexcept
    : SolarControl() {
    *this = ::std::move(from);
  }

  inline SolarControl& operator=(SolarControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarControl* internal_default_instance() {
    return reinterpret_cast<const SolarControl*>(
               &_SolarControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SolarControl* other);
  friend void swap(SolarControl& a, SolarControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarControl* New() const final {
    return CreateMaybeMessage<SolarControl>(nullptr);
  }

  SolarControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarControl& from);
  void MergeFrom(const SolarControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue();
  static const int kControlValueFieldNumber = 1;
  const ::commonmodule::ControlValue& controlvalue() const;
  ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);

  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 2;
  const ::commonmodule::CheckConditions& check() const;
  ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);

  // .solarmodule.SolarControlFSCC solarControlFSCC = 3;
  bool has_solarcontrolfscc() const;
  void clear_solarcontrolfscc();
  static const int kSolarControlFSCCFieldNumber = 3;
  const ::solarmodule::SolarControlFSCC& solarcontrolfscc() const;
  ::solarmodule::SolarControlFSCC* release_solarcontrolfscc();
  ::solarmodule::SolarControlFSCC* mutable_solarcontrolfscc();
  void set_allocated_solarcontrolfscc(::solarmodule::SolarControlFSCC* solarcontrolfscc);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlValue* controlvalue_;
  ::commonmodule::CheckConditions* check_;
  ::solarmodule::SolarControlFSCC* solarcontrolfscc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarInverter :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarInverter) */ {
 public:
  SolarInverter();
  virtual ~SolarInverter();

  SolarInverter(const SolarInverter& from);

  inline SolarInverter& operator=(const SolarInverter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarInverter(SolarInverter&& from) noexcept
    : SolarInverter() {
    *this = ::std::move(from);
  }

  inline SolarInverter& operator=(SolarInverter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarInverter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarInverter* internal_default_instance() {
    return reinterpret_cast<const SolarInverter*>(
               &_SolarInverter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SolarInverter* other);
  friend void swap(SolarInverter& a, SolarInverter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarInverter* New() const final {
    return CreateMaybeMessage<SolarInverter>(nullptr);
  }

  SolarInverter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarInverter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarInverter& from);
  void MergeFrom(const SolarInverter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarInverter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment();
  static const int kConductingEquipmentFieldNumber = 1;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarInverter)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipment* conductingequipment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarControlProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControlProfile) */ {
 public:
  SolarControlProfile();
  virtual ~SolarControlProfile();

  SolarControlProfile(const SolarControlProfile& from);

  inline SolarControlProfile& operator=(const SolarControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarControlProfile(SolarControlProfile&& from) noexcept
    : SolarControlProfile() {
    *this = ::std::move(from);
  }

  inline SolarControlProfile& operator=(SolarControlProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarControlProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarControlProfile* internal_default_instance() {
    return reinterpret_cast<const SolarControlProfile*>(
               &_SolarControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SolarControlProfile* other);
  friend void swap(SolarControlProfile& a, SolarControlProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarControlProfile* New() const final {
    return CreateMaybeMessage<SolarControlProfile>(nullptr);
  }

  SolarControlProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarControlProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarControlProfile& from);
  void MergeFrom(const SolarControlProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControlProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo();
  static const int kControlMessageInfoFieldNumber = 1;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .solarmodule.SolarControl solarControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarcontrol() const;
  void clear_solarcontrol();
  static const int kSolarControlFieldNumber = 3;
  const ::solarmodule::SolarControl& solarcontrol() const;
  ::solarmodule::SolarControl* release_solarcontrol();
  ::solarmodule::SolarControl* mutable_solarcontrol();
  void set_allocated_solarcontrol(::solarmodule::SolarControl* solarcontrol);

  // .solarmodule.SolarInverter solarInverter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  void clear_solarinverter();
  static const int kSolarInverterFieldNumber = 4;
  const ::solarmodule::SolarInverter& solarinverter() const;
  ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarControlProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlMessageInfo* controlmessageinfo_;
  ::commonmodule::IED* ied_;
  ::solarmodule::SolarControl* solarcontrol_;
  ::solarmodule::SolarInverter* solarinverter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarPointStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarPointStatus) */ {
 public:
  SolarPointStatus();
  virtual ~SolarPointStatus();

  SolarPointStatus(const SolarPointStatus& from);

  inline SolarPointStatus& operator=(const SolarPointStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarPointStatus(SolarPointStatus&& from) noexcept
    : SolarPointStatus() {
    *this = ::std::move(from);
  }

  inline SolarPointStatus& operator=(SolarPointStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarPointStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarPointStatus* internal_default_instance() {
    return reinterpret_cast<const SolarPointStatus*>(
               &_SolarPointStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SolarPointStatus* other);
  friend void swap(SolarPointStatus& a, SolarPointStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarPointStatus* New() const final {
    return CreateMaybeMessage<SolarPointStatus>(nullptr);
  }

  SolarPointStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarPointStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarPointStatus& from);
  void MergeFrom(const SolarPointStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarPointStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlDPC frequencySetPointEnabled = 1;
  bool has_frequencysetpointenabled() const;
  void clear_frequencysetpointenabled();
  static const int kFrequencySetPointEnabledFieldNumber = 1;
  const ::commonmodule::ControlDPC& frequencysetpointenabled() const;
  ::commonmodule::ControlDPC* release_frequencysetpointenabled();
  ::commonmodule::ControlDPC* mutable_frequencysetpointenabled();
  void set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled);

  // .commonmodule.ENG_GridConnectModeKind mode = 2;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);

  // .google.protobuf.FloatValue pctHzDroop = 3;
  bool has_pcthzdroop() const;
  void clear_pcthzdroop();
  static const int kPctHzDroopFieldNumber = 3;
  const ::google::protobuf::FloatValue& pcthzdroop() const;
  ::google::protobuf::FloatValue* release_pcthzdroop();
  ::google::protobuf::FloatValue* mutable_pcthzdroop();
  void set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop);

  // .google.protobuf.FloatValue pctVDroop = 4;
  bool has_pctvdroop() const;
  void clear_pctvdroop();
  static const int kPctVDroopFieldNumber = 4;
  const ::google::protobuf::FloatValue& pctvdroop() const;
  ::google::protobuf::FloatValue* release_pctvdroop();
  ::google::protobuf::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop);

  // .commonmodule.RampRate rampRates = 5;
  bool has_ramprates() const;
  void clear_ramprates();
  static const int kRampRatesFieldNumber = 5;
  const ::commonmodule::RampRate& ramprates() const;
  ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);

  // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;
  bool has_reactivepwrsetpointenabled() const;
  void clear_reactivepwrsetpointenabled();
  static const int kReactivePwrSetPointEnabledFieldNumber = 6;
  const ::commonmodule::ControlDPC& reactivepwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_reactivepwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled);

  // .commonmodule.ControlDPC realPwrSetPointEnabled = 7;
  bool has_realpwrsetpointenabled() const;
  void clear_realpwrsetpointenabled();
  static const int kRealPwrSetPointEnabledFieldNumber = 7;
  const ::commonmodule::ControlDPC& realpwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_realpwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled);

  // .commonmodule.Optional_StateKind state = 8;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 8;
  const ::commonmodule::Optional_StateKind& state() const;
  ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);

  // .commonmodule.ControlDPC voltageSetPointEnabled = 9;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled();
  static const int kVoltageSetPointEnabledFieldNumber = 9;
  const ::commonmodule::ControlDPC& voltagesetpointenabled() const;
  ::commonmodule::ControlDPC* release_voltagesetpointenabled();
  ::commonmodule::ControlDPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarPointStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlDPC* frequencysetpointenabled_;
  ::commonmodule::ENG_GridConnectModeKind* mode_;
  ::google::protobuf::FloatValue* pcthzdroop_;
  ::google::protobuf::FloatValue* pctvdroop_;
  ::commonmodule::RampRate* ramprates_;
  ::commonmodule::ControlDPC* reactivepwrsetpointenabled_;
  ::commonmodule::ControlDPC* realpwrsetpointenabled_;
  ::commonmodule::Optional_StateKind* state_;
  ::commonmodule::ControlDPC* voltagesetpointenabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarEventAndStatusZGEN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEventAndStatusZGEN) */ {
 public:
  SolarEventAndStatusZGEN();
  virtual ~SolarEventAndStatusZGEN();

  SolarEventAndStatusZGEN(const SolarEventAndStatusZGEN& from);

  inline SolarEventAndStatusZGEN& operator=(const SolarEventAndStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarEventAndStatusZGEN(SolarEventAndStatusZGEN&& from) noexcept
    : SolarEventAndStatusZGEN() {
    *this = ::std::move(from);
  }

  inline SolarEventAndStatusZGEN& operator=(SolarEventAndStatusZGEN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarEventAndStatusZGEN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarEventAndStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const SolarEventAndStatusZGEN*>(
               &_SolarEventAndStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SolarEventAndStatusZGEN* other);
  friend void swap(SolarEventAndStatusZGEN& a, SolarEventAndStatusZGEN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarEventAndStatusZGEN* New() const final {
    return CreateMaybeMessage<SolarEventAndStatusZGEN>(nullptr);
  }

  SolarEventAndStatusZGEN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarEventAndStatusZGEN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarEventAndStatusZGEN& from);
  void MergeFrom(const SolarEventAndStatusZGEN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEventAndStatusZGEN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.StatusSPS AuxPwrSt = 2;
  bool has_auxpwrst() const;
  void clear_auxpwrst();
  static const int kAuxPwrStFieldNumber = 2;
  const ::commonmodule::StatusSPS& auxpwrst() const;
  ::commonmodule::StatusSPS* release_auxpwrst();
  ::commonmodule::StatusSPS* mutable_auxpwrst();
  void set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst);

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
  bool has_dynamictest() const;
  void clear_dynamictest();
  static const int kDynamicTestFieldNumber = 3;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);

  // .commonmodule.StatusSPS EmgStop = 4;
  bool has_emgstop() const;
  void clear_emgstop();
  static const int kEmgStopFieldNumber = 4;
  const ::commonmodule::StatusSPS& emgstop() const;
  ::commonmodule::StatusSPS* release_emgstop();
  ::commonmodule::StatusSPS* mutable_emgstop();
  void set_allocated_emgstop(::commonmodule::StatusSPS* emgstop);

  // .solarmodule.SolarPointStatus PointStatus = 5;
  bool has_pointstatus() const;
  void clear_pointstatus();
  static const int kPointStatusFieldNumber = 5;
  const ::solarmodule::SolarPointStatus& pointstatus() const;
  ::solarmodule::SolarPointStatus* release_pointstatus();
  ::solarmodule::SolarPointStatus* mutable_pointstatus();
  void set_allocated_pointstatus(::solarmodule::SolarPointStatus* pointstatus);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarEventAndStatusZGEN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::StatusSPS* auxpwrst_;
  ::commonmodule::ENS_DynamicTestKind* dynamictest_;
  ::commonmodule::StatusSPS* emgstop_;
  ::solarmodule::SolarPointStatus* pointstatus_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarEventZGEN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEventZGEN) */ {
 public:
  SolarEventZGEN();
  virtual ~SolarEventZGEN();

  SolarEventZGEN(const SolarEventZGEN& from);

  inline SolarEventZGEN& operator=(const SolarEventZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarEventZGEN(SolarEventZGEN&& from) noexcept
    : SolarEventZGEN() {
    *this = ::std::move(from);
  }

  inline SolarEventZGEN& operator=(SolarEventZGEN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarEventZGEN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarEventZGEN* internal_default_instance() {
    return reinterpret_cast<const SolarEventZGEN*>(
               &_SolarEventZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SolarEventZGEN* other);
  friend void swap(SolarEventZGEN& a, SolarEventZGEN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarEventZGEN* New() const final {
    return CreateMaybeMessage<SolarEventZGEN>(nullptr);
  }

  SolarEventZGEN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarEventZGEN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarEventZGEN& from);
  void MergeFrom(const SolarEventZGEN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEventZGEN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_solareventandstatuszgen() const;
  void clear_solareventandstatuszgen();
  static const int kSolarEventAndStatusZGENFieldNumber = 1;
  const ::solarmodule::SolarEventAndStatusZGEN& solareventandstatuszgen() const;
  ::solarmodule::SolarEventAndStatusZGEN* release_solareventandstatuszgen();
  ::solarmodule::SolarEventAndStatusZGEN* mutable_solareventandstatuszgen();
  void set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen);

  // .commonmodule.ENG_GridConnectModeKind GriMod = 2;
  bool has_grimod() const;
  void clear_grimod();
  static const int kGriModFieldNumber = 2;
  const ::commonmodule::ENG_GridConnectModeKind& grimod() const;
  ::commonmodule::ENG_GridConnectModeKind* release_grimod();
  ::commonmodule::ENG_GridConnectModeKind* mutable_grimod();
  void set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarEventZGEN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen_;
  ::commonmodule::ENG_GridConnectModeKind* grimod_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEvent) */ {
 public:
  SolarEvent();
  virtual ~SolarEvent();

  SolarEvent(const SolarEvent& from);

  inline SolarEvent& operator=(const SolarEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarEvent(SolarEvent&& from) noexcept
    : SolarEvent() {
    *this = ::std::move(from);
  }

  inline SolarEvent& operator=(SolarEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarEvent* internal_default_instance() {
    return reinterpret_cast<const SolarEvent*>(
               &_SolarEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SolarEvent* other);
  friend void swap(SolarEvent& a, SolarEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarEvent* New() const final {
    return CreateMaybeMessage<SolarEvent>(nullptr);
  }

  SolarEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarEvent& from);
  void MergeFrom(const SolarEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  void clear_eventvalue();
  static const int kEventValueFieldNumber = 1;
  const ::commonmodule::EventValue& eventvalue() const;
  ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);

  // .solarmodule.SolarEventZGEN solarEventZGEN = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solareventzgen() const;
  void clear_solareventzgen();
  static const int kSolarEventZGENFieldNumber = 2;
  const ::solarmodule::SolarEventZGEN& solareventzgen() const;
  ::solarmodule::SolarEventZGEN* release_solareventzgen();
  ::solarmodule::SolarEventZGEN* mutable_solareventzgen();
  void set_allocated_solareventzgen(::solarmodule::SolarEventZGEN* solareventzgen);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventValue* eventvalue_;
  ::solarmodule::SolarEventZGEN* solareventzgen_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarEventProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEventProfile) */ {
 public:
  SolarEventProfile();
  virtual ~SolarEventProfile();

  SolarEventProfile(const SolarEventProfile& from);

  inline SolarEventProfile& operator=(const SolarEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarEventProfile(SolarEventProfile&& from) noexcept
    : SolarEventProfile() {
    *this = ::std::move(from);
  }

  inline SolarEventProfile& operator=(SolarEventProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarEventProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarEventProfile* internal_default_instance() {
    return reinterpret_cast<const SolarEventProfile*>(
               &_SolarEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SolarEventProfile* other);
  friend void swap(SolarEventProfile& a, SolarEventProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarEventProfile* New() const final {
    return CreateMaybeMessage<SolarEventProfile>(nullptr);
  }

  SolarEventProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarEventProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarEventProfile& from);
  void MergeFrom(const SolarEventProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEventProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  void clear_eventmessageinfo();
  static const int kEventMessageInfoFieldNumber = 1;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .solarmodule.SolarEvent solarEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarevent() const;
  void clear_solarevent();
  static const int kSolarEventFieldNumber = 3;
  const ::solarmodule::SolarEvent& solarevent() const;
  ::solarmodule::SolarEvent* release_solarevent();
  ::solarmodule::SolarEvent* mutable_solarevent();
  void set_allocated_solarevent(::solarmodule::SolarEvent* solarevent);

  // .solarmodule.SolarInverter solarInverter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  void clear_solarinverter();
  static const int kSolarInverterFieldNumber = 4;
  const ::solarmodule::SolarInverter& solarinverter() const;
  ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarEventProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventMessageInfo* eventmessageinfo_;
  ::commonmodule::IED* ied_;
  ::solarmodule::SolarEvent* solarevent_;
  ::solarmodule::SolarInverter* solarinverter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarReading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarReading) */ {
 public:
  SolarReading();
  virtual ~SolarReading();

  SolarReading(const SolarReading& from);

  inline SolarReading& operator=(const SolarReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarReading(SolarReading&& from) noexcept
    : SolarReading() {
    *this = ::std::move(from);
  }

  inline SolarReading& operator=(SolarReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarReading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarReading* internal_default_instance() {
    return reinterpret_cast<const SolarReading*>(
               &_SolarReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SolarReading* other);
  friend void swap(SolarReading& a, SolarReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarReading* New() const final {
    return CreateMaybeMessage<SolarReading>(nullptr);
  }

  SolarReading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarReading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarReading& from);
  void MergeFrom(const SolarReading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  void clear_conductingequipmentterminalreading();
  static const int kConductingEquipmentTerminalReadingFieldNumber = 1;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);

  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  void clear_phasemmtn();
  static const int kPhaseMMTNFieldNumber = 2;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);

  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  void clear_readingmmtr();
  static const int kReadingMMTRFieldNumber = 3;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);

  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  void clear_readingmmxu();
  static const int kReadingMMXUFieldNumber = 4;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarReading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
  ::commonmodule::PhaseMMTN* phasemmtn_;
  ::commonmodule::ReadingMMTR* readingmmtr_;
  ::commonmodule::ReadingMMXU* readingmmxu_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarReadingProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarReadingProfile) */ {
 public:
  SolarReadingProfile();
  virtual ~SolarReadingProfile();

  SolarReadingProfile(const SolarReadingProfile& from);

  inline SolarReadingProfile& operator=(const SolarReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarReadingProfile(SolarReadingProfile&& from) noexcept
    : SolarReadingProfile() {
    *this = ::std::move(from);
  }

  inline SolarReadingProfile& operator=(SolarReadingProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarReadingProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarReadingProfile* internal_default_instance() {
    return reinterpret_cast<const SolarReadingProfile*>(
               &_SolarReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(SolarReadingProfile* other);
  friend void swap(SolarReadingProfile& a, SolarReadingProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarReadingProfile* New() const final {
    return CreateMaybeMessage<SolarReadingProfile>(nullptr);
  }

  SolarReadingProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarReadingProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarReadingProfile& from);
  void MergeFrom(const SolarReadingProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarReadingProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  void clear_readingmessageinfo();
  static const int kReadingMessageInfoFieldNumber = 1;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  void clear_solarinverter();
  static const int kSolarInverterFieldNumber = 3;
  const ::solarmodule::SolarInverter& solarinverter() const;
  ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);

  // .solarmodule.SolarReading solarReading = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarreading() const;
  void clear_solarreading();
  static const int kSolarReadingFieldNumber = 4;
  const ::solarmodule::SolarReading& solarreading() const;
  ::solarmodule::SolarReading* release_solarreading();
  ::solarmodule::SolarReading* mutable_solarreading();
  void set_allocated_solarreading(::solarmodule::SolarReading* solarreading);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarReadingProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
  ::commonmodule::IED* ied_;
  ::solarmodule::SolarInverter* solarinverter_;
  ::solarmodule::SolarReading* solarreading_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarStatusZGEN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarStatusZGEN) */ {
 public:
  SolarStatusZGEN();
  virtual ~SolarStatusZGEN();

  SolarStatusZGEN(const SolarStatusZGEN& from);

  inline SolarStatusZGEN& operator=(const SolarStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarStatusZGEN(SolarStatusZGEN&& from) noexcept
    : SolarStatusZGEN() {
    *this = ::std::move(from);
  }

  inline SolarStatusZGEN& operator=(SolarStatusZGEN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarStatusZGEN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const SolarStatusZGEN*>(
               &_SolarStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(SolarStatusZGEN* other);
  friend void swap(SolarStatusZGEN& a, SolarStatusZGEN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarStatusZGEN* New() const final {
    return CreateMaybeMessage<SolarStatusZGEN>(nullptr);
  }

  SolarStatusZGEN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarStatusZGEN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarStatusZGEN& from);
  void MergeFrom(const SolarStatusZGEN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarStatusZGEN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_solareventandstatuszgen() const;
  void clear_solareventandstatuszgen();
  static const int kSolarEventAndStatusZGENFieldNumber = 1;
  const ::solarmodule::SolarEventAndStatusZGEN& solareventandstatuszgen() const;
  ::solarmodule::SolarEventAndStatusZGEN* release_solareventandstatuszgen();
  ::solarmodule::SolarEventAndStatusZGEN* mutable_solareventandstatuszgen();
  void set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen);

  // .commonmodule.ENG_GridConnectModeKind GriMod = 2;
  bool has_grimod() const;
  void clear_grimod();
  static const int kGriModFieldNumber = 2;
  const ::commonmodule::ENG_GridConnectModeKind& grimod() const;
  ::commonmodule::ENG_GridConnectModeKind* release_grimod();
  ::commonmodule::ENG_GridConnectModeKind* mutable_grimod();
  void set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarStatusZGEN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen_;
  ::commonmodule::ENG_GridConnectModeKind* grimod_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarStatus) */ {
 public:
  SolarStatus();
  virtual ~SolarStatus();

  SolarStatus(const SolarStatus& from);

  inline SolarStatus& operator=(const SolarStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarStatus(SolarStatus&& from) noexcept
    : SolarStatus() {
    *this = ::std::move(from);
  }

  inline SolarStatus& operator=(SolarStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarStatus* internal_default_instance() {
    return reinterpret_cast<const SolarStatus*>(
               &_SolarStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SolarStatus* other);
  friend void swap(SolarStatus& a, SolarStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarStatus* New() const final {
    return CreateMaybeMessage<SolarStatus>(nullptr);
  }

  SolarStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarStatus& from);
  void MergeFrom(const SolarStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  void clear_statusvalue();
  static const int kStatusValueFieldNumber = 1;
  const ::commonmodule::StatusValue& statusvalue() const;
  ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);

  // .solarmodule.SolarStatusZGEN solarStatusZGEN = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarstatuszgen() const;
  void clear_solarstatuszgen();
  static const int kSolarStatusZGENFieldNumber = 2;
  const ::solarmodule::SolarStatusZGEN& solarstatuszgen() const;
  ::solarmodule::SolarStatusZGEN* release_solarstatuszgen();
  ::solarmodule::SolarStatusZGEN* mutable_solarstatuszgen();
  void set_allocated_solarstatuszgen(::solarmodule::SolarStatusZGEN* solarstatuszgen);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusValue* statusvalue_;
  ::solarmodule::SolarStatusZGEN* solarstatuszgen_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// -------------------------------------------------------------------

class SolarStatusProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarStatusProfile) */ {
 public:
  SolarStatusProfile();
  virtual ~SolarStatusProfile();

  SolarStatusProfile(const SolarStatusProfile& from);

  inline SolarStatusProfile& operator=(const SolarStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolarStatusProfile(SolarStatusProfile&& from) noexcept
    : SolarStatusProfile() {
    *this = ::std::move(from);
  }

  inline SolarStatusProfile& operator=(SolarStatusProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SolarStatusProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolarStatusProfile* internal_default_instance() {
    return reinterpret_cast<const SolarStatusProfile*>(
               &_SolarStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SolarStatusProfile* other);
  friend void swap(SolarStatusProfile& a, SolarStatusProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolarStatusProfile* New() const final {
    return CreateMaybeMessage<SolarStatusProfile>(nullptr);
  }

  SolarStatusProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SolarStatusProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SolarStatusProfile& from);
  void MergeFrom(const SolarStatusProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarStatusProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  void clear_statusmessageinfo();
  static const int kStatusMessageInfoFieldNumber = 1;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  void clear_solarinverter();
  static const int kSolarInverterFieldNumber = 3;
  const ::solarmodule::SolarInverter& solarinverter() const;
  ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);

  // .solarmodule.SolarStatus solarStatus = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarstatus() const;
  void clear_solarstatus();
  static const int kSolarStatusFieldNumber = 4;
  const ::solarmodule::SolarStatus& solarstatus() const;
  ::solarmodule::SolarStatus* release_solarstatus();
  ::solarmodule::SolarStatus* mutable_solarstatus();
  void set_allocated_solarstatus(::solarmodule::SolarStatus* solarstatus);

  // @@protoc_insertion_point(class_scope:solarmodule.SolarStatusProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusMessageInfo* statusmessageinfo_;
  ::commonmodule::IED* ied_;
  ::solarmodule::SolarInverter* solarinverter_;
  ::solarmodule::SolarStatus* solarstatus_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SolarPoint

// .commonmodule.ControlDPC frequencySetPointEnabled = 1;
inline bool SolarPoint::has_frequencysetpointenabled() const {
  return this != internal_default_instance() && frequencysetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPoint::frequencysetpointenabled() const {
  const ::commonmodule::ControlDPC* p = frequencysetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.frequencySetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPoint::release_frequencysetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.frequencySetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = frequencysetpointenabled_;
  frequencysetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPoint::mutable_frequencysetpointenabled() {
  
  if (frequencysetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    frequencysetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.frequencySetPointEnabled)
  return frequencysetpointenabled_;
}
inline void SolarPoint::set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencysetpointenabled_);
  }
  if (frequencysetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      frequencysetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencysetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.frequencySetPointEnabled)
}

// .commonmodule.ENG_GridConnectModeKind mode = 2;
inline bool SolarPoint::has_mode() const {
  return this != internal_default_instance() && mode_ != nullptr;
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarPoint::mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = mode_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.mode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind*>(
      &::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPoint::release_mode() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = mode_;
  mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPoint::mutable_mode() {
  
  if (mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaNoVirtual());
    mode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.mode)
  return mode_;
}
inline void SolarPoint::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mode_);
  }
  if (mode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }
    
  } else {
    
  }
  mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.mode)
}

// .google.protobuf.FloatValue pctHzDroop = 3;
inline bool SolarPoint::has_pcthzdroop() const {
  return this != internal_default_instance() && pcthzdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SolarPoint::pcthzdroop() const {
  const ::google::protobuf::FloatValue* p = pcthzdroop_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.pctHzDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SolarPoint::release_pcthzdroop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.pctHzDroop)
  
  ::google::protobuf::FloatValue* temp = pcthzdroop_;
  pcthzdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SolarPoint::mutable_pcthzdroop() {
  
  if (pcthzdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pcthzdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.pctHzDroop)
  return pcthzdroop_;
}
inline void SolarPoint::set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pcthzdroop_);
  }
  if (pcthzdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pcthzdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pcthzdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pcthzdroop, submessage_arena);
    }
    
  } else {
    
  }
  pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.pctHzDroop)
}

// .google.protobuf.FloatValue pctVDroop = 4;
inline bool SolarPoint::has_pctvdroop() const {
  return this != internal_default_instance() && pctvdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SolarPoint::pctvdroop() const {
  const ::google::protobuf::FloatValue* p = pctvdroop_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.pctVDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SolarPoint::release_pctvdroop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.pctVDroop)
  
  ::google::protobuf::FloatValue* temp = pctvdroop_;
  pctvdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SolarPoint::mutable_pctvdroop() {
  
  if (pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pctvdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.pctVDroop)
  return pctvdroop_;
}
inline void SolarPoint::set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pctvdroop_);
  }
  if (pctvdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pctvdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pctvdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }
    
  } else {
    
  }
  pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.pctVDroop)
}

// .commonmodule.RampRate rampRates = 5;
inline bool SolarPoint::has_ramprates() const {
  return this != internal_default_instance() && ramprates_ != nullptr;
}
inline const ::commonmodule::RampRate& SolarPoint::ramprates() const {
  const ::commonmodule::RampRate* p = ramprates_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.rampRates)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::RampRate*>(
      &::commonmodule::_RampRate_default_instance_);
}
inline ::commonmodule::RampRate* SolarPoint::release_ramprates() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.rampRates)
  
  ::commonmodule::RampRate* temp = ramprates_;
  ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* SolarPoint::mutable_ramprates() {
  
  if (ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaNoVirtual());
    ramprates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.rampRates)
  return ramprates_;
}
inline void SolarPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ramprates_);
  }
  if (ramprates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ramprates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }
    
  } else {
    
  }
  ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.rampRates)
}

// .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;
inline bool SolarPoint::has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && reactivepwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPoint::reactivepwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = reactivepwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.reactivePwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPoint::release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.reactivePwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = reactivepwrsetpointenabled_;
  reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPoint::mutable_reactivepwrsetpointenabled() {
  
  if (reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reactivepwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.reactivePwrSetPointEnabled)
  return reactivepwrsetpointenabled_;
}
inline void SolarPoint::set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.reactivePwrSetPointEnabled)
}

// .commonmodule.ControlDPC realPwrSetPointEnabled = 7;
inline bool SolarPoint::has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && realpwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPoint::realpwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = realpwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.realPwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPoint::release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.realPwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = realpwrsetpointenabled_;
  realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPoint::mutable_realpwrsetpointenabled() {
  
  if (realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    realpwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.realPwrSetPointEnabled)
  return realpwrsetpointenabled_;
}
inline void SolarPoint::set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.realPwrSetPointEnabled)
}

// .commonmodule.ControlDPC reset = 8;
inline bool SolarPoint::has_reset() const {
  return this != internal_default_instance() && reset_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPoint::reset() const {
  const ::commonmodule::ControlDPC* p = reset_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.reset)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPoint::release_reset() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.reset)
  
  ::commonmodule::ControlDPC* temp = reset_;
  reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPoint::mutable_reset() {
  
  if (reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.reset)
  return reset_;
}
inline void SolarPoint::set_allocated_reset(::commonmodule::ControlDPC* reset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reset_);
  }
  if (reset) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }
    
  } else {
    
  }
  reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.reset)
}

// .commonmodule.Optional_StateKind state = 9;
inline bool SolarPoint::has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline const ::commonmodule::Optional_StateKind& SolarPoint::state() const {
  const ::commonmodule::Optional_StateKind* p = state_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.state)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_StateKind*>(
      &::commonmodule::_Optional_StateKind_default_instance_);
}
inline ::commonmodule::Optional_StateKind* SolarPoint::release_state() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.state)
  
  ::commonmodule::Optional_StateKind* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* SolarPoint::mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.state)
  return state_;
}
inline void SolarPoint::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.state)
}

// .commonmodule.ControlDPC voltageSetPointEnabled = 10;
inline bool SolarPoint::has_voltagesetpointenabled() const {
  return this != internal_default_instance() && voltagesetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPoint::voltagesetpointenabled() const {
  const ::commonmodule::ControlDPC* p = voltagesetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.voltageSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPoint::release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.voltageSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = voltagesetpointenabled_;
  voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPoint::mutable_voltagesetpointenabled() {
  
  if (voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    voltagesetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.voltageSetPointEnabled)
  return voltagesetpointenabled_;
}
inline void SolarPoint::set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.voltageSetPointEnabled)
}

// .commonmodule.ControlTimestamp startTime = 11 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarPoint::has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline const ::commonmodule::ControlTimestamp& SolarPoint::starttime() const {
  const ::commonmodule::ControlTimestamp* p = starttime_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.startTime)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlTimestamp*>(
      &::commonmodule::_ControlTimestamp_default_instance_);
}
inline ::commonmodule::ControlTimestamp* SolarPoint::release_starttime() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* SolarPoint::mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaNoVirtual());
    starttime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.startTime)
  return starttime_;
}
inline void SolarPoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starttime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.startTime)
}

// -------------------------------------------------------------------

// SolarCSG

// repeated .solarmodule.SolarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int SolarCSG::crvpts_size() const {
  return crvpts_.size();
}
inline void SolarCSG::clear_crvpts() {
  crvpts_.Clear();
}
inline ::solarmodule::SolarPoint* SolarCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCSG.crvPts)
  return crvpts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::solarmodule::SolarPoint >*
SolarCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:solarmodule.SolarCSG.crvPts)
  return &crvpts_;
}
inline const ::solarmodule::SolarPoint& SolarCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCSG.crvPts)
  return crvpts_.Get(index);
}
inline ::solarmodule::SolarPoint* SolarCSG::add_crvpts() {
  // @@protoc_insertion_point(field_add:solarmodule.SolarCSG.crvPts)
  return crvpts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::solarmodule::SolarPoint >&
SolarCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:solarmodule.SolarCSG.crvPts)
  return crvpts_;
}

// -------------------------------------------------------------------

// SolarControlScheduleFSCH

// .solarmodule.SolarCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarControlScheduleFSCH::has_valdcsg() const {
  return this != internal_default_instance() && valdcsg_ != nullptr;
}
inline void SolarControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaNoVirtual() == nullptr && valdcsg_ != nullptr) {
    delete valdcsg_;
  }
  valdcsg_ = nullptr;
}
inline const ::solarmodule::SolarCSG& SolarControlScheduleFSCH::valdcsg() const {
  const ::solarmodule::SolarCSG* p = valdcsg_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlScheduleFSCH.ValDCSG)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarCSG*>(
      &::solarmodule::_SolarCSG_default_instance_);
}
inline ::solarmodule::SolarCSG* SolarControlScheduleFSCH::release_valdcsg() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlScheduleFSCH.ValDCSG)
  
  ::solarmodule::SolarCSG* temp = valdcsg_;
  valdcsg_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarCSG* SolarControlScheduleFSCH::mutable_valdcsg() {
  
  if (valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarCSG>(GetArenaNoVirtual());
    valdcsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlScheduleFSCH.ValDCSG)
  return valdcsg_;
}
inline void SolarControlScheduleFSCH::set_allocated_valdcsg(::solarmodule::SolarCSG* valdcsg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete valdcsg_;
  }
  if (valdcsg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      valdcsg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }
    
  } else {
    
  }
  valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// SolarControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool SolarControlFSCC::has_controlfscc() const {
  return this != internal_default_instance() && controlfscc_ != nullptr;
}
inline const ::commonmodule::ControlFSCC& SolarControlFSCC::controlfscc() const {
  const ::commonmodule::ControlFSCC* p = controlfscc_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlFSCC.controlFSCC)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlFSCC*>(
      &::commonmodule::_ControlFSCC_default_instance_);
}
inline ::commonmodule::ControlFSCC* SolarControlFSCC::release_controlfscc() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = controlfscc_;
  controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* SolarControlFSCC::mutable_controlfscc() {
  
  if (controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaNoVirtual());
    controlfscc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlFSCC.controlFSCC)
  return controlfscc_;
}
inline void SolarControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlfscc_);
  }
  if (controlfscc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlfscc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }
    
  } else {
    
  }
  controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlFSCC.controlFSCC)
}

// .solarmodule.SolarControlScheduleFSCH SolarControlScheduleFSCH = 2;
inline bool SolarControlFSCC::has_solarcontrolschedulefsch() const {
  return this != internal_default_instance() && solarcontrolschedulefsch_ != nullptr;
}
inline void SolarControlFSCC::clear_solarcontrolschedulefsch() {
  if (GetArenaNoVirtual() == nullptr && solarcontrolschedulefsch_ != nullptr) {
    delete solarcontrolschedulefsch_;
  }
  solarcontrolschedulefsch_ = nullptr;
}
inline const ::solarmodule::SolarControlScheduleFSCH& SolarControlFSCC::solarcontrolschedulefsch() const {
  const ::solarmodule::SolarControlScheduleFSCH* p = solarcontrolschedulefsch_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarControlScheduleFSCH*>(
      &::solarmodule::_SolarControlScheduleFSCH_default_instance_);
}
inline ::solarmodule::SolarControlScheduleFSCH* SolarControlFSCC::release_solarcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
  
  ::solarmodule::SolarControlScheduleFSCH* temp = solarcontrolschedulefsch_;
  solarcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarControlScheduleFSCH* SolarControlFSCC::mutable_solarcontrolschedulefsch() {
  
  if (solarcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarControlScheduleFSCH>(GetArenaNoVirtual());
    solarcontrolschedulefsch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
  return solarcontrolschedulefsch_;
}
inline void SolarControlFSCC::set_allocated_solarcontrolschedulefsch(::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarcontrolschedulefsch_;
  }
  if (solarcontrolschedulefsch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarcontrolschedulefsch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarcontrolschedulefsch, submessage_arena);
    }
    
  } else {
    
  }
  solarcontrolschedulefsch_ = solarcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
}

// -------------------------------------------------------------------

// SolarControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarControl::has_controlvalue() const {
  return this != internal_default_instance() && controlvalue_ != nullptr;
}
inline const ::commonmodule::ControlValue& SolarControl::controlvalue() const {
  const ::commonmodule::ControlValue* p = controlvalue_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControl.controlValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlValue*>(
      &::commonmodule::_ControlValue_default_instance_);
}
inline ::commonmodule::ControlValue* SolarControl::release_controlvalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControl.controlValue)
  
  ::commonmodule::ControlValue* temp = controlvalue_;
  controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* SolarControl::mutable_controlvalue() {
  
  if (controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaNoVirtual());
    controlvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControl.controlValue)
  return controlvalue_;
}
inline void SolarControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlvalue_);
  }
  if (controlvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }
    
  } else {
    
  }
  controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool SolarControl::has_check() const {
  return this != internal_default_instance() && check_ != nullptr;
}
inline const ::commonmodule::CheckConditions& SolarControl::check() const {
  const ::commonmodule::CheckConditions* p = check_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControl.check)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CheckConditions*>(
      &::commonmodule::_CheckConditions_default_instance_);
}
inline ::commonmodule::CheckConditions* SolarControl::release_check() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControl.check)
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* SolarControl::mutable_check() {
  
  if (check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaNoVirtual());
    check_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControl.check)
  return check_;
}
inline void SolarControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(check_);
  }
  if (check) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControl.check)
}

// .solarmodule.SolarControlFSCC solarControlFSCC = 3;
inline bool SolarControl::has_solarcontrolfscc() const {
  return this != internal_default_instance() && solarcontrolfscc_ != nullptr;
}
inline void SolarControl::clear_solarcontrolfscc() {
  if (GetArenaNoVirtual() == nullptr && solarcontrolfscc_ != nullptr) {
    delete solarcontrolfscc_;
  }
  solarcontrolfscc_ = nullptr;
}
inline const ::solarmodule::SolarControlFSCC& SolarControl::solarcontrolfscc() const {
  const ::solarmodule::SolarControlFSCC* p = solarcontrolfscc_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControl.solarControlFSCC)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarControlFSCC*>(
      &::solarmodule::_SolarControlFSCC_default_instance_);
}
inline ::solarmodule::SolarControlFSCC* SolarControl::release_solarcontrolfscc() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControl.solarControlFSCC)
  
  ::solarmodule::SolarControlFSCC* temp = solarcontrolfscc_;
  solarcontrolfscc_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarControlFSCC* SolarControl::mutable_solarcontrolfscc() {
  
  if (solarcontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarControlFSCC>(GetArenaNoVirtual());
    solarcontrolfscc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControl.solarControlFSCC)
  return solarcontrolfscc_;
}
inline void SolarControl::set_allocated_solarcontrolfscc(::solarmodule::SolarControlFSCC* solarcontrolfscc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarcontrolfscc_;
  }
  if (solarcontrolfscc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarcontrolfscc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarcontrolfscc, submessage_arena);
    }
    
  } else {
    
  }
  solarcontrolfscc_ = solarcontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControl.solarControlFSCC)
}

// -------------------------------------------------------------------

// SolarInverter

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool SolarInverter::has_conductingequipment() const {
  return this != internal_default_instance() && conductingequipment_ != nullptr;
}
inline const ::commonmodule::ConductingEquipment& SolarInverter::conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = conductingequipment_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarInverter.conductingEquipment)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipment*>(
      &::commonmodule::_ConductingEquipment_default_instance_);
}
inline ::commonmodule::ConductingEquipment* SolarInverter::release_conductingequipment() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarInverter.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = conductingequipment_;
  conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* SolarInverter::mutable_conductingequipment() {
  
  if (conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaNoVirtual());
    conductingequipment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarInverter.conductingEquipment)
  return conductingequipment_;
}
inline void SolarInverter::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipment_);
  }
  if (conductingequipment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarInverter.conductingEquipment)
}

// -------------------------------------------------------------------

// SolarControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarControlProfile::has_controlmessageinfo() const {
  return this != internal_default_instance() && controlmessageinfo_ != nullptr;
}
inline const ::commonmodule::ControlMessageInfo& SolarControlProfile::controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = controlmessageinfo_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlProfile.controlMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlMessageInfo*>(
      &::commonmodule::_ControlMessageInfo_default_instance_);
}
inline ::commonmodule::ControlMessageInfo* SolarControlProfile::release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SolarControlProfile::mutable_controlmessageinfo() {
  
  if (controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaNoVirtual());
    controlmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlProfile.controlMessageInfo)
  return controlmessageinfo_;
}
inline void SolarControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlProfile.controlMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarControlProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SolarControlProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SolarControlProfile::release_ied() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SolarControlProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlProfile.ied)
  return ied_;
}
inline void SolarControlProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlProfile.ied)
}

// .solarmodule.SolarControl solarControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarControlProfile::has_solarcontrol() const {
  return this != internal_default_instance() && solarcontrol_ != nullptr;
}
inline void SolarControlProfile::clear_solarcontrol() {
  if (GetArenaNoVirtual() == nullptr && solarcontrol_ != nullptr) {
    delete solarcontrol_;
  }
  solarcontrol_ = nullptr;
}
inline const ::solarmodule::SolarControl& SolarControlProfile::solarcontrol() const {
  const ::solarmodule::SolarControl* p = solarcontrol_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlProfile.solarControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarControl*>(
      &::solarmodule::_SolarControl_default_instance_);
}
inline ::solarmodule::SolarControl* SolarControlProfile::release_solarcontrol() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlProfile.solarControl)
  
  ::solarmodule::SolarControl* temp = solarcontrol_;
  solarcontrol_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarControl* SolarControlProfile::mutable_solarcontrol() {
  
  if (solarcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarControl>(GetArenaNoVirtual());
    solarcontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlProfile.solarControl)
  return solarcontrol_;
}
inline void SolarControlProfile::set_allocated_solarcontrol(::solarmodule::SolarControl* solarcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarcontrol_;
  }
  if (solarcontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarcontrol, submessage_arena);
    }
    
  } else {
    
  }
  solarcontrol_ = solarcontrol;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlProfile.solarControl)
}

// .solarmodule.SolarInverter solarInverter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarControlProfile::has_solarinverter() const {
  return this != internal_default_instance() && solarinverter_ != nullptr;
}
inline void SolarControlProfile::clear_solarinverter() {
  if (GetArenaNoVirtual() == nullptr && solarinverter_ != nullptr) {
    delete solarinverter_;
  }
  solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarControlProfile::solarinverter() const {
  const ::solarmodule::SolarInverter* p = solarinverter_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlProfile.solarInverter)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarInverter*>(
      &::solarmodule::_SolarInverter_default_instance_);
}
inline ::solarmodule::SolarInverter* SolarControlProfile::release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = solarinverter_;
  solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarControlProfile::mutable_solarinverter() {
  
  if (solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaNoVirtual());
    solarinverter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlProfile.solarInverter)
  return solarinverter_;
}
inline void SolarControlProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarinverter_;
  }
  if (solarinverter) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarinverter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }
    
  } else {
    
  }
  solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlProfile.solarInverter)
}

// -------------------------------------------------------------------

// SolarPointStatus

// .commonmodule.ControlDPC frequencySetPointEnabled = 1;
inline bool SolarPointStatus::has_frequencysetpointenabled() const {
  return this != internal_default_instance() && frequencysetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPointStatus::frequencysetpointenabled() const {
  const ::commonmodule::ControlDPC* p = frequencysetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.frequencySetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPointStatus::release_frequencysetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.frequencySetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = frequencysetpointenabled_;
  frequencysetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPointStatus::mutable_frequencysetpointenabled() {
  
  if (frequencysetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    frequencysetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.frequencySetPointEnabled)
  return frequencysetpointenabled_;
}
inline void SolarPointStatus::set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencysetpointenabled_);
  }
  if (frequencysetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      frequencysetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencysetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.frequencySetPointEnabled)
}

// .commonmodule.ENG_GridConnectModeKind mode = 2;
inline bool SolarPointStatus::has_mode() const {
  return this != internal_default_instance() && mode_ != nullptr;
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarPointStatus::mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = mode_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.mode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind*>(
      &::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPointStatus::release_mode() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = mode_;
  mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPointStatus::mutable_mode() {
  
  if (mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaNoVirtual());
    mode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.mode)
  return mode_;
}
inline void SolarPointStatus::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mode_);
  }
  if (mode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }
    
  } else {
    
  }
  mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.mode)
}

// .google.protobuf.FloatValue pctHzDroop = 3;
inline bool SolarPointStatus::has_pcthzdroop() const {
  return this != internal_default_instance() && pcthzdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SolarPointStatus::pcthzdroop() const {
  const ::google::protobuf::FloatValue* p = pcthzdroop_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.pctHzDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SolarPointStatus::release_pcthzdroop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.pctHzDroop)
  
  ::google::protobuf::FloatValue* temp = pcthzdroop_;
  pcthzdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SolarPointStatus::mutable_pcthzdroop() {
  
  if (pcthzdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pcthzdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.pctHzDroop)
  return pcthzdroop_;
}
inline void SolarPointStatus::set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pcthzdroop_);
  }
  if (pcthzdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pcthzdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pcthzdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pcthzdroop, submessage_arena);
    }
    
  } else {
    
  }
  pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.pctHzDroop)
}

// .google.protobuf.FloatValue pctVDroop = 4;
inline bool SolarPointStatus::has_pctvdroop() const {
  return this != internal_default_instance() && pctvdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SolarPointStatus::pctvdroop() const {
  const ::google::protobuf::FloatValue* p = pctvdroop_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.pctVDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SolarPointStatus::release_pctvdroop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.pctVDroop)
  
  ::google::protobuf::FloatValue* temp = pctvdroop_;
  pctvdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SolarPointStatus::mutable_pctvdroop() {
  
  if (pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pctvdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.pctVDroop)
  return pctvdroop_;
}
inline void SolarPointStatus::set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pctvdroop_);
  }
  if (pctvdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pctvdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pctvdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }
    
  } else {
    
  }
  pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.pctVDroop)
}

// .commonmodule.RampRate rampRates = 5;
inline bool SolarPointStatus::has_ramprates() const {
  return this != internal_default_instance() && ramprates_ != nullptr;
}
inline const ::commonmodule::RampRate& SolarPointStatus::ramprates() const {
  const ::commonmodule::RampRate* p = ramprates_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.rampRates)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::RampRate*>(
      &::commonmodule::_RampRate_default_instance_);
}
inline ::commonmodule::RampRate* SolarPointStatus::release_ramprates() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.rampRates)
  
  ::commonmodule::RampRate* temp = ramprates_;
  ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* SolarPointStatus::mutable_ramprates() {
  
  if (ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaNoVirtual());
    ramprates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.rampRates)
  return ramprates_;
}
inline void SolarPointStatus::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ramprates_);
  }
  if (ramprates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ramprates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }
    
  } else {
    
  }
  ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.rampRates)
}

// .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;
inline bool SolarPointStatus::has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && reactivepwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPointStatus::reactivepwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = reactivepwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPointStatus::release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = reactivepwrsetpointenabled_;
  reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPointStatus::mutable_reactivepwrsetpointenabled() {
  
  if (reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reactivepwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
  return reactivepwrsetpointenabled_;
}
inline void SolarPointStatus::set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
}

// .commonmodule.ControlDPC realPwrSetPointEnabled = 7;
inline bool SolarPointStatus::has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && realpwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPointStatus::realpwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = realpwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPointStatus::release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = realpwrsetpointenabled_;
  realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPointStatus::mutable_realpwrsetpointenabled() {
  
  if (realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    realpwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
  return realpwrsetpointenabled_;
}
inline void SolarPointStatus::set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
}

// .commonmodule.Optional_StateKind state = 8;
inline bool SolarPointStatus::has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline const ::commonmodule::Optional_StateKind& SolarPointStatus::state() const {
  const ::commonmodule::Optional_StateKind* p = state_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.state)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_StateKind*>(
      &::commonmodule::_Optional_StateKind_default_instance_);
}
inline ::commonmodule::Optional_StateKind* SolarPointStatus::release_state() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.state)
  
  ::commonmodule::Optional_StateKind* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* SolarPointStatus::mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.state)
  return state_;
}
inline void SolarPointStatus::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.state)
}

// .commonmodule.ControlDPC voltageSetPointEnabled = 9;
inline bool SolarPointStatus::has_voltagesetpointenabled() const {
  return this != internal_default_instance() && voltagesetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SolarPointStatus::voltagesetpointenabled() const {
  const ::commonmodule::ControlDPC* p = voltagesetpointenabled_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.voltageSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SolarPointStatus::release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.voltageSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = voltagesetpointenabled_;
  voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SolarPointStatus::mutable_voltagesetpointenabled() {
  
  if (voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    voltagesetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.voltageSetPointEnabled)
  return voltagesetpointenabled_;
}
inline void SolarPointStatus::set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.voltageSetPointEnabled)
}

// -------------------------------------------------------------------

// SolarEventAndStatusZGEN

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool SolarEventAndStatusZGEN::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SolarEventAndStatusZGEN::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SolarEventAndStatusZGEN::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SolarEventAndStatusZGEN::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void SolarEventAndStatusZGEN::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS AuxPwrSt = 2;
inline bool SolarEventAndStatusZGEN::has_auxpwrst() const {
  return this != internal_default_instance() && auxpwrst_ != nullptr;
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::auxpwrst() const {
  const ::commonmodule::StatusSPS* p = auxpwrst_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::release_auxpwrst() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
  
  ::commonmodule::StatusSPS* temp = auxpwrst_;
  auxpwrst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::mutable_auxpwrst() {
  
  if (auxpwrst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    auxpwrst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
  return auxpwrst_;
}
inline void SolarEventAndStatusZGEN::set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(auxpwrst_);
  }
  if (auxpwrst) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      auxpwrst = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, auxpwrst, submessage_arena);
    }
    
  } else {
    
  }
  auxpwrst_ = auxpwrst;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
inline bool SolarEventAndStatusZGEN::has_dynamictest() const {
  return this != internal_default_instance() && dynamictest_ != nullptr;
}
inline const ::commonmodule::ENS_DynamicTestKind& SolarEventAndStatusZGEN::dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = dynamictest_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind*>(
      &::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline ::commonmodule::ENS_DynamicTestKind* SolarEventAndStatusZGEN::release_dynamictest() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = dynamictest_;
  dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SolarEventAndStatusZGEN::mutable_dynamictest() {
  
  if (dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaNoVirtual());
    dynamictest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
  return dynamictest_;
}
inline void SolarEventAndStatusZGEN::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dynamictest_);
  }
  if (dynamictest) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamictest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }
    
  } else {
    
  }
  dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
}

// .commonmodule.StatusSPS EmgStop = 4;
inline bool SolarEventAndStatusZGEN::has_emgstop() const {
  return this != internal_default_instance() && emgstop_ != nullptr;
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::emgstop() const {
  const ::commonmodule::StatusSPS* p = emgstop_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.EmgStop)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::release_emgstop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.EmgStop)
  
  ::commonmodule::StatusSPS* temp = emgstop_;
  emgstop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::mutable_emgstop() {
  
  if (emgstop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    emgstop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.EmgStop)
  return emgstop_;
}
inline void SolarEventAndStatusZGEN::set_allocated_emgstop(::commonmodule::StatusSPS* emgstop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emgstop_);
  }
  if (emgstop) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      emgstop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emgstop, submessage_arena);
    }
    
  } else {
    
  }
  emgstop_ = emgstop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.EmgStop)
}

// .solarmodule.SolarPointStatus PointStatus = 5;
inline bool SolarEventAndStatusZGEN::has_pointstatus() const {
  return this != internal_default_instance() && pointstatus_ != nullptr;
}
inline void SolarEventAndStatusZGEN::clear_pointstatus() {
  if (GetArenaNoVirtual() == nullptr && pointstatus_ != nullptr) {
    delete pointstatus_;
  }
  pointstatus_ = nullptr;
}
inline const ::solarmodule::SolarPointStatus& SolarEventAndStatusZGEN::pointstatus() const {
  const ::solarmodule::SolarPointStatus* p = pointstatus_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.PointStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarPointStatus*>(
      &::solarmodule::_SolarPointStatus_default_instance_);
}
inline ::solarmodule::SolarPointStatus* SolarEventAndStatusZGEN::release_pointstatus() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.PointStatus)
  
  ::solarmodule::SolarPointStatus* temp = pointstatus_;
  pointstatus_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarPointStatus* SolarEventAndStatusZGEN::mutable_pointstatus() {
  
  if (pointstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarPointStatus>(GetArenaNoVirtual());
    pointstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.PointStatus)
  return pointstatus_;
}
inline void SolarEventAndStatusZGEN::set_allocated_pointstatus(::solarmodule::SolarPointStatus* pointstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pointstatus_;
  }
  if (pointstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pointstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pointstatus, submessage_arena);
    }
    
  } else {
    
  }
  pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.PointStatus)
}

// -------------------------------------------------------------------

// SolarEventZGEN

// .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool SolarEventZGEN::has_solareventandstatuszgen() const {
  return this != internal_default_instance() && solareventandstatuszgen_ != nullptr;
}
inline void SolarEventZGEN::clear_solareventandstatuszgen() {
  if (GetArenaNoVirtual() == nullptr && solareventandstatuszgen_ != nullptr) {
    delete solareventandstatuszgen_;
  }
  solareventandstatuszgen_ = nullptr;
}
inline const ::solarmodule::SolarEventAndStatusZGEN& SolarEventZGEN::solareventandstatuszgen() const {
  const ::solarmodule::SolarEventAndStatusZGEN* p = solareventandstatuszgen_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarEventAndStatusZGEN*>(
      &::solarmodule::_SolarEventAndStatusZGEN_default_instance_);
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarEventZGEN::release_solareventandstatuszgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
  
  ::solarmodule::SolarEventAndStatusZGEN* temp = solareventandstatuszgen_;
  solareventandstatuszgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarEventZGEN::mutable_solareventandstatuszgen() {
  
  if (solareventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEventAndStatusZGEN>(GetArenaNoVirtual());
    solareventandstatuszgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
  return solareventandstatuszgen_;
}
inline void SolarEventZGEN::set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solareventandstatuszgen_;
  }
  if (solareventandstatuszgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solareventandstatuszgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solareventandstatuszgen, submessage_arena);
    }
    
  } else {
    
  }
  solareventandstatuszgen_ = solareventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
}

// .commonmodule.ENG_GridConnectModeKind GriMod = 2;
inline bool SolarEventZGEN::has_grimod() const {
  return this != internal_default_instance() && grimod_ != nullptr;
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarEventZGEN::grimod() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = grimod_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventZGEN.GriMod)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind*>(
      &::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarEventZGEN::release_grimod() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventZGEN.GriMod)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = grimod_;
  grimod_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarEventZGEN::mutable_grimod() {
  
  if (grimod_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaNoVirtual());
    grimod_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventZGEN.GriMod)
  return grimod_;
}
inline void SolarEventZGEN::set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(grimod_);
  }
  if (grimod) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      grimod = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grimod, submessage_arena);
    }
    
  } else {
    
  }
  grimod_ = grimod;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventZGEN.GriMod)
}

// -------------------------------------------------------------------

// SolarEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarEvent::has_eventvalue() const {
  return this != internal_default_instance() && eventvalue_ != nullptr;
}
inline const ::commonmodule::EventValue& SolarEvent::eventvalue() const {
  const ::commonmodule::EventValue* p = eventvalue_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEvent.eventValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventValue*>(
      &::commonmodule::_EventValue_default_instance_);
}
inline ::commonmodule::EventValue* SolarEvent::release_eventvalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEvent.eventValue)
  
  ::commonmodule::EventValue* temp = eventvalue_;
  eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* SolarEvent::mutable_eventvalue() {
  
  if (eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaNoVirtual());
    eventvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEvent.eventValue)
  return eventvalue_;
}
inline void SolarEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventvalue_);
  }
  if (eventvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }
    
  } else {
    
  }
  eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEvent.eventValue)
}

// .solarmodule.SolarEventZGEN solarEventZGEN = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarEvent::has_solareventzgen() const {
  return this != internal_default_instance() && solareventzgen_ != nullptr;
}
inline void SolarEvent::clear_solareventzgen() {
  if (GetArenaNoVirtual() == nullptr && solareventzgen_ != nullptr) {
    delete solareventzgen_;
  }
  solareventzgen_ = nullptr;
}
inline const ::solarmodule::SolarEventZGEN& SolarEvent::solareventzgen() const {
  const ::solarmodule::SolarEventZGEN* p = solareventzgen_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEvent.solarEventZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarEventZGEN*>(
      &::solarmodule::_SolarEventZGEN_default_instance_);
}
inline ::solarmodule::SolarEventZGEN* SolarEvent::release_solareventzgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEvent.solarEventZGEN)
  
  ::solarmodule::SolarEventZGEN* temp = solareventzgen_;
  solareventzgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEventZGEN* SolarEvent::mutable_solareventzgen() {
  
  if (solareventzgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEventZGEN>(GetArenaNoVirtual());
    solareventzgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEvent.solarEventZGEN)
  return solareventzgen_;
}
inline void SolarEvent::set_allocated_solareventzgen(::solarmodule::SolarEventZGEN* solareventzgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solareventzgen_;
  }
  if (solareventzgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solareventzgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solareventzgen, submessage_arena);
    }
    
  } else {
    
  }
  solareventzgen_ = solareventzgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEvent.solarEventZGEN)
}

// -------------------------------------------------------------------

// SolarEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarEventProfile::has_eventmessageinfo() const {
  return this != internal_default_instance() && eventmessageinfo_ != nullptr;
}
inline const ::commonmodule::EventMessageInfo& SolarEventProfile::eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = eventmessageinfo_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventProfile.eventMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventMessageInfo*>(
      &::commonmodule::_EventMessageInfo_default_instance_);
}
inline ::commonmodule::EventMessageInfo* SolarEventProfile::release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* SolarEventProfile::mutable_eventmessageinfo() {
  
  if (eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaNoVirtual());
    eventmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventProfile.eventMessageInfo)
  return eventmessageinfo_;
}
inline void SolarEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventProfile.eventMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarEventProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SolarEventProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SolarEventProfile::release_ied() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SolarEventProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventProfile.ied)
  return ied_;
}
inline void SolarEventProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventProfile.ied)
}

// .solarmodule.SolarEvent solarEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarEventProfile::has_solarevent() const {
  return this != internal_default_instance() && solarevent_ != nullptr;
}
inline void SolarEventProfile::clear_solarevent() {
  if (GetArenaNoVirtual() == nullptr && solarevent_ != nullptr) {
    delete solarevent_;
  }
  solarevent_ = nullptr;
}
inline const ::solarmodule::SolarEvent& SolarEventProfile::solarevent() const {
  const ::solarmodule::SolarEvent* p = solarevent_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventProfile.solarEvent)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarEvent*>(
      &::solarmodule::_SolarEvent_default_instance_);
}
inline ::solarmodule::SolarEvent* SolarEventProfile::release_solarevent() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventProfile.solarEvent)
  
  ::solarmodule::SolarEvent* temp = solarevent_;
  solarevent_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEvent* SolarEventProfile::mutable_solarevent() {
  
  if (solarevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEvent>(GetArenaNoVirtual());
    solarevent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventProfile.solarEvent)
  return solarevent_;
}
inline void SolarEventProfile::set_allocated_solarevent(::solarmodule::SolarEvent* solarevent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarevent_;
  }
  if (solarevent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarevent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarevent, submessage_arena);
    }
    
  } else {
    
  }
  solarevent_ = solarevent;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventProfile.solarEvent)
}

// .solarmodule.SolarInverter solarInverter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarEventProfile::has_solarinverter() const {
  return this != internal_default_instance() && solarinverter_ != nullptr;
}
inline void SolarEventProfile::clear_solarinverter() {
  if (GetArenaNoVirtual() == nullptr && solarinverter_ != nullptr) {
    delete solarinverter_;
  }
  solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarEventProfile::solarinverter() const {
  const ::solarmodule::SolarInverter* p = solarinverter_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventProfile.solarInverter)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarInverter*>(
      &::solarmodule::_SolarInverter_default_instance_);
}
inline ::solarmodule::SolarInverter* SolarEventProfile::release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = solarinverter_;
  solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarEventProfile::mutable_solarinverter() {
  
  if (solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaNoVirtual());
    solarinverter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventProfile.solarInverter)
  return solarinverter_;
}
inline void SolarEventProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarinverter_;
  }
  if (solarinverter) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarinverter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }
    
  } else {
    
  }
  solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventProfile.solarInverter)
}

// -------------------------------------------------------------------

// SolarReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool SolarReading::has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && conductingequipmentterminalreading_ != nullptr;
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& SolarReading::conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = conductingequipmentterminalreading_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.conductingEquipmentTerminalReading)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading*>(
      &::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SolarReading::release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = conductingequipmentterminalreading_;
  conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SolarReading::mutable_conductingequipmentterminalreading() {
  
  if (conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaNoVirtual());
    conductingequipmentterminalreading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.conductingEquipmentTerminalReading)
  return conductingequipmentterminalreading_;
}
inline void SolarReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool SolarReading::has_phasemmtn() const {
  return this != internal_default_instance() && phasemmtn_ != nullptr;
}
inline const ::commonmodule::PhaseMMTN& SolarReading::phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = phasemmtn_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.phaseMMTN)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::PhaseMMTN*>(
      &::commonmodule::_PhaseMMTN_default_instance_);
}
inline ::commonmodule::PhaseMMTN* SolarReading::release_phasemmtn() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = phasemmtn_;
  phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* SolarReading::mutable_phasemmtn() {
  
  if (phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaNoVirtual());
    phasemmtn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.phaseMMTN)
  return phasemmtn_;
}
inline void SolarReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(phasemmtn_);
  }
  if (phasemmtn) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phasemmtn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }
    
  } else {
    
  }
  phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool SolarReading::has_readingmmtr() const {
  return this != internal_default_instance() && readingmmtr_ != nullptr;
}
inline const ::commonmodule::ReadingMMTR& SolarReading::readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = readingmmtr_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.readingMMTR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTR*>(
      &::commonmodule::_ReadingMMTR_default_instance_);
}
inline ::commonmodule::ReadingMMTR* SolarReading::release_readingmmtr() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = readingmmtr_;
  readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* SolarReading::mutable_readingmmtr() {
  
  if (readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaNoVirtual());
    readingmmtr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.readingMMTR)
  return readingmmtr_;
}
inline void SolarReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmtr_);
  }
  if (readingmmtr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmtr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }
    
  } else {
    
  }
  readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool SolarReading::has_readingmmxu() const {
  return this != internal_default_instance() && readingmmxu_ != nullptr;
}
inline const ::commonmodule::ReadingMMXU& SolarReading::readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = readingmmxu_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.readingMMXU)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMXU*>(
      &::commonmodule::_ReadingMMXU_default_instance_);
}
inline ::commonmodule::ReadingMMXU* SolarReading::release_readingmmxu() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = readingmmxu_;
  readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* SolarReading::mutable_readingmmxu() {
  
  if (readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaNoVirtual());
    readingmmxu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.readingMMXU)
  return readingmmxu_;
}
inline void SolarReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmxu_);
  }
  if (readingmmxu) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmxu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }
    
  } else {
    
  }
  readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.readingMMXU)
}

// -------------------------------------------------------------------

// SolarReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarReadingProfile::has_readingmessageinfo() const {
  return this != internal_default_instance() && readingmessageinfo_ != nullptr;
}
inline const ::commonmodule::ReadingMessageInfo& SolarReadingProfile::readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = readingmessageinfo_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReadingProfile.readingMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMessageInfo*>(
      &::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline ::commonmodule::ReadingMessageInfo* SolarReadingProfile::release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = readingmessageinfo_;
  readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* SolarReadingProfile::mutable_readingmessageinfo() {
  
  if (readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaNoVirtual());
    readingmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReadingProfile.readingMessageInfo)
  return readingmessageinfo_;
}
inline void SolarReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReadingProfile.readingMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarReadingProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SolarReadingProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReadingProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SolarReadingProfile::release_ied() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReadingProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SolarReadingProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReadingProfile.ied)
  return ied_;
}
inline void SolarReadingProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReadingProfile.ied)
}

// .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarReadingProfile::has_solarinverter() const {
  return this != internal_default_instance() && solarinverter_ != nullptr;
}
inline void SolarReadingProfile::clear_solarinverter() {
  if (GetArenaNoVirtual() == nullptr && solarinverter_ != nullptr) {
    delete solarinverter_;
  }
  solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarReadingProfile::solarinverter() const {
  const ::solarmodule::SolarInverter* p = solarinverter_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReadingProfile.solarInverter)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarInverter*>(
      &::solarmodule::_SolarInverter_default_instance_);
}
inline ::solarmodule::SolarInverter* SolarReadingProfile::release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReadingProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = solarinverter_;
  solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarReadingProfile::mutable_solarinverter() {
  
  if (solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaNoVirtual());
    solarinverter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReadingProfile.solarInverter)
  return solarinverter_;
}
inline void SolarReadingProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarinverter_;
  }
  if (solarinverter) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarinverter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }
    
  } else {
    
  }
  solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReadingProfile.solarInverter)
}

// .solarmodule.SolarReading solarReading = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarReadingProfile::has_solarreading() const {
  return this != internal_default_instance() && solarreading_ != nullptr;
}
inline void SolarReadingProfile::clear_solarreading() {
  if (GetArenaNoVirtual() == nullptr && solarreading_ != nullptr) {
    delete solarreading_;
  }
  solarreading_ = nullptr;
}
inline const ::solarmodule::SolarReading& SolarReadingProfile::solarreading() const {
  const ::solarmodule::SolarReading* p = solarreading_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarReadingProfile.solarReading)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarReading*>(
      &::solarmodule::_SolarReading_default_instance_);
}
inline ::solarmodule::SolarReading* SolarReadingProfile::release_solarreading() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReadingProfile.solarReading)
  
  ::solarmodule::SolarReading* temp = solarreading_;
  solarreading_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarReading* SolarReadingProfile::mutable_solarreading() {
  
  if (solarreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarReading>(GetArenaNoVirtual());
    solarreading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReadingProfile.solarReading)
  return solarreading_;
}
inline void SolarReadingProfile::set_allocated_solarreading(::solarmodule::SolarReading* solarreading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarreading_;
  }
  if (solarreading) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarreading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarreading, submessage_arena);
    }
    
  } else {
    
  }
  solarreading_ = solarreading;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReadingProfile.solarReading)
}

// -------------------------------------------------------------------

// SolarStatusZGEN

// .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool SolarStatusZGEN::has_solareventandstatuszgen() const {
  return this != internal_default_instance() && solareventandstatuszgen_ != nullptr;
}
inline void SolarStatusZGEN::clear_solareventandstatuszgen() {
  if (GetArenaNoVirtual() == nullptr && solareventandstatuszgen_ != nullptr) {
    delete solareventandstatuszgen_;
  }
  solareventandstatuszgen_ = nullptr;
}
inline const ::solarmodule::SolarEventAndStatusZGEN& SolarStatusZGEN::solareventandstatuszgen() const {
  const ::solarmodule::SolarEventAndStatusZGEN* p = solareventandstatuszgen_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarEventAndStatusZGEN*>(
      &::solarmodule::_SolarEventAndStatusZGEN_default_instance_);
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarStatusZGEN::release_solareventandstatuszgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
  
  ::solarmodule::SolarEventAndStatusZGEN* temp = solareventandstatuszgen_;
  solareventandstatuszgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarStatusZGEN::mutable_solareventandstatuszgen() {
  
  if (solareventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEventAndStatusZGEN>(GetArenaNoVirtual());
    solareventandstatuszgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
  return solareventandstatuszgen_;
}
inline void SolarStatusZGEN::set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solareventandstatuszgen_;
  }
  if (solareventandstatuszgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solareventandstatuszgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solareventandstatuszgen, submessage_arena);
    }
    
  } else {
    
  }
  solareventandstatuszgen_ = solareventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
}

// .commonmodule.ENG_GridConnectModeKind GriMod = 2;
inline bool SolarStatusZGEN::has_grimod() const {
  return this != internal_default_instance() && grimod_ != nullptr;
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarStatusZGEN::grimod() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = grimod_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusZGEN.GriMod)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind*>(
      &::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarStatusZGEN::release_grimod() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusZGEN.GriMod)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = grimod_;
  grimod_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarStatusZGEN::mutable_grimod() {
  
  if (grimod_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaNoVirtual());
    grimod_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusZGEN.GriMod)
  return grimod_;
}
inline void SolarStatusZGEN::set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(grimod_);
  }
  if (grimod) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      grimod = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grimod, submessage_arena);
    }
    
  } else {
    
  }
  grimod_ = grimod;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusZGEN.GriMod)
}

// -------------------------------------------------------------------

// SolarStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarStatus::has_statusvalue() const {
  return this != internal_default_instance() && statusvalue_ != nullptr;
}
inline const ::commonmodule::StatusValue& SolarStatus::statusvalue() const {
  const ::commonmodule::StatusValue* p = statusvalue_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatus.statusValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusValue*>(
      &::commonmodule::_StatusValue_default_instance_);
}
inline ::commonmodule::StatusValue* SolarStatus::release_statusvalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = statusvalue_;
  statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* SolarStatus::mutable_statusvalue() {
  
  if (statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaNoVirtual());
    statusvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatus.statusValue)
  return statusvalue_;
}
inline void SolarStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusvalue_);
  }
  if (statusvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }
    
  } else {
    
  }
  statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatus.statusValue)
}

// .solarmodule.SolarStatusZGEN solarStatusZGEN = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarStatus::has_solarstatuszgen() const {
  return this != internal_default_instance() && solarstatuszgen_ != nullptr;
}
inline void SolarStatus::clear_solarstatuszgen() {
  if (GetArenaNoVirtual() == nullptr && solarstatuszgen_ != nullptr) {
    delete solarstatuszgen_;
  }
  solarstatuszgen_ = nullptr;
}
inline const ::solarmodule::SolarStatusZGEN& SolarStatus::solarstatuszgen() const {
  const ::solarmodule::SolarStatusZGEN* p = solarstatuszgen_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatus.solarStatusZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarStatusZGEN*>(
      &::solarmodule::_SolarStatusZGEN_default_instance_);
}
inline ::solarmodule::SolarStatusZGEN* SolarStatus::release_solarstatuszgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatus.solarStatusZGEN)
  
  ::solarmodule::SolarStatusZGEN* temp = solarstatuszgen_;
  solarstatuszgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarStatusZGEN* SolarStatus::mutable_solarstatuszgen() {
  
  if (solarstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarStatusZGEN>(GetArenaNoVirtual());
    solarstatuszgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatus.solarStatusZGEN)
  return solarstatuszgen_;
}
inline void SolarStatus::set_allocated_solarstatuszgen(::solarmodule::SolarStatusZGEN* solarstatuszgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarstatuszgen_;
  }
  if (solarstatuszgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarstatuszgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarstatuszgen, submessage_arena);
    }
    
  } else {
    
  }
  solarstatuszgen_ = solarstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatus.solarStatusZGEN)
}

// -------------------------------------------------------------------

// SolarStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarStatusProfile::has_statusmessageinfo() const {
  return this != internal_default_instance() && statusmessageinfo_ != nullptr;
}
inline const ::commonmodule::StatusMessageInfo& SolarStatusProfile::statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = statusmessageinfo_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusProfile.statusMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusMessageInfo*>(
      &::commonmodule::_StatusMessageInfo_default_instance_);
}
inline ::commonmodule::StatusMessageInfo* SolarStatusProfile::release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = statusmessageinfo_;
  statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* SolarStatusProfile::mutable_statusmessageinfo() {
  
  if (statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaNoVirtual());
    statusmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusProfile.statusMessageInfo)
  return statusmessageinfo_;
}
inline void SolarStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusProfile.statusMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarStatusProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SolarStatusProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SolarStatusProfile::release_ied() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SolarStatusProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusProfile.ied)
  return ied_;
}
inline void SolarStatusProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusProfile.ied)
}

// .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarStatusProfile::has_solarinverter() const {
  return this != internal_default_instance() && solarinverter_ != nullptr;
}
inline void SolarStatusProfile::clear_solarinverter() {
  if (GetArenaNoVirtual() == nullptr && solarinverter_ != nullptr) {
    delete solarinverter_;
  }
  solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarStatusProfile::solarinverter() const {
  const ::solarmodule::SolarInverter* p = solarinverter_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusProfile.solarInverter)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarInverter*>(
      &::solarmodule::_SolarInverter_default_instance_);
}
inline ::solarmodule::SolarInverter* SolarStatusProfile::release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = solarinverter_;
  solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarStatusProfile::mutable_solarinverter() {
  
  if (solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaNoVirtual());
    solarinverter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusProfile.solarInverter)
  return solarinverter_;
}
inline void SolarStatusProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarinverter_;
  }
  if (solarinverter) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarinverter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }
    
  } else {
    
  }
  solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusProfile.solarInverter)
}

// .solarmodule.SolarStatus solarStatus = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarStatusProfile::has_solarstatus() const {
  return this != internal_default_instance() && solarstatus_ != nullptr;
}
inline void SolarStatusProfile::clear_solarstatus() {
  if (GetArenaNoVirtual() == nullptr && solarstatus_ != nullptr) {
    delete solarstatus_;
  }
  solarstatus_ = nullptr;
}
inline const ::solarmodule::SolarStatus& SolarStatusProfile::solarstatus() const {
  const ::solarmodule::SolarStatus* p = solarstatus_;
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusProfile.solarStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::solarmodule::SolarStatus*>(
      &::solarmodule::_SolarStatus_default_instance_);
}
inline ::solarmodule::SolarStatus* SolarStatusProfile::release_solarstatus() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusProfile.solarStatus)
  
  ::solarmodule::SolarStatus* temp = solarstatus_;
  solarstatus_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarStatus* SolarStatusProfile::mutable_solarstatus() {
  
  if (solarstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarStatus>(GetArenaNoVirtual());
    solarstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusProfile.solarStatus)
  return solarstatus_;
}
inline void SolarStatusProfile::set_allocated_solarstatus(::solarmodule::SolarStatus* solarstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete solarstatus_;
  }
  if (solarstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      solarstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solarstatus, submessage_arena);
    }
    
  } else {
    
  }
  solarstatus_ = solarstatus;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusProfile.solarStatus)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace solarmodule

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_solarmodule_2fsolarmodule_2eproto
