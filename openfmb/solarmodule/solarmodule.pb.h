// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: solarmodule/solarmodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_solarmodule_2fsolarmodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_solarmodule_2fsolarmodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_solarmodule_2fsolarmodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_solarmodule_2fsolarmodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_solarmodule_2fsolarmodule_2eproto;
namespace solarmodule {
class SolarCSG;
struct SolarCSGDefaultTypeInternal;
extern SolarCSGDefaultTypeInternal _SolarCSG_default_instance_;
class SolarCapability;
struct SolarCapabilityDefaultTypeInternal;
extern SolarCapabilityDefaultTypeInternal _SolarCapability_default_instance_;
class SolarCapabilityConfiguration;
struct SolarCapabilityConfigurationDefaultTypeInternal;
extern SolarCapabilityConfigurationDefaultTypeInternal _SolarCapabilityConfiguration_default_instance_;
class SolarCapabilityOverride;
struct SolarCapabilityOverrideDefaultTypeInternal;
extern SolarCapabilityOverrideDefaultTypeInternal _SolarCapabilityOverride_default_instance_;
class SolarCapabilityOverrideProfile;
struct SolarCapabilityOverrideProfileDefaultTypeInternal;
extern SolarCapabilityOverrideProfileDefaultTypeInternal _SolarCapabilityOverrideProfile_default_instance_;
class SolarCapabilityProfile;
struct SolarCapabilityProfileDefaultTypeInternal;
extern SolarCapabilityProfileDefaultTypeInternal _SolarCapabilityProfile_default_instance_;
class SolarCapabilityRatings;
struct SolarCapabilityRatingsDefaultTypeInternal;
extern SolarCapabilityRatingsDefaultTypeInternal _SolarCapabilityRatings_default_instance_;
class SolarControl;
struct SolarControlDefaultTypeInternal;
extern SolarControlDefaultTypeInternal _SolarControl_default_instance_;
class SolarControlFSCC;
struct SolarControlFSCCDefaultTypeInternal;
extern SolarControlFSCCDefaultTypeInternal _SolarControlFSCC_default_instance_;
class SolarControlProfile;
struct SolarControlProfileDefaultTypeInternal;
extern SolarControlProfileDefaultTypeInternal _SolarControlProfile_default_instance_;
class SolarControlScheduleFSCH;
struct SolarControlScheduleFSCHDefaultTypeInternal;
extern SolarControlScheduleFSCHDefaultTypeInternal _SolarControlScheduleFSCH_default_instance_;
class SolarCurvePoint;
struct SolarCurvePointDefaultTypeInternal;
extern SolarCurvePointDefaultTypeInternal _SolarCurvePoint_default_instance_;
class SolarDiscreteControl;
struct SolarDiscreteControlDefaultTypeInternal;
extern SolarDiscreteControlDefaultTypeInternal _SolarDiscreteControl_default_instance_;
class SolarDiscreteControlPV;
struct SolarDiscreteControlPVDefaultTypeInternal;
extern SolarDiscreteControlPVDefaultTypeInternal _SolarDiscreteControlPV_default_instance_;
class SolarDiscreteControlProfile;
struct SolarDiscreteControlProfileDefaultTypeInternal;
extern SolarDiscreteControlProfileDefaultTypeInternal _SolarDiscreteControlProfile_default_instance_;
class SolarEvent;
struct SolarEventDefaultTypeInternal;
extern SolarEventDefaultTypeInternal _SolarEvent_default_instance_;
class SolarEventAndStatusZGEN;
struct SolarEventAndStatusZGENDefaultTypeInternal;
extern SolarEventAndStatusZGENDefaultTypeInternal _SolarEventAndStatusZGEN_default_instance_;
class SolarEventProfile;
struct SolarEventProfileDefaultTypeInternal;
extern SolarEventProfileDefaultTypeInternal _SolarEventProfile_default_instance_;
class SolarEventZGEN;
struct SolarEventZGENDefaultTypeInternal;
extern SolarEventZGENDefaultTypeInternal _SolarEventZGEN_default_instance_;
class SolarInverter;
struct SolarInverterDefaultTypeInternal;
extern SolarInverterDefaultTypeInternal _SolarInverter_default_instance_;
class SolarPoint;
struct SolarPointDefaultTypeInternal;
extern SolarPointDefaultTypeInternal _SolarPoint_default_instance_;
class SolarPointStatus;
struct SolarPointStatusDefaultTypeInternal;
extern SolarPointStatusDefaultTypeInternal _SolarPointStatus_default_instance_;
class SolarReading;
struct SolarReadingDefaultTypeInternal;
extern SolarReadingDefaultTypeInternal _SolarReading_default_instance_;
class SolarReadingProfile;
struct SolarReadingProfileDefaultTypeInternal;
extern SolarReadingProfileDefaultTypeInternal _SolarReadingProfile_default_instance_;
class SolarStatus;
struct SolarStatusDefaultTypeInternal;
extern SolarStatusDefaultTypeInternal _SolarStatus_default_instance_;
class SolarStatusProfile;
struct SolarStatusProfileDefaultTypeInternal;
extern SolarStatusProfileDefaultTypeInternal _SolarStatusProfile_default_instance_;
class SolarStatusZGEN;
struct SolarStatusZGENDefaultTypeInternal;
extern SolarStatusZGENDefaultTypeInternal _SolarStatusZGEN_default_instance_;
}  // namespace solarmodule
PROTOBUF_NAMESPACE_OPEN
template <>
::solarmodule::SolarCSG* Arena::CreateMaybeMessage<::solarmodule::SolarCSG>(Arena*);
template <>
::solarmodule::SolarCapability* Arena::CreateMaybeMessage<::solarmodule::SolarCapability>(Arena*);
template <>
::solarmodule::SolarCapabilityConfiguration* Arena::CreateMaybeMessage<::solarmodule::SolarCapabilityConfiguration>(Arena*);
template <>
::solarmodule::SolarCapabilityOverride* Arena::CreateMaybeMessage<::solarmodule::SolarCapabilityOverride>(Arena*);
template <>
::solarmodule::SolarCapabilityOverrideProfile* Arena::CreateMaybeMessage<::solarmodule::SolarCapabilityOverrideProfile>(Arena*);
template <>
::solarmodule::SolarCapabilityProfile* Arena::CreateMaybeMessage<::solarmodule::SolarCapabilityProfile>(Arena*);
template <>
::solarmodule::SolarCapabilityRatings* Arena::CreateMaybeMessage<::solarmodule::SolarCapabilityRatings>(Arena*);
template <>
::solarmodule::SolarControl* Arena::CreateMaybeMessage<::solarmodule::SolarControl>(Arena*);
template <>
::solarmodule::SolarControlFSCC* Arena::CreateMaybeMessage<::solarmodule::SolarControlFSCC>(Arena*);
template <>
::solarmodule::SolarControlProfile* Arena::CreateMaybeMessage<::solarmodule::SolarControlProfile>(Arena*);
template <>
::solarmodule::SolarControlScheduleFSCH* Arena::CreateMaybeMessage<::solarmodule::SolarControlScheduleFSCH>(Arena*);
template <>
::solarmodule::SolarCurvePoint* Arena::CreateMaybeMessage<::solarmodule::SolarCurvePoint>(Arena*);
template <>
::solarmodule::SolarDiscreteControl* Arena::CreateMaybeMessage<::solarmodule::SolarDiscreteControl>(Arena*);
template <>
::solarmodule::SolarDiscreteControlPV* Arena::CreateMaybeMessage<::solarmodule::SolarDiscreteControlPV>(Arena*);
template <>
::solarmodule::SolarDiscreteControlProfile* Arena::CreateMaybeMessage<::solarmodule::SolarDiscreteControlProfile>(Arena*);
template <>
::solarmodule::SolarEvent* Arena::CreateMaybeMessage<::solarmodule::SolarEvent>(Arena*);
template <>
::solarmodule::SolarEventAndStatusZGEN* Arena::CreateMaybeMessage<::solarmodule::SolarEventAndStatusZGEN>(Arena*);
template <>
::solarmodule::SolarEventProfile* Arena::CreateMaybeMessage<::solarmodule::SolarEventProfile>(Arena*);
template <>
::solarmodule::SolarEventZGEN* Arena::CreateMaybeMessage<::solarmodule::SolarEventZGEN>(Arena*);
template <>
::solarmodule::SolarInverter* Arena::CreateMaybeMessage<::solarmodule::SolarInverter>(Arena*);
template <>
::solarmodule::SolarPoint* Arena::CreateMaybeMessage<::solarmodule::SolarPoint>(Arena*);
template <>
::solarmodule::SolarPointStatus* Arena::CreateMaybeMessage<::solarmodule::SolarPointStatus>(Arena*);
template <>
::solarmodule::SolarReading* Arena::CreateMaybeMessage<::solarmodule::SolarReading>(Arena*);
template <>
::solarmodule::SolarReadingProfile* Arena::CreateMaybeMessage<::solarmodule::SolarReadingProfile>(Arena*);
template <>
::solarmodule::SolarStatus* Arena::CreateMaybeMessage<::solarmodule::SolarStatus>(Arena*);
template <>
::solarmodule::SolarStatusProfile* Arena::CreateMaybeMessage<::solarmodule::SolarStatusProfile>(Arena*);
template <>
::solarmodule::SolarStatusZGEN* Arena::CreateMaybeMessage<::solarmodule::SolarStatusZGEN>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace solarmodule {

// ===================================================================


// -------------------------------------------------------------------

class SolarInverter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarInverter) */ {
 public:
  inline SolarInverter() : SolarInverter(nullptr) {}
  ~SolarInverter() override;
  explicit PROTOBUF_CONSTEXPR SolarInverter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarInverter(const SolarInverter& from);
  SolarInverter(SolarInverter&& from) noexcept
    : SolarInverter() {
    *this = ::std::move(from);
  }

  inline SolarInverter& operator=(const SolarInverter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarInverter& operator=(SolarInverter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarInverter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarInverter* internal_default_instance() {
    return reinterpret_cast<const SolarInverter*>(
               &_SolarInverter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SolarInverter& a, SolarInverter& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarInverter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarInverter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarInverter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarInverter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarInverter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarInverter& from) {
    SolarInverter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarInverter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarInverter";
  }
  protected:
  explicit SolarInverter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  private:
  bool _internal_has_conductingequipment() const;

  public:
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);
  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_conductingequipment();
  public:
  void unsafe_arena_set_allocated_conductingequipment(
      ::commonmodule::ConductingEquipment* conductingequipment);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_conductingequipment();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarInverter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipment* conductingequipment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCapabilityConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCapabilityConfiguration) */ {
 public:
  inline SolarCapabilityConfiguration() : SolarCapabilityConfiguration(nullptr) {}
  ~SolarCapabilityConfiguration() override;
  explicit PROTOBUF_CONSTEXPR SolarCapabilityConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCapabilityConfiguration(const SolarCapabilityConfiguration& from);
  SolarCapabilityConfiguration(SolarCapabilityConfiguration&& from) noexcept
    : SolarCapabilityConfiguration() {
    *this = ::std::move(from);
  }

  inline SolarCapabilityConfiguration& operator=(const SolarCapabilityConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCapabilityConfiguration& operator=(SolarCapabilityConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCapabilityConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCapabilityConfiguration* internal_default_instance() {
    return reinterpret_cast<const SolarCapabilityConfiguration*>(
               &_SolarCapabilityConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SolarCapabilityConfiguration& a, SolarCapabilityConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCapabilityConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCapabilityConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCapabilityConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCapabilityConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCapabilityConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCapabilityConfiguration& from) {
    SolarCapabilityConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCapabilityConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCapabilityConfiguration";
  }
  protected:
  explicit SolarCapabilityConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceCapabilityConfigurationFieldNumber = 1,
  };
  // .commonmodule.SourceCapabilityConfiguration sourceCapabilityConfiguration = 1 [(.uml.option_parent_message) = true];
  bool has_sourcecapabilityconfiguration() const;
  private:
  bool _internal_has_sourcecapabilityconfiguration() const;

  public:
  void clear_sourcecapabilityconfiguration() ;
  const ::commonmodule::SourceCapabilityConfiguration& sourcecapabilityconfiguration() const;
  PROTOBUF_NODISCARD ::commonmodule::SourceCapabilityConfiguration* release_sourcecapabilityconfiguration();
  ::commonmodule::SourceCapabilityConfiguration* mutable_sourcecapabilityconfiguration();
  void set_allocated_sourcecapabilityconfiguration(::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration);
  private:
  const ::commonmodule::SourceCapabilityConfiguration& _internal_sourcecapabilityconfiguration() const;
  ::commonmodule::SourceCapabilityConfiguration* _internal_mutable_sourcecapabilityconfiguration();
  public:
  void unsafe_arena_set_allocated_sourcecapabilityconfiguration(
      ::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration);
  ::commonmodule::SourceCapabilityConfiguration* unsafe_arena_release_sourcecapabilityconfiguration();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCapabilityConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCapabilityOverride final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCapabilityOverride) */ {
 public:
  inline SolarCapabilityOverride() : SolarCapabilityOverride(nullptr) {}
  ~SolarCapabilityOverride() override;
  explicit PROTOBUF_CONSTEXPR SolarCapabilityOverride(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCapabilityOverride(const SolarCapabilityOverride& from);
  SolarCapabilityOverride(SolarCapabilityOverride&& from) noexcept
    : SolarCapabilityOverride() {
    *this = ::std::move(from);
  }

  inline SolarCapabilityOverride& operator=(const SolarCapabilityOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCapabilityOverride& operator=(SolarCapabilityOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCapabilityOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCapabilityOverride* internal_default_instance() {
    return reinterpret_cast<const SolarCapabilityOverride*>(
               &_SolarCapabilityOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SolarCapabilityOverride& a, SolarCapabilityOverride& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCapabilityOverride* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCapabilityOverride* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCapabilityOverride* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCapabilityOverride>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCapabilityOverride& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCapabilityOverride& from) {
    SolarCapabilityOverride::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCapabilityOverride* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCapabilityOverride";
  }
  protected:
  explicit SolarCapabilityOverride(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kSolarCapabilityConfigurationFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .solarmodule.SolarCapabilityConfiguration solarCapabilityConfiguration = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarcapabilityconfiguration() const;
  private:
  bool _internal_has_solarcapabilityconfiguration() const;

  public:
  void clear_solarcapabilityconfiguration() ;
  const ::solarmodule::SolarCapabilityConfiguration& solarcapabilityconfiguration() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarCapabilityConfiguration* release_solarcapabilityconfiguration();
  ::solarmodule::SolarCapabilityConfiguration* mutable_solarcapabilityconfiguration();
  void set_allocated_solarcapabilityconfiguration(::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration);
  private:
  const ::solarmodule::SolarCapabilityConfiguration& _internal_solarcapabilityconfiguration() const;
  ::solarmodule::SolarCapabilityConfiguration* _internal_mutable_solarcapabilityconfiguration();
  public:
  void unsafe_arena_set_allocated_solarcapabilityconfiguration(
      ::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration);
  ::solarmodule::SolarCapabilityConfiguration* unsafe_arena_release_solarcapabilityconfiguration();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCapabilityOverride)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCapabilityOverrideProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCapabilityOverrideProfile) */ {
 public:
  inline SolarCapabilityOverrideProfile() : SolarCapabilityOverrideProfile(nullptr) {}
  ~SolarCapabilityOverrideProfile() override;
  explicit PROTOBUF_CONSTEXPR SolarCapabilityOverrideProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCapabilityOverrideProfile(const SolarCapabilityOverrideProfile& from);
  SolarCapabilityOverrideProfile(SolarCapabilityOverrideProfile&& from) noexcept
    : SolarCapabilityOverrideProfile() {
    *this = ::std::move(from);
  }

  inline SolarCapabilityOverrideProfile& operator=(const SolarCapabilityOverrideProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCapabilityOverrideProfile& operator=(SolarCapabilityOverrideProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCapabilityOverrideProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCapabilityOverrideProfile* internal_default_instance() {
    return reinterpret_cast<const SolarCapabilityOverrideProfile*>(
               &_SolarCapabilityOverrideProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SolarCapabilityOverrideProfile& a, SolarCapabilityOverrideProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCapabilityOverrideProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCapabilityOverrideProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCapabilityOverrideProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCapabilityOverrideProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCapabilityOverrideProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCapabilityOverrideProfile& from) {
    SolarCapabilityOverrideProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCapabilityOverrideProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCapabilityOverrideProfile";
  }
  protected:
  explicit SolarCapabilityOverrideProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilityMessageInfoFieldNumber = 1,
    kSolarCapabilityOverrideFieldNumber = 2,
    kSolarInverterFieldNumber = 3,
  };
  // .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_capabilitymessageinfo() const;
  private:
  bool _internal_has_capabilitymessageinfo() const;

  public:
  void clear_capabilitymessageinfo() ;
  const ::commonmodule::CapabilityMessageInfo& capabilitymessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::CapabilityMessageInfo* release_capabilitymessageinfo();
  ::commonmodule::CapabilityMessageInfo* mutable_capabilitymessageinfo();
  void set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  private:
  const ::commonmodule::CapabilityMessageInfo& _internal_capabilitymessageinfo() const;
  ::commonmodule::CapabilityMessageInfo* _internal_mutable_capabilitymessageinfo();
  public:
  void unsafe_arena_set_allocated_capabilitymessageinfo(
      ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  ::commonmodule::CapabilityMessageInfo* unsafe_arena_release_capabilitymessageinfo();
  // .solarmodule.SolarCapabilityOverride solarCapabilityOverride = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarcapabilityoverride() const;
  private:
  bool _internal_has_solarcapabilityoverride() const;

  public:
  void clear_solarcapabilityoverride() ;
  const ::solarmodule::SolarCapabilityOverride& solarcapabilityoverride() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarCapabilityOverride* release_solarcapabilityoverride();
  ::solarmodule::SolarCapabilityOverride* mutable_solarcapabilityoverride();
  void set_allocated_solarcapabilityoverride(::solarmodule::SolarCapabilityOverride* solarcapabilityoverride);
  private:
  const ::solarmodule::SolarCapabilityOverride& _internal_solarcapabilityoverride() const;
  ::solarmodule::SolarCapabilityOverride* _internal_mutable_solarcapabilityoverride();
  public:
  void unsafe_arena_set_allocated_solarcapabilityoverride(
      ::solarmodule::SolarCapabilityOverride* solarcapabilityoverride);
  ::solarmodule::SolarCapabilityOverride* unsafe_arena_release_solarcapabilityoverride();
  // .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  private:
  bool _internal_has_solarinverter() const;

  public:
  void clear_solarinverter() ;
  const ::solarmodule::SolarInverter& solarinverter() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);
  private:
  const ::solarmodule::SolarInverter& _internal_solarinverter() const;
  ::solarmodule::SolarInverter* _internal_mutable_solarinverter();
  public:
  void unsafe_arena_set_allocated_solarinverter(
      ::solarmodule::SolarInverter* solarinverter);
  ::solarmodule::SolarInverter* unsafe_arena_release_solarinverter();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCapabilityOverrideProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo_;
    ::solarmodule::SolarCapabilityOverride* solarcapabilityoverride_;
    ::solarmodule::SolarInverter* solarinverter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCapabilityRatings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCapabilityRatings) */ {
 public:
  inline SolarCapabilityRatings() : SolarCapabilityRatings(nullptr) {}
  ~SolarCapabilityRatings() override;
  explicit PROTOBUF_CONSTEXPR SolarCapabilityRatings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCapabilityRatings(const SolarCapabilityRatings& from);
  SolarCapabilityRatings(SolarCapabilityRatings&& from) noexcept
    : SolarCapabilityRatings() {
    *this = ::std::move(from);
  }

  inline SolarCapabilityRatings& operator=(const SolarCapabilityRatings& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCapabilityRatings& operator=(SolarCapabilityRatings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCapabilityRatings& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCapabilityRatings* internal_default_instance() {
    return reinterpret_cast<const SolarCapabilityRatings*>(
               &_SolarCapabilityRatings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SolarCapabilityRatings& a, SolarCapabilityRatings& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCapabilityRatings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCapabilityRatings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCapabilityRatings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCapabilityRatings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCapabilityRatings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCapabilityRatings& from) {
    SolarCapabilityRatings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCapabilityRatings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCapabilityRatings";
  }
  protected:
  explicit SolarCapabilityRatings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceCapabilityRatingsFieldNumber = 1,
  };
  // .commonmodule.SourceCapabilityRatings sourceCapabilityRatings = 1 [(.uml.option_parent_message) = true];
  bool has_sourcecapabilityratings() const;
  private:
  bool _internal_has_sourcecapabilityratings() const;

  public:
  void clear_sourcecapabilityratings() ;
  const ::commonmodule::SourceCapabilityRatings& sourcecapabilityratings() const;
  PROTOBUF_NODISCARD ::commonmodule::SourceCapabilityRatings* release_sourcecapabilityratings();
  ::commonmodule::SourceCapabilityRatings* mutable_sourcecapabilityratings();
  void set_allocated_sourcecapabilityratings(::commonmodule::SourceCapabilityRatings* sourcecapabilityratings);
  private:
  const ::commonmodule::SourceCapabilityRatings& _internal_sourcecapabilityratings() const;
  ::commonmodule::SourceCapabilityRatings* _internal_mutable_sourcecapabilityratings();
  public:
  void unsafe_arena_set_allocated_sourcecapabilityratings(
      ::commonmodule::SourceCapabilityRatings* sourcecapabilityratings);
  ::commonmodule::SourceCapabilityRatings* unsafe_arena_release_sourcecapabilityratings();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCapabilityRatings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::SourceCapabilityRatings* sourcecapabilityratings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCapability) */ {
 public:
  inline SolarCapability() : SolarCapability(nullptr) {}
  ~SolarCapability() override;
  explicit PROTOBUF_CONSTEXPR SolarCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCapability(const SolarCapability& from);
  SolarCapability(SolarCapability&& from) noexcept
    : SolarCapability() {
    *this = ::std::move(from);
  }

  inline SolarCapability& operator=(const SolarCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCapability& operator=(SolarCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCapability* internal_default_instance() {
    return reinterpret_cast<const SolarCapability*>(
               &_SolarCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SolarCapability& a, SolarCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCapability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCapability& from) {
    SolarCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCapability";
  }
  protected:
  explicit SolarCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameplateValueFieldNumber = 1,
    kSolarCapabilityConfigurationFieldNumber = 2,
    kSolarCapabilityRatingsFieldNumber = 3,
  };
  // .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
  bool has_nameplatevalue() const;
  private:
  bool _internal_has_nameplatevalue() const;

  public:
  void clear_nameplatevalue() ;
  const ::commonmodule::NameplateValue& nameplatevalue() const;
  PROTOBUF_NODISCARD ::commonmodule::NameplateValue* release_nameplatevalue();
  ::commonmodule::NameplateValue* mutable_nameplatevalue();
  void set_allocated_nameplatevalue(::commonmodule::NameplateValue* nameplatevalue);
  private:
  const ::commonmodule::NameplateValue& _internal_nameplatevalue() const;
  ::commonmodule::NameplateValue* _internal_mutable_nameplatevalue();
  public:
  void unsafe_arena_set_allocated_nameplatevalue(
      ::commonmodule::NameplateValue* nameplatevalue);
  ::commonmodule::NameplateValue* unsafe_arena_release_nameplatevalue();
  // .solarmodule.SolarCapabilityConfiguration solarCapabilityConfiguration = 2;
  bool has_solarcapabilityconfiguration() const;
  private:
  bool _internal_has_solarcapabilityconfiguration() const;

  public:
  void clear_solarcapabilityconfiguration() ;
  const ::solarmodule::SolarCapabilityConfiguration& solarcapabilityconfiguration() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarCapabilityConfiguration* release_solarcapabilityconfiguration();
  ::solarmodule::SolarCapabilityConfiguration* mutable_solarcapabilityconfiguration();
  void set_allocated_solarcapabilityconfiguration(::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration);
  private:
  const ::solarmodule::SolarCapabilityConfiguration& _internal_solarcapabilityconfiguration() const;
  ::solarmodule::SolarCapabilityConfiguration* _internal_mutable_solarcapabilityconfiguration();
  public:
  void unsafe_arena_set_allocated_solarcapabilityconfiguration(
      ::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration);
  ::solarmodule::SolarCapabilityConfiguration* unsafe_arena_release_solarcapabilityconfiguration();
  // .solarmodule.SolarCapabilityRatings solarCapabilityRatings = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarcapabilityratings() const;
  private:
  bool _internal_has_solarcapabilityratings() const;

  public:
  void clear_solarcapabilityratings() ;
  const ::solarmodule::SolarCapabilityRatings& solarcapabilityratings() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarCapabilityRatings* release_solarcapabilityratings();
  ::solarmodule::SolarCapabilityRatings* mutable_solarcapabilityratings();
  void set_allocated_solarcapabilityratings(::solarmodule::SolarCapabilityRatings* solarcapabilityratings);
  private:
  const ::solarmodule::SolarCapabilityRatings& _internal_solarcapabilityratings() const;
  ::solarmodule::SolarCapabilityRatings* _internal_mutable_solarcapabilityratings();
  public:
  void unsafe_arena_set_allocated_solarcapabilityratings(
      ::solarmodule::SolarCapabilityRatings* solarcapabilityratings);
  ::solarmodule::SolarCapabilityRatings* unsafe_arena_release_solarcapabilityratings();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::NameplateValue* nameplatevalue_;
    ::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration_;
    ::solarmodule::SolarCapabilityRatings* solarcapabilityratings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCapabilityProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCapabilityProfile) */ {
 public:
  inline SolarCapabilityProfile() : SolarCapabilityProfile(nullptr) {}
  ~SolarCapabilityProfile() override;
  explicit PROTOBUF_CONSTEXPR SolarCapabilityProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCapabilityProfile(const SolarCapabilityProfile& from);
  SolarCapabilityProfile(SolarCapabilityProfile&& from) noexcept
    : SolarCapabilityProfile() {
    *this = ::std::move(from);
  }

  inline SolarCapabilityProfile& operator=(const SolarCapabilityProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCapabilityProfile& operator=(SolarCapabilityProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCapabilityProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCapabilityProfile* internal_default_instance() {
    return reinterpret_cast<const SolarCapabilityProfile*>(
               &_SolarCapabilityProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SolarCapabilityProfile& a, SolarCapabilityProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCapabilityProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCapabilityProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCapabilityProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCapabilityProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCapabilityProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCapabilityProfile& from) {
    SolarCapabilityProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCapabilityProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCapabilityProfile";
  }
  protected:
  explicit SolarCapabilityProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilityMessageInfoFieldNumber = 1,
    kSolarCapabilityFieldNumber = 2,
    kSolarInverterFieldNumber = 3,
  };
  // .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_capabilitymessageinfo() const;
  private:
  bool _internal_has_capabilitymessageinfo() const;

  public:
  void clear_capabilitymessageinfo() ;
  const ::commonmodule::CapabilityMessageInfo& capabilitymessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::CapabilityMessageInfo* release_capabilitymessageinfo();
  ::commonmodule::CapabilityMessageInfo* mutable_capabilitymessageinfo();
  void set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  private:
  const ::commonmodule::CapabilityMessageInfo& _internal_capabilitymessageinfo() const;
  ::commonmodule::CapabilityMessageInfo* _internal_mutable_capabilitymessageinfo();
  public:
  void unsafe_arena_set_allocated_capabilitymessageinfo(
      ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  ::commonmodule::CapabilityMessageInfo* unsafe_arena_release_capabilitymessageinfo();
  // .solarmodule.SolarCapability solarCapability = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarcapability() const;
  private:
  bool _internal_has_solarcapability() const;

  public:
  void clear_solarcapability() ;
  const ::solarmodule::SolarCapability& solarcapability() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarCapability* release_solarcapability();
  ::solarmodule::SolarCapability* mutable_solarcapability();
  void set_allocated_solarcapability(::solarmodule::SolarCapability* solarcapability);
  private:
  const ::solarmodule::SolarCapability& _internal_solarcapability() const;
  ::solarmodule::SolarCapability* _internal_mutable_solarcapability();
  public:
  void unsafe_arena_set_allocated_solarcapability(
      ::solarmodule::SolarCapability* solarcapability);
  ::solarmodule::SolarCapability* unsafe_arena_release_solarcapability();
  // .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  private:
  bool _internal_has_solarinverter() const;

  public:
  void clear_solarinverter() ;
  const ::solarmodule::SolarInverter& solarinverter() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);
  private:
  const ::solarmodule::SolarInverter& _internal_solarinverter() const;
  ::solarmodule::SolarInverter* _internal_mutable_solarinverter();
  public:
  void unsafe_arena_set_allocated_solarinverter(
      ::solarmodule::SolarInverter* solarinverter);
  ::solarmodule::SolarInverter* unsafe_arena_release_solarinverter();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCapabilityProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo_;
    ::solarmodule::SolarCapability* solarcapability_;
    ::solarmodule::SolarInverter* solarinverter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarPoint) */ {
 public:
  inline SolarPoint() : SolarPoint(nullptr) {}
  ~SolarPoint() override;
  explicit PROTOBUF_CONSTEXPR SolarPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarPoint(const SolarPoint& from);
  SolarPoint(SolarPoint&& from) noexcept
    : SolarPoint() {
    *this = ::std::move(from);
  }

  inline SolarPoint& operator=(const SolarPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarPoint& operator=(SolarPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarPoint* internal_default_instance() {
    return reinterpret_cast<const SolarPoint*>(
               &_SolarPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SolarPoint& a, SolarPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarPoint& from) {
    SolarPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarPoint";
  }
  protected:
  explicit SolarPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 2,
    kRampRatesFieldNumber = 5,
    kResetFieldNumber = 8,
    kStateFieldNumber = 9,
    kEnterServiceOperationFieldNumber = 12,
    kHzWOperationFieldNumber = 13,
    kLimitWOperationFieldNumber = 14,
    kPFOperationFieldNumber = 15,
    kTmHzTripOperationFieldNumber = 16,
    kTmVoltTripOperationFieldNumber = 17,
    kVArOperationFieldNumber = 18,
    kVoltVarOperationFieldNumber = 19,
    kVoltWOperationFieldNumber = 20,
    kWVarOperationFieldNumber = 21,
    kBlackStartEnabledFieldNumber = 22,
    kWOperationFieldNumber = 24,
  };
  // .commonmodule.ENG_GridConnectModeKind mode = 2;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;

  public:
  void clear_mode() ;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);
  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_mode() const;
  ::commonmodule::ENG_GridConnectModeKind* _internal_mutable_mode();
  public:
  void unsafe_arena_set_allocated_mode(
      ::commonmodule::ENG_GridConnectModeKind* mode);
  ::commonmodule::ENG_GridConnectModeKind* unsafe_arena_release_mode();
  // .commonmodule.RampRate rampRates = 5;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.ControlSPC reset = 8;
  bool has_reset() const;
  private:
  bool _internal_has_reset() const;

  public:
  void clear_reset() ;
  const ::commonmodule::ControlSPC& reset() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_reset();
  ::commonmodule::ControlSPC* mutable_reset();
  void set_allocated_reset(::commonmodule::ControlSPC* reset);
  private:
  const ::commonmodule::ControlSPC& _internal_reset() const;
  ::commonmodule::ControlSPC* _internal_mutable_reset();
  public:
  void unsafe_arena_set_allocated_reset(
      ::commonmodule::ControlSPC* reset);
  ::commonmodule::ControlSPC* unsafe_arena_release_reset();
  // .commonmodule.Optional_StateKind state = 9;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // .commonmodule.EnterServiceAPC enterServiceOperation = 12;
  bool has_enterserviceoperation() const;
  private:
  bool _internal_has_enterserviceoperation() const;

  public:
  void clear_enterserviceoperation() ;
  const ::commonmodule::EnterServiceAPC& enterserviceoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::EnterServiceAPC* release_enterserviceoperation();
  ::commonmodule::EnterServiceAPC* mutable_enterserviceoperation();
  void set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation);
  private:
  const ::commonmodule::EnterServiceAPC& _internal_enterserviceoperation() const;
  ::commonmodule::EnterServiceAPC* _internal_mutable_enterserviceoperation();
  public:
  void unsafe_arena_set_allocated_enterserviceoperation(
      ::commonmodule::EnterServiceAPC* enterserviceoperation);
  ::commonmodule::EnterServiceAPC* unsafe_arena_release_enterserviceoperation();
  // .commonmodule.HzWAPC hzWOperation = 13;
  bool has_hzwoperation() const;
  private:
  bool _internal_has_hzwoperation() const;

  public:
  void clear_hzwoperation() ;
  const ::commonmodule::HzWAPC& hzwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::HzWAPC* release_hzwoperation();
  ::commonmodule::HzWAPC* mutable_hzwoperation();
  void set_allocated_hzwoperation(::commonmodule::HzWAPC* hzwoperation);
  private:
  const ::commonmodule::HzWAPC& _internal_hzwoperation() const;
  ::commonmodule::HzWAPC* _internal_mutable_hzwoperation();
  public:
  void unsafe_arena_set_allocated_hzwoperation(
      ::commonmodule::HzWAPC* hzwoperation);
  ::commonmodule::HzWAPC* unsafe_arena_release_hzwoperation();
  // .commonmodule.LimitWAPC limitWOperation = 14;
  bool has_limitwoperation() const;
  private:
  bool _internal_has_limitwoperation() const;

  public:
  void clear_limitwoperation() ;
  const ::commonmodule::LimitWAPC& limitwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::LimitWAPC* release_limitwoperation();
  ::commonmodule::LimitWAPC* mutable_limitwoperation();
  void set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation);
  private:
  const ::commonmodule::LimitWAPC& _internal_limitwoperation() const;
  ::commonmodule::LimitWAPC* _internal_mutable_limitwoperation();
  public:
  void unsafe_arena_set_allocated_limitwoperation(
      ::commonmodule::LimitWAPC* limitwoperation);
  ::commonmodule::LimitWAPC* unsafe_arena_release_limitwoperation();
  // .commonmodule.PFSPC pFOperation = 15;
  bool has_pfoperation() const;
  private:
  bool _internal_has_pfoperation() const;

  public:
  void clear_pfoperation() ;
  const ::commonmodule::PFSPC& pfoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::PFSPC* release_pfoperation();
  ::commonmodule::PFSPC* mutable_pfoperation();
  void set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation);
  private:
  const ::commonmodule::PFSPC& _internal_pfoperation() const;
  ::commonmodule::PFSPC* _internal_mutable_pfoperation();
  public:
  void unsafe_arena_set_allocated_pfoperation(
      ::commonmodule::PFSPC* pfoperation);
  ::commonmodule::PFSPC* unsafe_arena_release_pfoperation();
  // .commonmodule.TmHzCSG tmHzTripOperation = 16;
  bool has_tmhztripoperation() const;
  private:
  bool _internal_has_tmhztripoperation() const;

  public:
  void clear_tmhztripoperation() ;
  const ::commonmodule::TmHzCSG& tmhztripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmHzCSG* release_tmhztripoperation();
  ::commonmodule::TmHzCSG* mutable_tmhztripoperation();
  void set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation);
  private:
  const ::commonmodule::TmHzCSG& _internal_tmhztripoperation() const;
  ::commonmodule::TmHzCSG* _internal_mutable_tmhztripoperation();
  public:
  void unsafe_arena_set_allocated_tmhztripoperation(
      ::commonmodule::TmHzCSG* tmhztripoperation);
  ::commonmodule::TmHzCSG* unsafe_arena_release_tmhztripoperation();
  // .commonmodule.TmVoltCSG tmVoltTripOperation = 17;
  bool has_tmvolttripoperation() const;
  private:
  bool _internal_has_tmvolttripoperation() const;

  public:
  void clear_tmvolttripoperation() ;
  const ::commonmodule::TmVoltCSG& tmvolttripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmVoltCSG* release_tmvolttripoperation();
  ::commonmodule::TmVoltCSG* mutable_tmvolttripoperation();
  void set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation);
  private:
  const ::commonmodule::TmVoltCSG& _internal_tmvolttripoperation() const;
  ::commonmodule::TmVoltCSG* _internal_mutable_tmvolttripoperation();
  public:
  void unsafe_arena_set_allocated_tmvolttripoperation(
      ::commonmodule::TmVoltCSG* tmvolttripoperation);
  ::commonmodule::TmVoltCSG* unsafe_arena_release_tmvolttripoperation();
  // .commonmodule.VarSPC vArOperation = 18;
  bool has_varoperation() const;
  private:
  bool _internal_has_varoperation() const;

  public:
  void clear_varoperation() ;
  const ::commonmodule::VarSPC& varoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VarSPC* release_varoperation();
  ::commonmodule::VarSPC* mutable_varoperation();
  void set_allocated_varoperation(::commonmodule::VarSPC* varoperation);
  private:
  const ::commonmodule::VarSPC& _internal_varoperation() const;
  ::commonmodule::VarSPC* _internal_mutable_varoperation();
  public:
  void unsafe_arena_set_allocated_varoperation(
      ::commonmodule::VarSPC* varoperation);
  ::commonmodule::VarSPC* unsafe_arena_release_varoperation();
  // .commonmodule.VoltVarCSG voltVarOperation = 19;
  bool has_voltvaroperation() const;
  private:
  bool _internal_has_voltvaroperation() const;

  public:
  void clear_voltvaroperation() ;
  const ::commonmodule::VoltVarCSG& voltvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltVarCSG* release_voltvaroperation();
  ::commonmodule::VoltVarCSG* mutable_voltvaroperation();
  void set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation);
  private:
  const ::commonmodule::VoltVarCSG& _internal_voltvaroperation() const;
  ::commonmodule::VoltVarCSG* _internal_mutable_voltvaroperation();
  public:
  void unsafe_arena_set_allocated_voltvaroperation(
      ::commonmodule::VoltVarCSG* voltvaroperation);
  ::commonmodule::VoltVarCSG* unsafe_arena_release_voltvaroperation();
  // .commonmodule.VoltWCSG voltWOperation = 20;
  bool has_voltwoperation() const;
  private:
  bool _internal_has_voltwoperation() const;

  public:
  void clear_voltwoperation() ;
  const ::commonmodule::VoltWCSG& voltwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltWCSG* release_voltwoperation();
  ::commonmodule::VoltWCSG* mutable_voltwoperation();
  void set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation);
  private:
  const ::commonmodule::VoltWCSG& _internal_voltwoperation() const;
  ::commonmodule::VoltWCSG* _internal_mutable_voltwoperation();
  public:
  void unsafe_arena_set_allocated_voltwoperation(
      ::commonmodule::VoltWCSG* voltwoperation);
  ::commonmodule::VoltWCSG* unsafe_arena_release_voltwoperation();
  // .commonmodule.WVarCSG wVarOperation = 21;
  bool has_wvaroperation() const;
  private:
  bool _internal_has_wvaroperation() const;

  public:
  void clear_wvaroperation() ;
  const ::commonmodule::WVarCSG& wvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::WVarCSG* release_wvaroperation();
  ::commonmodule::WVarCSG* mutable_wvaroperation();
  void set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation);
  private:
  const ::commonmodule::WVarCSG& _internal_wvaroperation() const;
  ::commonmodule::WVarCSG* _internal_mutable_wvaroperation();
  public:
  void unsafe_arena_set_allocated_wvaroperation(
      ::commonmodule::WVarCSG* wvaroperation);
  ::commonmodule::WVarCSG* unsafe_arena_release_wvaroperation();
  // .commonmodule.ControlSPC blackStartEnabled = 22;
  bool has_blackstartenabled() const;
  private:
  bool _internal_has_blackstartenabled() const;

  public:
  void clear_blackstartenabled() ;
  const ::commonmodule::ControlSPC& blackstartenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_blackstartenabled();
  ::commonmodule::ControlSPC* mutable_blackstartenabled();
  void set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_blackstartenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_blackstartenabled();
  public:
  void unsafe_arena_set_allocated_blackstartenabled(
      ::commonmodule::ControlSPC* blackstartenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_blackstartenabled();
  // .commonmodule.WSPC wOperation = 24;
  bool has_woperation() const;
  private:
  bool _internal_has_woperation() const;

  public:
  void clear_woperation() ;
  const ::commonmodule::WSPC& woperation() const;
  PROTOBUF_NODISCARD ::commonmodule::WSPC* release_woperation();
  ::commonmodule::WSPC* mutable_woperation();
  void set_allocated_woperation(::commonmodule::WSPC* woperation);
  private:
  const ::commonmodule::WSPC& _internal_woperation() const;
  ::commonmodule::WSPC* _internal_mutable_woperation();
  public:
  void unsafe_arena_set_allocated_woperation(
      ::commonmodule::WSPC* woperation);
  ::commonmodule::WSPC* unsafe_arena_release_woperation();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ENG_GridConnectModeKind* mode_;
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::ControlSPC* reset_;
    ::commonmodule::Optional_StateKind* state_;
    ::commonmodule::EnterServiceAPC* enterserviceoperation_;
    ::commonmodule::HzWAPC* hzwoperation_;
    ::commonmodule::LimitWAPC* limitwoperation_;
    ::commonmodule::PFSPC* pfoperation_;
    ::commonmodule::TmHzCSG* tmhztripoperation_;
    ::commonmodule::TmVoltCSG* tmvolttripoperation_;
    ::commonmodule::VarSPC* varoperation_;
    ::commonmodule::VoltVarCSG* voltvaroperation_;
    ::commonmodule::VoltWCSG* voltwoperation_;
    ::commonmodule::WVarCSG* wvaroperation_;
    ::commonmodule::ControlSPC* blackstartenabled_;
    ::commonmodule::WSPC* woperation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCurvePoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCurvePoint) */ {
 public:
  inline SolarCurvePoint() : SolarCurvePoint(nullptr) {}
  ~SolarCurvePoint() override;
  explicit PROTOBUF_CONSTEXPR SolarCurvePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCurvePoint(const SolarCurvePoint& from);
  SolarCurvePoint(SolarCurvePoint&& from) noexcept
    : SolarCurvePoint() {
    *this = ::std::move(from);
  }

  inline SolarCurvePoint& operator=(const SolarCurvePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCurvePoint& operator=(SolarCurvePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCurvePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCurvePoint* internal_default_instance() {
    return reinterpret_cast<const SolarCurvePoint*>(
               &_SolarCurvePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SolarCurvePoint& a, SolarCurvePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCurvePoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCurvePoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCurvePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCurvePoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCurvePoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCurvePoint& from) {
    SolarCurvePoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCurvePoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCurvePoint";
  }
  protected:
  explicit SolarCurvePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFieldNumber = 1,
    kStartTimeFieldNumber = 2,
  };
  // .solarmodule.SolarPoint control = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_control() const;
  private:
  bool _internal_has_control() const;

  public:
  void clear_control() ;
  const ::solarmodule::SolarPoint& control() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarPoint* release_control();
  ::solarmodule::SolarPoint* mutable_control();
  void set_allocated_control(::solarmodule::SolarPoint* control);
  private:
  const ::solarmodule::SolarPoint& _internal_control() const;
  ::solarmodule::SolarPoint* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::solarmodule::SolarPoint* control);
  ::solarmodule::SolarPoint* unsafe_arena_release_control();
  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;

  public:
  void clear_starttime() ;
  const ::commonmodule::ControlTimestamp& starttime() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);
  private:
  const ::commonmodule::ControlTimestamp& _internal_starttime() const;
  ::commonmodule::ControlTimestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::commonmodule::ControlTimestamp* starttime);
  ::commonmodule::ControlTimestamp* unsafe_arena_release_starttime();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCurvePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::solarmodule::SolarPoint* control_;
    ::commonmodule::ControlTimestamp* starttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarCSG) */ {
 public:
  inline SolarCSG() : SolarCSG(nullptr) {}
  ~SolarCSG() override;
  explicit PROTOBUF_CONSTEXPR SolarCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarCSG(const SolarCSG& from);
  SolarCSG(SolarCSG&& from) noexcept
    : SolarCSG() {
    *this = ::std::move(from);
  }

  inline SolarCSG& operator=(const SolarCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarCSG& operator=(SolarCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarCSG* internal_default_instance() {
    return reinterpret_cast<const SolarCSG*>(
               &_SolarCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SolarCSG& a, SolarCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarCSG& from) {
    SolarCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarCSG";
  }
  protected:
  explicit SolarCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .solarmodule.SolarCurvePoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::solarmodule::SolarCurvePoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::solarmodule::SolarCurvePoint >*
      mutable_crvpts();
  private:
  const ::solarmodule::SolarCurvePoint& _internal_crvpts(int index) const;
  ::solarmodule::SolarCurvePoint* _internal_add_crvpts();
  public:
  const ::solarmodule::SolarCurvePoint& crvpts(int index) const;
  ::solarmodule::SolarCurvePoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::solarmodule::SolarCurvePoint >&
      crvpts() const;
  // @@protoc_insertion_point(class_scope:solarmodule.SolarCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::solarmodule::SolarCurvePoint > crvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarControlScheduleFSCH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControlScheduleFSCH) */ {
 public:
  inline SolarControlScheduleFSCH() : SolarControlScheduleFSCH(nullptr) {}
  ~SolarControlScheduleFSCH() override;
  explicit PROTOBUF_CONSTEXPR SolarControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarControlScheduleFSCH(const SolarControlScheduleFSCH& from);
  SolarControlScheduleFSCH(SolarControlScheduleFSCH&& from) noexcept
    : SolarControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline SolarControlScheduleFSCH& operator=(const SolarControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarControlScheduleFSCH& operator=(SolarControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarControlScheduleFSCH& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const SolarControlScheduleFSCH*>(
               &_SolarControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SolarControlScheduleFSCH& a, SolarControlScheduleFSCH& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarControlScheduleFSCH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarControlScheduleFSCH* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarControlScheduleFSCH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarControlScheduleFSCH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarControlScheduleFSCH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarControlScheduleFSCH& from) {
    SolarControlScheduleFSCH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControlScheduleFSCH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarControlScheduleFSCH";
  }
  protected:
  explicit SolarControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValDCSGFieldNumber = 1,
  };
  // .solarmodule.SolarCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  private:
  bool _internal_has_valdcsg() const;

  public:
  void clear_valdcsg() ;
  const ::solarmodule::SolarCSG& valdcsg() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarCSG* release_valdcsg();
  ::solarmodule::SolarCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::solarmodule::SolarCSG* valdcsg);
  private:
  const ::solarmodule::SolarCSG& _internal_valdcsg() const;
  ::solarmodule::SolarCSG* _internal_mutable_valdcsg();
  public:
  void unsafe_arena_set_allocated_valdcsg(
      ::solarmodule::SolarCSG* valdcsg);
  ::solarmodule::SolarCSG* unsafe_arena_release_valdcsg();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarControlScheduleFSCH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::solarmodule::SolarCSG* valdcsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarControlFSCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControlFSCC) */ {
 public:
  inline SolarControlFSCC() : SolarControlFSCC(nullptr) {}
  ~SolarControlFSCC() override;
  explicit PROTOBUF_CONSTEXPR SolarControlFSCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarControlFSCC(const SolarControlFSCC& from);
  SolarControlFSCC(SolarControlFSCC&& from) noexcept
    : SolarControlFSCC() {
    *this = ::std::move(from);
  }

  inline SolarControlFSCC& operator=(const SolarControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarControlFSCC& operator=(SolarControlFSCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarControlFSCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarControlFSCC* internal_default_instance() {
    return reinterpret_cast<const SolarControlFSCC*>(
               &_SolarControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SolarControlFSCC& a, SolarControlFSCC& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarControlFSCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarControlFSCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarControlFSCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarControlFSCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarControlFSCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarControlFSCC& from) {
    SolarControlFSCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControlFSCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarControlFSCC";
  }
  protected:
  explicit SolarControlFSCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFSCCFieldNumber = 1,
    kSolarControlScheduleFSCHFieldNumber = 2,
  };
  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  private:
  bool _internal_has_controlfscc() const;

  public:
  void clear_controlfscc() ;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);
  private:
  const ::commonmodule::ControlFSCC& _internal_controlfscc() const;
  ::commonmodule::ControlFSCC* _internal_mutable_controlfscc();
  public:
  void unsafe_arena_set_allocated_controlfscc(
      ::commonmodule::ControlFSCC* controlfscc);
  ::commonmodule::ControlFSCC* unsafe_arena_release_controlfscc();
  // .solarmodule.SolarControlScheduleFSCH SolarControlScheduleFSCH = 2;
  bool has_solarcontrolschedulefsch() const;
  private:
  bool _internal_has_solarcontrolschedulefsch() const;

  public:
  void clear_solarcontrolschedulefsch() ;
  const ::solarmodule::SolarControlScheduleFSCH& solarcontrolschedulefsch() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarControlScheduleFSCH* release_solarcontrolschedulefsch();
  ::solarmodule::SolarControlScheduleFSCH* mutable_solarcontrolschedulefsch();
  void set_allocated_solarcontrolschedulefsch(::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch);
  private:
  const ::solarmodule::SolarControlScheduleFSCH& _internal_solarcontrolschedulefsch() const;
  ::solarmodule::SolarControlScheduleFSCH* _internal_mutable_solarcontrolschedulefsch();
  public:
  void unsafe_arena_set_allocated_solarcontrolschedulefsch(
      ::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch);
  ::solarmodule::SolarControlScheduleFSCH* unsafe_arena_release_solarcontrolschedulefsch();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarControlFSCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlFSCC* controlfscc_;
    ::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControl) */ {
 public:
  inline SolarControl() : SolarControl(nullptr) {}
  ~SolarControl() override;
  explicit PROTOBUF_CONSTEXPR SolarControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarControl(const SolarControl& from);
  SolarControl(SolarControl&& from) noexcept
    : SolarControl() {
    *this = ::std::move(from);
  }

  inline SolarControl& operator=(const SolarControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarControl& operator=(SolarControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarControl* internal_default_instance() {
    return reinterpret_cast<const SolarControl*>(
               &_SolarControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SolarControl& a, SolarControl& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarControl& from) {
    SolarControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarControl";
  }
  protected:
  explicit SolarControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kSolarControlFSCCFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .solarmodule.SolarControlFSCC solarControlFSCC = 3;
  bool has_solarcontrolfscc() const;
  private:
  bool _internal_has_solarcontrolfscc() const;

  public:
  void clear_solarcontrolfscc() ;
  const ::solarmodule::SolarControlFSCC& solarcontrolfscc() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarControlFSCC* release_solarcontrolfscc();
  ::solarmodule::SolarControlFSCC* mutable_solarcontrolfscc();
  void set_allocated_solarcontrolfscc(::solarmodule::SolarControlFSCC* solarcontrolfscc);
  private:
  const ::solarmodule::SolarControlFSCC& _internal_solarcontrolfscc() const;
  ::solarmodule::SolarControlFSCC* _internal_mutable_solarcontrolfscc();
  public:
  void unsafe_arena_set_allocated_solarcontrolfscc(
      ::solarmodule::SolarControlFSCC* solarcontrolfscc);
  ::solarmodule::SolarControlFSCC* unsafe_arena_release_solarcontrolfscc();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::solarmodule::SolarControlFSCC* solarcontrolfscc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarControlProfile) */ {
 public:
  inline SolarControlProfile() : SolarControlProfile(nullptr) {}
  ~SolarControlProfile() override;
  explicit PROTOBUF_CONSTEXPR SolarControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarControlProfile(const SolarControlProfile& from);
  SolarControlProfile(SolarControlProfile&& from) noexcept
    : SolarControlProfile() {
    *this = ::std::move(from);
  }

  inline SolarControlProfile& operator=(const SolarControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarControlProfile& operator=(SolarControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarControlProfile* internal_default_instance() {
    return reinterpret_cast<const SolarControlProfile*>(
               &_SolarControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SolarControlProfile& a, SolarControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarControlProfile& from) {
    SolarControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarControlProfile";
  }
  protected:
  explicit SolarControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kSolarControlFieldNumber = 2,
    kSolarInverterFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .solarmodule.SolarControl solarControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarcontrol() const;
  private:
  bool _internal_has_solarcontrol() const;

  public:
  void clear_solarcontrol() ;
  const ::solarmodule::SolarControl& solarcontrol() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarControl* release_solarcontrol();
  ::solarmodule::SolarControl* mutable_solarcontrol();
  void set_allocated_solarcontrol(::solarmodule::SolarControl* solarcontrol);
  private:
  const ::solarmodule::SolarControl& _internal_solarcontrol() const;
  ::solarmodule::SolarControl* _internal_mutable_solarcontrol();
  public:
  void unsafe_arena_set_allocated_solarcontrol(
      ::solarmodule::SolarControl* solarcontrol);
  ::solarmodule::SolarControl* unsafe_arena_release_solarcontrol();
  // .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  private:
  bool _internal_has_solarinverter() const;

  public:
  void clear_solarinverter() ;
  const ::solarmodule::SolarInverter& solarinverter() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);
  private:
  const ::solarmodule::SolarInverter& _internal_solarinverter() const;
  ::solarmodule::SolarInverter* _internal_mutable_solarinverter();
  public:
  void unsafe_arena_set_allocated_solarinverter(
      ::solarmodule::SolarInverter* solarinverter);
  ::solarmodule::SolarInverter* unsafe_arena_release_solarinverter();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::solarmodule::SolarControl* solarcontrol_;
    ::solarmodule::SolarInverter* solarinverter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarDiscreteControlPV final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarDiscreteControlPV) */ {
 public:
  inline SolarDiscreteControlPV() : SolarDiscreteControlPV(nullptr) {}
  ~SolarDiscreteControlPV() override;
  explicit PROTOBUF_CONSTEXPR SolarDiscreteControlPV(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarDiscreteControlPV(const SolarDiscreteControlPV& from);
  SolarDiscreteControlPV(SolarDiscreteControlPV&& from) noexcept
    : SolarDiscreteControlPV() {
    *this = ::std::move(from);
  }

  inline SolarDiscreteControlPV& operator=(const SolarDiscreteControlPV& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarDiscreteControlPV& operator=(SolarDiscreteControlPV&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarDiscreteControlPV& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarDiscreteControlPV* internal_default_instance() {
    return reinterpret_cast<const SolarDiscreteControlPV*>(
               &_SolarDiscreteControlPV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SolarDiscreteControlPV& a, SolarDiscreteControlPV& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarDiscreteControlPV* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarDiscreteControlPV* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarDiscreteControlPV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarDiscreteControlPV>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarDiscreteControlPV& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarDiscreteControlPV& from) {
    SolarDiscreteControlPV::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarDiscreteControlPV* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarDiscreteControlPV";
  }
  protected:
  explicit SolarDiscreteControlPV(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kControlFieldNumber = 2,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;

  public:
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();
  // .solarmodule.SolarPoint control = 2;
  bool has_control() const;
  private:
  bool _internal_has_control() const;

  public:
  void clear_control() ;
  const ::solarmodule::SolarPoint& control() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarPoint* release_control();
  ::solarmodule::SolarPoint* mutable_control();
  void set_allocated_control(::solarmodule::SolarPoint* control);
  private:
  const ::solarmodule::SolarPoint& _internal_control() const;
  ::solarmodule::SolarPoint* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::solarmodule::SolarPoint* control);
  ::solarmodule::SolarPoint* unsafe_arena_release_control();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarDiscreteControlPV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
    ::solarmodule::SolarPoint* control_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarDiscreteControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarDiscreteControl) */ {
 public:
  inline SolarDiscreteControl() : SolarDiscreteControl(nullptr) {}
  ~SolarDiscreteControl() override;
  explicit PROTOBUF_CONSTEXPR SolarDiscreteControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarDiscreteControl(const SolarDiscreteControl& from);
  SolarDiscreteControl(SolarDiscreteControl&& from) noexcept
    : SolarDiscreteControl() {
    *this = ::std::move(from);
  }

  inline SolarDiscreteControl& operator=(const SolarDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarDiscreteControl& operator=(SolarDiscreteControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarDiscreteControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarDiscreteControl* internal_default_instance() {
    return reinterpret_cast<const SolarDiscreteControl*>(
               &_SolarDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SolarDiscreteControl& a, SolarDiscreteControl& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarDiscreteControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarDiscreteControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarDiscreteControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarDiscreteControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarDiscreteControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarDiscreteControl& from) {
    SolarDiscreteControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarDiscreteControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarDiscreteControl";
  }
  protected:
  explicit SolarDiscreteControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kSolarDiscreteControlPVFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .solarmodule.SolarDiscreteControlPV solarDiscreteControlPV = 3;
  bool has_solardiscretecontrolpv() const;
  private:
  bool _internal_has_solardiscretecontrolpv() const;

  public:
  void clear_solardiscretecontrolpv() ;
  const ::solarmodule::SolarDiscreteControlPV& solardiscretecontrolpv() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarDiscreteControlPV* release_solardiscretecontrolpv();
  ::solarmodule::SolarDiscreteControlPV* mutable_solardiscretecontrolpv();
  void set_allocated_solardiscretecontrolpv(::solarmodule::SolarDiscreteControlPV* solardiscretecontrolpv);
  private:
  const ::solarmodule::SolarDiscreteControlPV& _internal_solardiscretecontrolpv() const;
  ::solarmodule::SolarDiscreteControlPV* _internal_mutable_solardiscretecontrolpv();
  public:
  void unsafe_arena_set_allocated_solardiscretecontrolpv(
      ::solarmodule::SolarDiscreteControlPV* solardiscretecontrolpv);
  ::solarmodule::SolarDiscreteControlPV* unsafe_arena_release_solardiscretecontrolpv();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarDiscreteControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::solarmodule::SolarDiscreteControlPV* solardiscretecontrolpv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarDiscreteControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarDiscreteControlProfile) */ {
 public:
  inline SolarDiscreteControlProfile() : SolarDiscreteControlProfile(nullptr) {}
  ~SolarDiscreteControlProfile() override;
  explicit PROTOBUF_CONSTEXPR SolarDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarDiscreteControlProfile(const SolarDiscreteControlProfile& from);
  SolarDiscreteControlProfile(SolarDiscreteControlProfile&& from) noexcept
    : SolarDiscreteControlProfile() {
    *this = ::std::move(from);
  }

  inline SolarDiscreteControlProfile& operator=(const SolarDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarDiscreteControlProfile& operator=(SolarDiscreteControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarDiscreteControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarDiscreteControlProfile* internal_default_instance() {
    return reinterpret_cast<const SolarDiscreteControlProfile*>(
               &_SolarDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SolarDiscreteControlProfile& a, SolarDiscreteControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarDiscreteControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarDiscreteControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarDiscreteControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarDiscreteControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarDiscreteControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarDiscreteControlProfile& from) {
    SolarDiscreteControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarDiscreteControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarDiscreteControlProfile";
  }
  protected:
  explicit SolarDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kSolarDiscreteControlFieldNumber = 2,
    kSolarInverterFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .solarmodule.SolarDiscreteControl solarDiscreteControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solardiscretecontrol() const;
  private:
  bool _internal_has_solardiscretecontrol() const;

  public:
  void clear_solardiscretecontrol() ;
  const ::solarmodule::SolarDiscreteControl& solardiscretecontrol() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarDiscreteControl* release_solardiscretecontrol();
  ::solarmodule::SolarDiscreteControl* mutable_solardiscretecontrol();
  void set_allocated_solardiscretecontrol(::solarmodule::SolarDiscreteControl* solardiscretecontrol);
  private:
  const ::solarmodule::SolarDiscreteControl& _internal_solardiscretecontrol() const;
  ::solarmodule::SolarDiscreteControl* _internal_mutable_solardiscretecontrol();
  public:
  void unsafe_arena_set_allocated_solardiscretecontrol(
      ::solarmodule::SolarDiscreteControl* solardiscretecontrol);
  ::solarmodule::SolarDiscreteControl* unsafe_arena_release_solardiscretecontrol();
  // .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  private:
  bool _internal_has_solarinverter() const;

  public:
  void clear_solarinverter() ;
  const ::solarmodule::SolarInverter& solarinverter() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);
  private:
  const ::solarmodule::SolarInverter& _internal_solarinverter() const;
  ::solarmodule::SolarInverter* _internal_mutable_solarinverter();
  public:
  void unsafe_arena_set_allocated_solarinverter(
      ::solarmodule::SolarInverter* solarinverter);
  ::solarmodule::SolarInverter* unsafe_arena_release_solarinverter();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarDiscreteControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::solarmodule::SolarDiscreteControl* solardiscretecontrol_;
    ::solarmodule::SolarInverter* solarinverter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarPointStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarPointStatus) */ {
 public:
  inline SolarPointStatus() : SolarPointStatus(nullptr) {}
  ~SolarPointStatus() override;
  explicit PROTOBUF_CONSTEXPR SolarPointStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarPointStatus(const SolarPointStatus& from);
  SolarPointStatus(SolarPointStatus&& from) noexcept
    : SolarPointStatus() {
    *this = ::std::move(from);
  }

  inline SolarPointStatus& operator=(const SolarPointStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarPointStatus& operator=(SolarPointStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarPointStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarPointStatus* internal_default_instance() {
    return reinterpret_cast<const SolarPointStatus*>(
               &_SolarPointStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SolarPointStatus& a, SolarPointStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarPointStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarPointStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarPointStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarPointStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarPointStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarPointStatus& from) {
    SolarPointStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarPointStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarPointStatus";
  }
  protected:
  explicit SolarPointStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencySetPointEnabledFieldNumber = 1,
    kModeFieldNumber = 2,
    kPctHzDroopFieldNumber = 3,
    kPctVDroopFieldNumber = 4,
    kRampRatesFieldNumber = 5,
    kReactivePwrSetPointEnabledFieldNumber = 6,
    kRealPwrSetPointEnabledFieldNumber = 7,
    kStateFieldNumber = 8,
    kVoltageSetPointEnabledFieldNumber = 9,
    kBlackStartEnabledFieldNumber = 10,
    kEnterServiceOperationFieldNumber = 11,
    kHzWOperationFieldNumber = 12,
    kLimitWOperationFieldNumber = 13,
    kPFOperationFieldNumber = 14,
    kSyncBackToGridFieldNumber = 15,
    kTmHzTripOperationFieldNumber = 16,
    kTmVoltTripOperationFieldNumber = 17,
    kVArOperationFieldNumber = 18,
    kVoltVarOperationFieldNumber = 19,
    kVoltWOperationFieldNumber = 20,
    kWVarOperationFieldNumber = 21,
  };
  // .commonmodule.StatusSPS frequencySetPointEnabled = 1;
  bool has_frequencysetpointenabled() const;
  private:
  bool _internal_has_frequencysetpointenabled() const;

  public:
  void clear_frequencysetpointenabled() ;
  const ::commonmodule::StatusSPS& frequencysetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_frequencysetpointenabled();
  ::commonmodule::StatusSPS* mutable_frequencysetpointenabled();
  void set_allocated_frequencysetpointenabled(::commonmodule::StatusSPS* frequencysetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_frequencysetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_frequencysetpointenabled();
  public:
  void unsafe_arena_set_allocated_frequencysetpointenabled(
      ::commonmodule::StatusSPS* frequencysetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_frequencysetpointenabled();
  // .commonmodule.ENG_GridConnectModeKind mode = 2;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;

  public:
  void clear_mode() ;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);
  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_mode() const;
  ::commonmodule::ENG_GridConnectModeKind* _internal_mutable_mode();
  public:
  void unsafe_arena_set_allocated_mode(
      ::commonmodule::ENG_GridConnectModeKind* mode);
  ::commonmodule::ENG_GridConnectModeKind* unsafe_arena_release_mode();
  // .google.protobuf.FloatValue pctHzDroop = 3;
  bool has_pcthzdroop() const;
  private:
  bool _internal_has_pcthzdroop() const;

  public:
  void clear_pcthzdroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pcthzdroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pcthzdroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pcthzdroop();
  void set_allocated_pcthzdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pcthzdroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pcthzdroop();
  public:
  void unsafe_arena_set_allocated_pcthzdroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pcthzdroop();
  // .google.protobuf.FloatValue pctVDroop = 4;
  bool has_pctvdroop() const;
  private:
  bool _internal_has_pctvdroop() const;

  public:
  void clear_pctvdroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pctvdroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pctvdroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pctvdroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pctvdroop();
  public:
  void unsafe_arena_set_allocated_pctvdroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pctvdroop();
  // .commonmodule.RampRate rampRates = 5;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.StatusSPS reactivePwrSetPointEnabled = 6;
  bool has_reactivepwrsetpointenabled() const;
  private:
  bool _internal_has_reactivepwrsetpointenabled() const;

  public:
  void clear_reactivepwrsetpointenabled() ;
  const ::commonmodule::StatusSPS& reactivepwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_reactivepwrsetpointenabled();
  ::commonmodule::StatusSPS* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPS* reactivepwrsetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_reactivepwrsetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_reactivepwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_reactivepwrsetpointenabled(
      ::commonmodule::StatusSPS* reactivepwrsetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_reactivepwrsetpointenabled();
  // .commonmodule.StatusSPS realPwrSetPointEnabled = 7;
  bool has_realpwrsetpointenabled() const;
  private:
  bool _internal_has_realpwrsetpointenabled() const;

  public:
  void clear_realpwrsetpointenabled() ;
  const ::commonmodule::StatusSPS& realpwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_realpwrsetpointenabled();
  ::commonmodule::StatusSPS* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::StatusSPS* realpwrsetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_realpwrsetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_realpwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_realpwrsetpointenabled(
      ::commonmodule::StatusSPS* realpwrsetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_realpwrsetpointenabled();
  // .commonmodule.Optional_StateKind state = 8;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // .commonmodule.StatusSPS voltageSetPointEnabled = 9;
  bool has_voltagesetpointenabled() const;
  private:
  bool _internal_has_voltagesetpointenabled() const;

  public:
  void clear_voltagesetpointenabled() ;
  const ::commonmodule::StatusSPS& voltagesetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_voltagesetpointenabled();
  ::commonmodule::StatusSPS* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* voltagesetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_voltagesetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_voltagesetpointenabled();
  public:
  void unsafe_arena_set_allocated_voltagesetpointenabled(
      ::commonmodule::StatusSPS* voltagesetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_voltagesetpointenabled();
  // .commonmodule.ControlSPC blackStartEnabled = 10;
  bool has_blackstartenabled() const;
  private:
  bool _internal_has_blackstartenabled() const;

  public:
  void clear_blackstartenabled() ;
  const ::commonmodule::ControlSPC& blackstartenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_blackstartenabled();
  ::commonmodule::ControlSPC* mutable_blackstartenabled();
  void set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_blackstartenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_blackstartenabled();
  public:
  void unsafe_arena_set_allocated_blackstartenabled(
      ::commonmodule::ControlSPC* blackstartenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_blackstartenabled();
  // .commonmodule.EnterServiceAPC enterServiceOperation = 11;
  bool has_enterserviceoperation() const;
  private:
  bool _internal_has_enterserviceoperation() const;

  public:
  void clear_enterserviceoperation() ;
  const ::commonmodule::EnterServiceAPC& enterserviceoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::EnterServiceAPC* release_enterserviceoperation();
  ::commonmodule::EnterServiceAPC* mutable_enterserviceoperation();
  void set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation);
  private:
  const ::commonmodule::EnterServiceAPC& _internal_enterserviceoperation() const;
  ::commonmodule::EnterServiceAPC* _internal_mutable_enterserviceoperation();
  public:
  void unsafe_arena_set_allocated_enterserviceoperation(
      ::commonmodule::EnterServiceAPC* enterserviceoperation);
  ::commonmodule::EnterServiceAPC* unsafe_arena_release_enterserviceoperation();
  // .commonmodule.HzWPoint hzWOperation = 12;
  bool has_hzwoperation() const;
  private:
  bool _internal_has_hzwoperation() const;

  public:
  void clear_hzwoperation() ;
  const ::commonmodule::HzWPoint& hzwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::HzWPoint* release_hzwoperation();
  ::commonmodule::HzWPoint* mutable_hzwoperation();
  void set_allocated_hzwoperation(::commonmodule::HzWPoint* hzwoperation);
  private:
  const ::commonmodule::HzWPoint& _internal_hzwoperation() const;
  ::commonmodule::HzWPoint* _internal_mutable_hzwoperation();
  public:
  void unsafe_arena_set_allocated_hzwoperation(
      ::commonmodule::HzWPoint* hzwoperation);
  ::commonmodule::HzWPoint* unsafe_arena_release_hzwoperation();
  // .commonmodule.LimitWAPC limitWOperation = 13;
  bool has_limitwoperation() const;
  private:
  bool _internal_has_limitwoperation() const;

  public:
  void clear_limitwoperation() ;
  const ::commonmodule::LimitWAPC& limitwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::LimitWAPC* release_limitwoperation();
  ::commonmodule::LimitWAPC* mutable_limitwoperation();
  void set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation);
  private:
  const ::commonmodule::LimitWAPC& _internal_limitwoperation() const;
  ::commonmodule::LimitWAPC* _internal_mutable_limitwoperation();
  public:
  void unsafe_arena_set_allocated_limitwoperation(
      ::commonmodule::LimitWAPC* limitwoperation);
  ::commonmodule::LimitWAPC* unsafe_arena_release_limitwoperation();
  // .commonmodule.PFSPC pFOperation = 14;
  bool has_pfoperation() const;
  private:
  bool _internal_has_pfoperation() const;

  public:
  void clear_pfoperation() ;
  const ::commonmodule::PFSPC& pfoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::PFSPC* release_pfoperation();
  ::commonmodule::PFSPC* mutable_pfoperation();
  void set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation);
  private:
  const ::commonmodule::PFSPC& _internal_pfoperation() const;
  ::commonmodule::PFSPC* _internal_mutable_pfoperation();
  public:
  void unsafe_arena_set_allocated_pfoperation(
      ::commonmodule::PFSPC* pfoperation);
  ::commonmodule::PFSPC* unsafe_arena_release_pfoperation();
  // .commonmodule.ControlSPC syncBackToGrid = 15;
  bool has_syncbacktogrid() const;
  private:
  bool _internal_has_syncbacktogrid() const;

  public:
  void clear_syncbacktogrid() ;
  const ::commonmodule::ControlSPC& syncbacktogrid() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_syncbacktogrid();
  ::commonmodule::ControlSPC* mutable_syncbacktogrid();
  void set_allocated_syncbacktogrid(::commonmodule::ControlSPC* syncbacktogrid);
  private:
  const ::commonmodule::ControlSPC& _internal_syncbacktogrid() const;
  ::commonmodule::ControlSPC* _internal_mutable_syncbacktogrid();
  public:
  void unsafe_arena_set_allocated_syncbacktogrid(
      ::commonmodule::ControlSPC* syncbacktogrid);
  ::commonmodule::ControlSPC* unsafe_arena_release_syncbacktogrid();
  // .commonmodule.TmHzCSG tmHzTripOperation = 16;
  bool has_tmhztripoperation() const;
  private:
  bool _internal_has_tmhztripoperation() const;

  public:
  void clear_tmhztripoperation() ;
  const ::commonmodule::TmHzCSG& tmhztripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmHzCSG* release_tmhztripoperation();
  ::commonmodule::TmHzCSG* mutable_tmhztripoperation();
  void set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation);
  private:
  const ::commonmodule::TmHzCSG& _internal_tmhztripoperation() const;
  ::commonmodule::TmHzCSG* _internal_mutable_tmhztripoperation();
  public:
  void unsafe_arena_set_allocated_tmhztripoperation(
      ::commonmodule::TmHzCSG* tmhztripoperation);
  ::commonmodule::TmHzCSG* unsafe_arena_release_tmhztripoperation();
  // .commonmodule.TmVoltCSG tmVoltTripOperation = 17;
  bool has_tmvolttripoperation() const;
  private:
  bool _internal_has_tmvolttripoperation() const;

  public:
  void clear_tmvolttripoperation() ;
  const ::commonmodule::TmVoltCSG& tmvolttripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmVoltCSG* release_tmvolttripoperation();
  ::commonmodule::TmVoltCSG* mutable_tmvolttripoperation();
  void set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation);
  private:
  const ::commonmodule::TmVoltCSG& _internal_tmvolttripoperation() const;
  ::commonmodule::TmVoltCSG* _internal_mutable_tmvolttripoperation();
  public:
  void unsafe_arena_set_allocated_tmvolttripoperation(
      ::commonmodule::TmVoltCSG* tmvolttripoperation);
  ::commonmodule::TmVoltCSG* unsafe_arena_release_tmvolttripoperation();
  // .commonmodule.VarSPC vArOperation = 18;
  bool has_varoperation() const;
  private:
  bool _internal_has_varoperation() const;

  public:
  void clear_varoperation() ;
  const ::commonmodule::VarSPC& varoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VarSPC* release_varoperation();
  ::commonmodule::VarSPC* mutable_varoperation();
  void set_allocated_varoperation(::commonmodule::VarSPC* varoperation);
  private:
  const ::commonmodule::VarSPC& _internal_varoperation() const;
  ::commonmodule::VarSPC* _internal_mutable_varoperation();
  public:
  void unsafe_arena_set_allocated_varoperation(
      ::commonmodule::VarSPC* varoperation);
  ::commonmodule::VarSPC* unsafe_arena_release_varoperation();
  // .commonmodule.VoltVarCSG voltVarOperation = 19;
  bool has_voltvaroperation() const;
  private:
  bool _internal_has_voltvaroperation() const;

  public:
  void clear_voltvaroperation() ;
  const ::commonmodule::VoltVarCSG& voltvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltVarCSG* release_voltvaroperation();
  ::commonmodule::VoltVarCSG* mutable_voltvaroperation();
  void set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation);
  private:
  const ::commonmodule::VoltVarCSG& _internal_voltvaroperation() const;
  ::commonmodule::VoltVarCSG* _internal_mutable_voltvaroperation();
  public:
  void unsafe_arena_set_allocated_voltvaroperation(
      ::commonmodule::VoltVarCSG* voltvaroperation);
  ::commonmodule::VoltVarCSG* unsafe_arena_release_voltvaroperation();
  // .commonmodule.VoltWCSG voltWOperation = 20;
  bool has_voltwoperation() const;
  private:
  bool _internal_has_voltwoperation() const;

  public:
  void clear_voltwoperation() ;
  const ::commonmodule::VoltWCSG& voltwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltWCSG* release_voltwoperation();
  ::commonmodule::VoltWCSG* mutable_voltwoperation();
  void set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation);
  private:
  const ::commonmodule::VoltWCSG& _internal_voltwoperation() const;
  ::commonmodule::VoltWCSG* _internal_mutable_voltwoperation();
  public:
  void unsafe_arena_set_allocated_voltwoperation(
      ::commonmodule::VoltWCSG* voltwoperation);
  ::commonmodule::VoltWCSG* unsafe_arena_release_voltwoperation();
  // .commonmodule.WVarCSG wVarOperation = 21;
  bool has_wvaroperation() const;
  private:
  bool _internal_has_wvaroperation() const;

  public:
  void clear_wvaroperation() ;
  const ::commonmodule::WVarCSG& wvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::WVarCSG* release_wvaroperation();
  ::commonmodule::WVarCSG* mutable_wvaroperation();
  void set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation);
  private:
  const ::commonmodule::WVarCSG& _internal_wvaroperation() const;
  ::commonmodule::WVarCSG* _internal_mutable_wvaroperation();
  public:
  void unsafe_arena_set_allocated_wvaroperation(
      ::commonmodule::WVarCSG* wvaroperation);
  ::commonmodule::WVarCSG* unsafe_arena_release_wvaroperation();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarPointStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusSPS* frequencysetpointenabled_;
    ::commonmodule::ENG_GridConnectModeKind* mode_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop_;
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::StatusSPS* reactivepwrsetpointenabled_;
    ::commonmodule::StatusSPS* realpwrsetpointenabled_;
    ::commonmodule::Optional_StateKind* state_;
    ::commonmodule::StatusSPS* voltagesetpointenabled_;
    ::commonmodule::ControlSPC* blackstartenabled_;
    ::commonmodule::EnterServiceAPC* enterserviceoperation_;
    ::commonmodule::HzWPoint* hzwoperation_;
    ::commonmodule::LimitWAPC* limitwoperation_;
    ::commonmodule::PFSPC* pfoperation_;
    ::commonmodule::ControlSPC* syncbacktogrid_;
    ::commonmodule::TmHzCSG* tmhztripoperation_;
    ::commonmodule::TmVoltCSG* tmvolttripoperation_;
    ::commonmodule::VarSPC* varoperation_;
    ::commonmodule::VoltVarCSG* voltvaroperation_;
    ::commonmodule::VoltWCSG* voltwoperation_;
    ::commonmodule::WVarCSG* wvaroperation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarEventAndStatusZGEN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEventAndStatusZGEN) */ {
 public:
  inline SolarEventAndStatusZGEN() : SolarEventAndStatusZGEN(nullptr) {}
  ~SolarEventAndStatusZGEN() override;
  explicit PROTOBUF_CONSTEXPR SolarEventAndStatusZGEN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarEventAndStatusZGEN(const SolarEventAndStatusZGEN& from);
  SolarEventAndStatusZGEN(SolarEventAndStatusZGEN&& from) noexcept
    : SolarEventAndStatusZGEN() {
    *this = ::std::move(from);
  }

  inline SolarEventAndStatusZGEN& operator=(const SolarEventAndStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarEventAndStatusZGEN& operator=(SolarEventAndStatusZGEN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarEventAndStatusZGEN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarEventAndStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const SolarEventAndStatusZGEN*>(
               &_SolarEventAndStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SolarEventAndStatusZGEN& a, SolarEventAndStatusZGEN& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarEventAndStatusZGEN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarEventAndStatusZGEN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarEventAndStatusZGEN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarEventAndStatusZGEN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarEventAndStatusZGEN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarEventAndStatusZGEN& from) {
    SolarEventAndStatusZGEN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEventAndStatusZGEN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarEventAndStatusZGEN";
  }
  protected:
  explicit SolarEventAndStatusZGEN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kAuxPwrStFieldNumber = 2,
    kDynamicTestFieldNumber = 3,
    kEmgStopFieldNumber = 4,
    kPointStatusFieldNumber = 5,
    kAlrmFieldNumber = 6,
    kGnSynStFieldNumber = 7,
    kGridConnectionStateFieldNumber = 8,
    kManAlrmInfoFieldNumber = 9,
    kOperatingStateFieldNumber = 10,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.StatusSPS AuxPwrSt = 2;
  bool has_auxpwrst() const;
  private:
  bool _internal_has_auxpwrst() const;

  public:
  void clear_auxpwrst() ;
  const ::commonmodule::StatusSPS& auxpwrst() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_auxpwrst();
  ::commonmodule::StatusSPS* mutable_auxpwrst();
  void set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst);
  private:
  const ::commonmodule::StatusSPS& _internal_auxpwrst() const;
  ::commonmodule::StatusSPS* _internal_mutable_auxpwrst();
  public:
  void unsafe_arena_set_allocated_auxpwrst(
      ::commonmodule::StatusSPS* auxpwrst);
  ::commonmodule::StatusSPS* unsafe_arena_release_auxpwrst();
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
  bool has_dynamictest() const;
  private:
  bool _internal_has_dynamictest() const;

  public:
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);
  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* _internal_mutable_dynamictest();
  public:
  void unsafe_arena_set_allocated_dynamictest(
      ::commonmodule::ENS_DynamicTestKind* dynamictest);
  ::commonmodule::ENS_DynamicTestKind* unsafe_arena_release_dynamictest();
  // .commonmodule.StatusSPS EmgStop = 4;
  bool has_emgstop() const;
  private:
  bool _internal_has_emgstop() const;

  public:
  void clear_emgstop() ;
  const ::commonmodule::StatusSPS& emgstop() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_emgstop();
  ::commonmodule::StatusSPS* mutable_emgstop();
  void set_allocated_emgstop(::commonmodule::StatusSPS* emgstop);
  private:
  const ::commonmodule::StatusSPS& _internal_emgstop() const;
  ::commonmodule::StatusSPS* _internal_mutable_emgstop();
  public:
  void unsafe_arena_set_allocated_emgstop(
      ::commonmodule::StatusSPS* emgstop);
  ::commonmodule::StatusSPS* unsafe_arena_release_emgstop();
  // .solarmodule.SolarPointStatus PointStatus = 5;
  bool has_pointstatus() const;
  private:
  bool _internal_has_pointstatus() const;

  public:
  void clear_pointstatus() ;
  const ::solarmodule::SolarPointStatus& pointstatus() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarPointStatus* release_pointstatus();
  ::solarmodule::SolarPointStatus* mutable_pointstatus();
  void set_allocated_pointstatus(::solarmodule::SolarPointStatus* pointstatus);
  private:
  const ::solarmodule::SolarPointStatus& _internal_pointstatus() const;
  ::solarmodule::SolarPointStatus* _internal_mutable_pointstatus();
  public:
  void unsafe_arena_set_allocated_pointstatus(
      ::solarmodule::SolarPointStatus* pointstatus);
  ::solarmodule::SolarPointStatus* unsafe_arena_release_pointstatus();
  // .commonmodule.Optional_AlrmKind Alrm = 6;
  bool has_alrm() const;
  private:
  bool _internal_has_alrm() const;

  public:
  void clear_alrm() ;
  const ::commonmodule::Optional_AlrmKind& alrm() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_AlrmKind* release_alrm();
  ::commonmodule::Optional_AlrmKind* mutable_alrm();
  void set_allocated_alrm(::commonmodule::Optional_AlrmKind* alrm);
  private:
  const ::commonmodule::Optional_AlrmKind& _internal_alrm() const;
  ::commonmodule::Optional_AlrmKind* _internal_mutable_alrm();
  public:
  void unsafe_arena_set_allocated_alrm(
      ::commonmodule::Optional_AlrmKind* alrm);
  ::commonmodule::Optional_AlrmKind* unsafe_arena_release_alrm();
  // .commonmodule.StatusSPS GnSynSt = 7;
  bool has_gnsynst() const;
  private:
  bool _internal_has_gnsynst() const;

  public:
  void clear_gnsynst() ;
  const ::commonmodule::StatusSPS& gnsynst() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_gnsynst();
  ::commonmodule::StatusSPS* mutable_gnsynst();
  void set_allocated_gnsynst(::commonmodule::StatusSPS* gnsynst);
  private:
  const ::commonmodule::StatusSPS& _internal_gnsynst() const;
  ::commonmodule::StatusSPS* _internal_mutable_gnsynst();
  public:
  void unsafe_arena_set_allocated_gnsynst(
      ::commonmodule::StatusSPS* gnsynst);
  ::commonmodule::StatusSPS* unsafe_arena_release_gnsynst();
  // .commonmodule.Optional_GridConnectionStateKind GridConnectionState = 8;
  bool has_gridconnectionstate() const;
  private:
  bool _internal_has_gridconnectionstate() const;

  public:
  void clear_gridconnectionstate() ;
  const ::commonmodule::Optional_GridConnectionStateKind& gridconnectionstate() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_GridConnectionStateKind* release_gridconnectionstate();
  ::commonmodule::Optional_GridConnectionStateKind* mutable_gridconnectionstate();
  void set_allocated_gridconnectionstate(::commonmodule::Optional_GridConnectionStateKind* gridconnectionstate);
  private:
  const ::commonmodule::Optional_GridConnectionStateKind& _internal_gridconnectionstate() const;
  ::commonmodule::Optional_GridConnectionStateKind* _internal_mutable_gridconnectionstate();
  public:
  void unsafe_arena_set_allocated_gridconnectionstate(
      ::commonmodule::Optional_GridConnectionStateKind* gridconnectionstate);
  ::commonmodule::Optional_GridConnectionStateKind* unsafe_arena_release_gridconnectionstate();
  // .google.protobuf.StringValue ManAlrmInfo = 9;
  bool has_manalrminfo() const;
  private:
  bool _internal_has_manalrminfo() const;

  public:
  void clear_manalrminfo() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& manalrminfo() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_manalrminfo();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_manalrminfo();
  void set_allocated_manalrminfo(::PROTOBUF_NAMESPACE_ID::StringValue* manalrminfo);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_manalrminfo() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_manalrminfo();
  public:
  void unsafe_arena_set_allocated_manalrminfo(
      ::PROTOBUF_NAMESPACE_ID::StringValue* manalrminfo);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_manalrminfo();
  // .commonmodule.Optional_OperatingStateKind OperatingState = 10;
  bool has_operatingstate() const;
  private:
  bool _internal_has_operatingstate() const;

  public:
  void clear_operatingstate() ;
  const ::commonmodule::Optional_OperatingStateKind& operatingstate() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_OperatingStateKind* release_operatingstate();
  ::commonmodule::Optional_OperatingStateKind* mutable_operatingstate();
  void set_allocated_operatingstate(::commonmodule::Optional_OperatingStateKind* operatingstate);
  private:
  const ::commonmodule::Optional_OperatingStateKind& _internal_operatingstate() const;
  ::commonmodule::Optional_OperatingStateKind* _internal_mutable_operatingstate();
  public:
  void unsafe_arena_set_allocated_operatingstate(
      ::commonmodule::Optional_OperatingStateKind* operatingstate);
  ::commonmodule::Optional_OperatingStateKind* unsafe_arena_release_operatingstate();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarEventAndStatusZGEN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::StatusSPS* auxpwrst_;
    ::commonmodule::ENS_DynamicTestKind* dynamictest_;
    ::commonmodule::StatusSPS* emgstop_;
    ::solarmodule::SolarPointStatus* pointstatus_;
    ::commonmodule::Optional_AlrmKind* alrm_;
    ::commonmodule::StatusSPS* gnsynst_;
    ::commonmodule::Optional_GridConnectionStateKind* gridconnectionstate_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* manalrminfo_;
    ::commonmodule::Optional_OperatingStateKind* operatingstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarEventZGEN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEventZGEN) */ {
 public:
  inline SolarEventZGEN() : SolarEventZGEN(nullptr) {}
  ~SolarEventZGEN() override;
  explicit PROTOBUF_CONSTEXPR SolarEventZGEN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarEventZGEN(const SolarEventZGEN& from);
  SolarEventZGEN(SolarEventZGEN&& from) noexcept
    : SolarEventZGEN() {
    *this = ::std::move(from);
  }

  inline SolarEventZGEN& operator=(const SolarEventZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarEventZGEN& operator=(SolarEventZGEN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarEventZGEN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarEventZGEN* internal_default_instance() {
    return reinterpret_cast<const SolarEventZGEN*>(
               &_SolarEventZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SolarEventZGEN& a, SolarEventZGEN& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarEventZGEN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarEventZGEN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarEventZGEN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarEventZGEN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarEventZGEN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarEventZGEN& from) {
    SolarEventZGEN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEventZGEN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarEventZGEN";
  }
  protected:
  explicit SolarEventZGEN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSolarEventAndStatusZGENFieldNumber = 1,
    kGriModFieldNumber = 2,
  };
  // .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_solareventandstatuszgen() const;
  private:
  bool _internal_has_solareventandstatuszgen() const;

  public:
  void clear_solareventandstatuszgen() ;
  const ::solarmodule::SolarEventAndStatusZGEN& solareventandstatuszgen() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarEventAndStatusZGEN* release_solareventandstatuszgen();
  ::solarmodule::SolarEventAndStatusZGEN* mutable_solareventandstatuszgen();
  void set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen);
  private:
  const ::solarmodule::SolarEventAndStatusZGEN& _internal_solareventandstatuszgen() const;
  ::solarmodule::SolarEventAndStatusZGEN* _internal_mutable_solareventandstatuszgen();
  public:
  void unsafe_arena_set_allocated_solareventandstatuszgen(
      ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen);
  ::solarmodule::SolarEventAndStatusZGEN* unsafe_arena_release_solareventandstatuszgen();
  // .commonmodule.ENG_GridConnectModeKind GriMod = 2;
  bool has_grimod() const;
  private:
  bool _internal_has_grimod() const;

  public:
  void clear_grimod() ;
  const ::commonmodule::ENG_GridConnectModeKind& grimod() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_GridConnectModeKind* release_grimod();
  ::commonmodule::ENG_GridConnectModeKind* mutable_grimod();
  void set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod);
  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_grimod() const;
  ::commonmodule::ENG_GridConnectModeKind* _internal_mutable_grimod();
  public:
  void unsafe_arena_set_allocated_grimod(
      ::commonmodule::ENG_GridConnectModeKind* grimod);
  ::commonmodule::ENG_GridConnectModeKind* unsafe_arena_release_grimod();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarEventZGEN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen_;
    ::commonmodule::ENG_GridConnectModeKind* grimod_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEvent) */ {
 public:
  inline SolarEvent() : SolarEvent(nullptr) {}
  ~SolarEvent() override;
  explicit PROTOBUF_CONSTEXPR SolarEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarEvent(const SolarEvent& from);
  SolarEvent(SolarEvent&& from) noexcept
    : SolarEvent() {
    *this = ::std::move(from);
  }

  inline SolarEvent& operator=(const SolarEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarEvent& operator=(SolarEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarEvent* internal_default_instance() {
    return reinterpret_cast<const SolarEvent*>(
               &_SolarEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SolarEvent& a, SolarEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarEvent& from) {
    SolarEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarEvent";
  }
  protected:
  explicit SolarEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventValueFieldNumber = 1,
    kSolarEventZGENFieldNumber = 2,
  };
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  private:
  bool _internal_has_eventvalue() const;

  public:
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);
  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* _internal_mutable_eventvalue();
  public:
  void unsafe_arena_set_allocated_eventvalue(
      ::commonmodule::EventValue* eventvalue);
  ::commonmodule::EventValue* unsafe_arena_release_eventvalue();
  // .solarmodule.SolarEventZGEN solarEventZGEN = 2;
  bool has_solareventzgen() const;
  private:
  bool _internal_has_solareventzgen() const;

  public:
  void clear_solareventzgen() ;
  const ::solarmodule::SolarEventZGEN& solareventzgen() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarEventZGEN* release_solareventzgen();
  ::solarmodule::SolarEventZGEN* mutable_solareventzgen();
  void set_allocated_solareventzgen(::solarmodule::SolarEventZGEN* solareventzgen);
  private:
  const ::solarmodule::SolarEventZGEN& _internal_solareventzgen() const;
  ::solarmodule::SolarEventZGEN* _internal_mutable_solareventzgen();
  public:
  void unsafe_arena_set_allocated_solareventzgen(
      ::solarmodule::SolarEventZGEN* solareventzgen);
  ::solarmodule::SolarEventZGEN* unsafe_arena_release_solareventzgen();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventValue* eventvalue_;
    ::solarmodule::SolarEventZGEN* solareventzgen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarEventProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarEventProfile) */ {
 public:
  inline SolarEventProfile() : SolarEventProfile(nullptr) {}
  ~SolarEventProfile() override;
  explicit PROTOBUF_CONSTEXPR SolarEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarEventProfile(const SolarEventProfile& from);
  SolarEventProfile(SolarEventProfile&& from) noexcept
    : SolarEventProfile() {
    *this = ::std::move(from);
  }

  inline SolarEventProfile& operator=(const SolarEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarEventProfile& operator=(SolarEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarEventProfile* internal_default_instance() {
    return reinterpret_cast<const SolarEventProfile*>(
               &_SolarEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SolarEventProfile& a, SolarEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarEventProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarEventProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarEventProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarEventProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarEventProfile& from) {
    SolarEventProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarEventProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarEventProfile";
  }
  protected:
  explicit SolarEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kSolarEventFieldNumber = 2,
    kSolarInverterFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;

  public:
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();
  // .solarmodule.SolarEvent solarEvent = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarevent() const;
  private:
  bool _internal_has_solarevent() const;

  public:
  void clear_solarevent() ;
  const ::solarmodule::SolarEvent& solarevent() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarEvent* release_solarevent();
  ::solarmodule::SolarEvent* mutable_solarevent();
  void set_allocated_solarevent(::solarmodule::SolarEvent* solarevent);
  private:
  const ::solarmodule::SolarEvent& _internal_solarevent() const;
  ::solarmodule::SolarEvent* _internal_mutable_solarevent();
  public:
  void unsafe_arena_set_allocated_solarevent(
      ::solarmodule::SolarEvent* solarevent);
  ::solarmodule::SolarEvent* unsafe_arena_release_solarevent();
  // .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  private:
  bool _internal_has_solarinverter() const;

  public:
  void clear_solarinverter() ;
  const ::solarmodule::SolarInverter& solarinverter() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);
  private:
  const ::solarmodule::SolarInverter& _internal_solarinverter() const;
  ::solarmodule::SolarInverter* _internal_mutable_solarinverter();
  public:
  void unsafe_arena_set_allocated_solarinverter(
      ::solarmodule::SolarInverter* solarinverter);
  ::solarmodule::SolarInverter* unsafe_arena_release_solarinverter();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventMessageInfo* eventmessageinfo_;
    ::solarmodule::SolarEvent* solarevent_;
    ::solarmodule::SolarInverter* solarinverter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarReading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarReading) */ {
 public:
  inline SolarReading() : SolarReading(nullptr) {}
  ~SolarReading() override;
  explicit PROTOBUF_CONSTEXPR SolarReading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarReading(const SolarReading& from);
  SolarReading(SolarReading&& from) noexcept
    : SolarReading() {
    *this = ::std::move(from);
  }

  inline SolarReading& operator=(const SolarReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarReading& operator=(SolarReading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarReading& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarReading* internal_default_instance() {
    return reinterpret_cast<const SolarReading*>(
               &_SolarReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SolarReading& a, SolarReading& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarReading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarReading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarReading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarReading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarReading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarReading& from) {
    SolarReading::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarReading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarReading";
  }
  protected:
  explicit SolarReading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kPhaseMMTNFieldNumber = 2,
    kReadingMMTRFieldNumber = 3,
    kReadingMMXUFieldNumber = 4,
  };
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  private:
  bool _internal_has_conductingequipmentterminalreading() const;

  public:
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* _internal_mutable_conductingequipmentterminalreading();
  public:
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(
      ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  ::commonmodule::ConductingEquipmentTerminalReading* unsafe_arena_release_conductingequipmentterminalreading();
  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  private:
  bool _internal_has_phasemmtn() const;

  public:
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);
  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* _internal_mutable_phasemmtn();
  public:
  void unsafe_arena_set_allocated_phasemmtn(
      ::commonmodule::PhaseMMTN* phasemmtn);
  ::commonmodule::PhaseMMTN* unsafe_arena_release_phasemmtn();
  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  private:
  bool _internal_has_readingmmtr() const;

  public:
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);
  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* _internal_mutable_readingmmtr();
  public:
  void unsafe_arena_set_allocated_readingmmtr(
      ::commonmodule::ReadingMMTR* readingmmtr);
  ::commonmodule::ReadingMMTR* unsafe_arena_release_readingmmtr();
  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  private:
  bool _internal_has_readingmmxu() const;

  public:
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_readingmmxu();
  public:
  void unsafe_arena_set_allocated_readingmmxu(
      ::commonmodule::ReadingMMXU* readingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_readingmmxu();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarReading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
    ::commonmodule::PhaseMMTN* phasemmtn_;
    ::commonmodule::ReadingMMTR* readingmmtr_;
    ::commonmodule::ReadingMMXU* readingmmxu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarReadingProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarReadingProfile) */ {
 public:
  inline SolarReadingProfile() : SolarReadingProfile(nullptr) {}
  ~SolarReadingProfile() override;
  explicit PROTOBUF_CONSTEXPR SolarReadingProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarReadingProfile(const SolarReadingProfile& from);
  SolarReadingProfile(SolarReadingProfile&& from) noexcept
    : SolarReadingProfile() {
    *this = ::std::move(from);
  }

  inline SolarReadingProfile& operator=(const SolarReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarReadingProfile& operator=(SolarReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarReadingProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarReadingProfile* internal_default_instance() {
    return reinterpret_cast<const SolarReadingProfile*>(
               &_SolarReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SolarReadingProfile& a, SolarReadingProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarReadingProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarReadingProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarReadingProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarReadingProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarReadingProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarReadingProfile& from) {
    SolarReadingProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarReadingProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarReadingProfile";
  }
  protected:
  explicit SolarReadingProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadingMessageInfoFieldNumber = 1,
    kSolarInverterFieldNumber = 2,
    kSolarReadingFieldNumber = 3,
  };
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  private:
  bool _internal_has_readingmessageinfo() const;

  public:
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);
  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* _internal_mutable_readingmessageinfo();
  public:
  void unsafe_arena_set_allocated_readingmessageinfo(
      ::commonmodule::ReadingMessageInfo* readingmessageinfo);
  ::commonmodule::ReadingMessageInfo* unsafe_arena_release_readingmessageinfo();
  // .solarmodule.SolarInverter solarInverter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  private:
  bool _internal_has_solarinverter() const;

  public:
  void clear_solarinverter() ;
  const ::solarmodule::SolarInverter& solarinverter() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);
  private:
  const ::solarmodule::SolarInverter& _internal_solarinverter() const;
  ::solarmodule::SolarInverter* _internal_mutable_solarinverter();
  public:
  void unsafe_arena_set_allocated_solarinverter(
      ::solarmodule::SolarInverter* solarinverter);
  ::solarmodule::SolarInverter* unsafe_arena_release_solarinverter();
  // .solarmodule.SolarReading solarReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarreading() const;
  private:
  bool _internal_has_solarreading() const;

  public:
  void clear_solarreading() ;
  const ::solarmodule::SolarReading& solarreading() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarReading* release_solarreading();
  ::solarmodule::SolarReading* mutable_solarreading();
  void set_allocated_solarreading(::solarmodule::SolarReading* solarreading);
  private:
  const ::solarmodule::SolarReading& _internal_solarreading() const;
  ::solarmodule::SolarReading* _internal_mutable_solarreading();
  public:
  void unsafe_arena_set_allocated_solarreading(
      ::solarmodule::SolarReading* solarreading);
  ::solarmodule::SolarReading* unsafe_arena_release_solarreading();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarReadingProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
    ::solarmodule::SolarInverter* solarinverter_;
    ::solarmodule::SolarReading* solarreading_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarStatusZGEN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarStatusZGEN) */ {
 public:
  inline SolarStatusZGEN() : SolarStatusZGEN(nullptr) {}
  ~SolarStatusZGEN() override;
  explicit PROTOBUF_CONSTEXPR SolarStatusZGEN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarStatusZGEN(const SolarStatusZGEN& from);
  SolarStatusZGEN(SolarStatusZGEN&& from) noexcept
    : SolarStatusZGEN() {
    *this = ::std::move(from);
  }

  inline SolarStatusZGEN& operator=(const SolarStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarStatusZGEN& operator=(SolarStatusZGEN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarStatusZGEN& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const SolarStatusZGEN*>(
               &_SolarStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SolarStatusZGEN& a, SolarStatusZGEN& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarStatusZGEN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarStatusZGEN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarStatusZGEN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarStatusZGEN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarStatusZGEN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarStatusZGEN& from) {
    SolarStatusZGEN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarStatusZGEN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarStatusZGEN";
  }
  protected:
  explicit SolarStatusZGEN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSolarEventAndStatusZGENFieldNumber = 1,
    kGriModFieldNumber = 2,
  };
  // .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_solareventandstatuszgen() const;
  private:
  bool _internal_has_solareventandstatuszgen() const;

  public:
  void clear_solareventandstatuszgen() ;
  const ::solarmodule::SolarEventAndStatusZGEN& solareventandstatuszgen() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarEventAndStatusZGEN* release_solareventandstatuszgen();
  ::solarmodule::SolarEventAndStatusZGEN* mutable_solareventandstatuszgen();
  void set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen);
  private:
  const ::solarmodule::SolarEventAndStatusZGEN& _internal_solareventandstatuszgen() const;
  ::solarmodule::SolarEventAndStatusZGEN* _internal_mutable_solareventandstatuszgen();
  public:
  void unsafe_arena_set_allocated_solareventandstatuszgen(
      ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen);
  ::solarmodule::SolarEventAndStatusZGEN* unsafe_arena_release_solareventandstatuszgen();
  // .commonmodule.ENG_GridConnectModeKind GriMod = 2;
  bool has_grimod() const;
  private:
  bool _internal_has_grimod() const;

  public:
  void clear_grimod() ;
  const ::commonmodule::ENG_GridConnectModeKind& grimod() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_GridConnectModeKind* release_grimod();
  ::commonmodule::ENG_GridConnectModeKind* mutable_grimod();
  void set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod);
  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_grimod() const;
  ::commonmodule::ENG_GridConnectModeKind* _internal_mutable_grimod();
  public:
  void unsafe_arena_set_allocated_grimod(
      ::commonmodule::ENG_GridConnectModeKind* grimod);
  ::commonmodule::ENG_GridConnectModeKind* unsafe_arena_release_grimod();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarStatusZGEN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen_;
    ::commonmodule::ENG_GridConnectModeKind* grimod_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarStatus) */ {
 public:
  inline SolarStatus() : SolarStatus(nullptr) {}
  ~SolarStatus() override;
  explicit PROTOBUF_CONSTEXPR SolarStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarStatus(const SolarStatus& from);
  SolarStatus(SolarStatus&& from) noexcept
    : SolarStatus() {
    *this = ::std::move(from);
  }

  inline SolarStatus& operator=(const SolarStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarStatus& operator=(SolarStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarStatus* internal_default_instance() {
    return reinterpret_cast<const SolarStatus*>(
               &_SolarStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SolarStatus& a, SolarStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarStatus& from) {
    SolarStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarStatus";
  }
  protected:
  explicit SolarStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusValueFieldNumber = 1,
    kSolarStatusZGENFieldNumber = 2,
  };
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  private:
  bool _internal_has_statusvalue() const;

  public:
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);
  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* _internal_mutable_statusvalue();
  public:
  void unsafe_arena_set_allocated_statusvalue(
      ::commonmodule::StatusValue* statusvalue);
  ::commonmodule::StatusValue* unsafe_arena_release_statusvalue();
  // .solarmodule.SolarStatusZGEN solarStatusZGEN = 2;
  bool has_solarstatuszgen() const;
  private:
  bool _internal_has_solarstatuszgen() const;

  public:
  void clear_solarstatuszgen() ;
  const ::solarmodule::SolarStatusZGEN& solarstatuszgen() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarStatusZGEN* release_solarstatuszgen();
  ::solarmodule::SolarStatusZGEN* mutable_solarstatuszgen();
  void set_allocated_solarstatuszgen(::solarmodule::SolarStatusZGEN* solarstatuszgen);
  private:
  const ::solarmodule::SolarStatusZGEN& _internal_solarstatuszgen() const;
  ::solarmodule::SolarStatusZGEN* _internal_mutable_solarstatuszgen();
  public:
  void unsafe_arena_set_allocated_solarstatuszgen(
      ::solarmodule::SolarStatusZGEN* solarstatuszgen);
  ::solarmodule::SolarStatusZGEN* unsafe_arena_release_solarstatuszgen();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusValue* statusvalue_;
    ::solarmodule::SolarStatusZGEN* solarstatuszgen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};// -------------------------------------------------------------------

class SolarStatusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:solarmodule.SolarStatusProfile) */ {
 public:
  inline SolarStatusProfile() : SolarStatusProfile(nullptr) {}
  ~SolarStatusProfile() override;
  explicit PROTOBUF_CONSTEXPR SolarStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolarStatusProfile(const SolarStatusProfile& from);
  SolarStatusProfile(SolarStatusProfile&& from) noexcept
    : SolarStatusProfile() {
    *this = ::std::move(from);
  }

  inline SolarStatusProfile& operator=(const SolarStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolarStatusProfile& operator=(SolarStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolarStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolarStatusProfile* internal_default_instance() {
    return reinterpret_cast<const SolarStatusProfile*>(
               &_SolarStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SolarStatusProfile& a, SolarStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SolarStatusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolarStatusProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolarStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolarStatusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolarStatusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SolarStatusProfile& from) {
    SolarStatusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolarStatusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "solarmodule.SolarStatusProfile";
  }
  protected:
  explicit SolarStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kSolarInverterFieldNumber = 2,
    kSolarStatusFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  private:
  bool _internal_has_statusmessageinfo() const;

  public:
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);
  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* _internal_mutable_statusmessageinfo();
  public:
  void unsafe_arena_set_allocated_statusmessageinfo(
      ::commonmodule::StatusMessageInfo* statusmessageinfo);
  ::commonmodule::StatusMessageInfo* unsafe_arena_release_statusmessageinfo();
  // .solarmodule.SolarInverter solarInverter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarinverter() const;
  private:
  bool _internal_has_solarinverter() const;

  public:
  void clear_solarinverter() ;
  const ::solarmodule::SolarInverter& solarinverter() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarInverter* release_solarinverter();
  ::solarmodule::SolarInverter* mutable_solarinverter();
  void set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter);
  private:
  const ::solarmodule::SolarInverter& _internal_solarinverter() const;
  ::solarmodule::SolarInverter* _internal_mutable_solarinverter();
  public:
  void unsafe_arena_set_allocated_solarinverter(
      ::solarmodule::SolarInverter* solarinverter);
  ::solarmodule::SolarInverter* unsafe_arena_release_solarinverter();
  // .solarmodule.SolarStatus solarStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_solarstatus() const;
  private:
  bool _internal_has_solarstatus() const;

  public:
  void clear_solarstatus() ;
  const ::solarmodule::SolarStatus& solarstatus() const;
  PROTOBUF_NODISCARD ::solarmodule::SolarStatus* release_solarstatus();
  ::solarmodule::SolarStatus* mutable_solarstatus();
  void set_allocated_solarstatus(::solarmodule::SolarStatus* solarstatus);
  private:
  const ::solarmodule::SolarStatus& _internal_solarstatus() const;
  ::solarmodule::SolarStatus* _internal_mutable_solarstatus();
  public:
  void unsafe_arena_set_allocated_solarstatus(
      ::solarmodule::SolarStatus* solarstatus);
  ::solarmodule::SolarStatus* unsafe_arena_release_solarstatus();
  // @@protoc_insertion_point(class_scope:solarmodule.SolarStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusMessageInfo* statusmessageinfo_;
    ::solarmodule::SolarInverter* solarinverter_;
    ::solarmodule::SolarStatus* solarstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_solarmodule_2fsolarmodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SolarInverter

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool SolarInverter::_internal_has_conductingequipment() const {
  return this != internal_default_instance() && _impl_.conductingequipment_ != nullptr;
}
inline bool SolarInverter::has_conductingequipment() const {
  return _internal_has_conductingequipment();
}
inline const ::commonmodule::ConductingEquipment& SolarInverter::_internal_conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& SolarInverter::conductingequipment() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarInverter.conductingEquipment)
  return _internal_conductingequipment();
}
inline void SolarInverter::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* conductingequipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarInverter.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* SolarInverter::release_conductingequipment() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* SolarInverter::unsafe_arena_release_conductingequipment() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarInverter.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* SolarInverter::_internal_mutable_conductingequipment() {
  
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.conductingequipment_ = p;
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* SolarInverter::mutable_conductingequipment() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarInverter.conductingEquipment)
  return _msg;
}
inline void SolarInverter::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  if (conductingequipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipment));
    if (message_arena != submessage_arena) {
      conductingequipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarInverter.conductingEquipment)
}

// -------------------------------------------------------------------

// SolarCapabilityConfiguration

// .commonmodule.SourceCapabilityConfiguration sourceCapabilityConfiguration = 1 [(.uml.option_parent_message) = true];
inline bool SolarCapabilityConfiguration::_internal_has_sourcecapabilityconfiguration() const {
  return this != internal_default_instance() && _impl_.sourcecapabilityconfiguration_ != nullptr;
}
inline bool SolarCapabilityConfiguration::has_sourcecapabilityconfiguration() const {
  return _internal_has_sourcecapabilityconfiguration();
}
inline const ::commonmodule::SourceCapabilityConfiguration& SolarCapabilityConfiguration::_internal_sourcecapabilityconfiguration() const {
  const ::commonmodule::SourceCapabilityConfiguration* p = _impl_.sourcecapabilityconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SourceCapabilityConfiguration&>(
      ::commonmodule::_SourceCapabilityConfiguration_default_instance_);
}
inline const ::commonmodule::SourceCapabilityConfiguration& SolarCapabilityConfiguration::sourcecapabilityconfiguration() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityConfiguration.sourceCapabilityConfiguration)
  return _internal_sourcecapabilityconfiguration();
}
inline void SolarCapabilityConfiguration::unsafe_arena_set_allocated_sourcecapabilityconfiguration(
    ::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityconfiguration_);
  }
  _impl_.sourcecapabilityconfiguration_ = sourcecapabilityconfiguration;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityConfiguration.sourceCapabilityConfiguration)
}
inline ::commonmodule::SourceCapabilityConfiguration* SolarCapabilityConfiguration::release_sourcecapabilityconfiguration() {
  
  ::commonmodule::SourceCapabilityConfiguration* temp = _impl_.sourcecapabilityconfiguration_;
  _impl_.sourcecapabilityconfiguration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::SourceCapabilityConfiguration* SolarCapabilityConfiguration::unsafe_arena_release_sourcecapabilityconfiguration() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityConfiguration.sourceCapabilityConfiguration)
  
  ::commonmodule::SourceCapabilityConfiguration* temp = _impl_.sourcecapabilityconfiguration_;
  _impl_.sourcecapabilityconfiguration_ = nullptr;
  return temp;
}
inline ::commonmodule::SourceCapabilityConfiguration* SolarCapabilityConfiguration::_internal_mutable_sourcecapabilityconfiguration() {
  
  if (_impl_.sourcecapabilityconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::SourceCapabilityConfiguration>(GetArenaForAllocation());
    _impl_.sourcecapabilityconfiguration_ = p;
  }
  return _impl_.sourcecapabilityconfiguration_;
}
inline ::commonmodule::SourceCapabilityConfiguration* SolarCapabilityConfiguration::mutable_sourcecapabilityconfiguration() {
  ::commonmodule::SourceCapabilityConfiguration* _msg = _internal_mutable_sourcecapabilityconfiguration();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityConfiguration.sourceCapabilityConfiguration)
  return _msg;
}
inline void SolarCapabilityConfiguration::set_allocated_sourcecapabilityconfiguration(::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityconfiguration_);
  }
  if (sourcecapabilityconfiguration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sourcecapabilityconfiguration));
    if (message_arena != submessage_arena) {
      sourcecapabilityconfiguration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sourcecapabilityconfiguration, submessage_arena);
    }

  } else {

  }
  _impl_.sourcecapabilityconfiguration_ = sourcecapabilityconfiguration;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityConfiguration.sourceCapabilityConfiguration)
}

// -------------------------------------------------------------------

// SolarCapabilityOverride

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool SolarCapabilityOverride::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool SolarCapabilityOverride::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& SolarCapabilityOverride::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& SolarCapabilityOverride::identifiedobject() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityOverride.identifiedObject)
  return _internal_identifiedobject();
}
inline void SolarCapabilityOverride::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityOverride.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* SolarCapabilityOverride::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* SolarCapabilityOverride::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityOverride.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* SolarCapabilityOverride::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* SolarCapabilityOverride::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityOverride.identifiedObject)
  return _msg;
}
inline void SolarCapabilityOverride::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject));
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityOverride.identifiedObject)
}

// .solarmodule.SolarCapabilityConfiguration solarCapabilityConfiguration = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCapabilityOverride::_internal_has_solarcapabilityconfiguration() const {
  return this != internal_default_instance() && _impl_.solarcapabilityconfiguration_ != nullptr;
}
inline bool SolarCapabilityOverride::has_solarcapabilityconfiguration() const {
  return _internal_has_solarcapabilityconfiguration();
}
inline void SolarCapabilityOverride::clear_solarcapabilityconfiguration() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcapabilityconfiguration_ != nullptr) {
    delete _impl_.solarcapabilityconfiguration_;
  }
  _impl_.solarcapabilityconfiguration_ = nullptr;
}
inline const ::solarmodule::SolarCapabilityConfiguration& SolarCapabilityOverride::_internal_solarcapabilityconfiguration() const {
  const ::solarmodule::SolarCapabilityConfiguration* p = _impl_.solarcapabilityconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarCapabilityConfiguration&>(
      ::solarmodule::_SolarCapabilityConfiguration_default_instance_);
}
inline const ::solarmodule::SolarCapabilityConfiguration& SolarCapabilityOverride::solarcapabilityconfiguration() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityOverride.solarCapabilityConfiguration)
  return _internal_solarcapabilityconfiguration();
}
inline void SolarCapabilityOverride::unsafe_arena_set_allocated_solarcapabilityconfiguration(
    ::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcapabilityconfiguration_);
  }
  _impl_.solarcapabilityconfiguration_ = solarcapabilityconfiguration;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityOverride.solarCapabilityConfiguration)
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapabilityOverride::release_solarcapabilityconfiguration() {
  
  ::solarmodule::SolarCapabilityConfiguration* temp = _impl_.solarcapabilityconfiguration_;
  _impl_.solarcapabilityconfiguration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapabilityOverride::unsafe_arena_release_solarcapabilityconfiguration() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityOverride.solarCapabilityConfiguration)
  
  ::solarmodule::SolarCapabilityConfiguration* temp = _impl_.solarcapabilityconfiguration_;
  _impl_.solarcapabilityconfiguration_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapabilityOverride::_internal_mutable_solarcapabilityconfiguration() {
  
  if (_impl_.solarcapabilityconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarCapabilityConfiguration>(GetArenaForAllocation());
    _impl_.solarcapabilityconfiguration_ = p;
  }
  return _impl_.solarcapabilityconfiguration_;
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapabilityOverride::mutable_solarcapabilityconfiguration() {
  ::solarmodule::SolarCapabilityConfiguration* _msg = _internal_mutable_solarcapabilityconfiguration();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityOverride.solarCapabilityConfiguration)
  return _msg;
}
inline void SolarCapabilityOverride::set_allocated_solarcapabilityconfiguration(::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcapabilityconfiguration_;
  }
  if (solarcapabilityconfiguration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcapabilityconfiguration);
    if (message_arena != submessage_arena) {
      solarcapabilityconfiguration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcapabilityconfiguration, submessage_arena);
    }

  } else {

  }
  _impl_.solarcapabilityconfiguration_ = solarcapabilityconfiguration;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityOverride.solarCapabilityConfiguration)
}

// -------------------------------------------------------------------

// SolarCapabilityOverrideProfile

// .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarCapabilityOverrideProfile::_internal_has_capabilitymessageinfo() const {
  return this != internal_default_instance() && _impl_.capabilitymessageinfo_ != nullptr;
}
inline bool SolarCapabilityOverrideProfile::has_capabilitymessageinfo() const {
  return _internal_has_capabilitymessageinfo();
}
inline const ::commonmodule::CapabilityMessageInfo& SolarCapabilityOverrideProfile::_internal_capabilitymessageinfo() const {
  const ::commonmodule::CapabilityMessageInfo* p = _impl_.capabilitymessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CapabilityMessageInfo&>(
      ::commonmodule::_CapabilityMessageInfo_default_instance_);
}
inline const ::commonmodule::CapabilityMessageInfo& SolarCapabilityOverrideProfile::capabilitymessageinfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityOverrideProfile.capabilityMessageInfo)
  return _internal_capabilitymessageinfo();
}
inline void SolarCapabilityOverrideProfile::unsafe_arena_set_allocated_capabilitymessageinfo(
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityOverrideProfile.capabilityMessageInfo)
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityOverrideProfile::release_capabilitymessageinfo() {
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityOverrideProfile::unsafe_arena_release_capabilitymessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityOverrideProfile.capabilityMessageInfo)
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityOverrideProfile::_internal_mutable_capabilitymessageinfo() {
  
  if (_impl_.capabilitymessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CapabilityMessageInfo>(GetArenaForAllocation());
    _impl_.capabilitymessageinfo_ = p;
  }
  return _impl_.capabilitymessageinfo_;
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityOverrideProfile::mutable_capabilitymessageinfo() {
  ::commonmodule::CapabilityMessageInfo* _msg = _internal_mutable_capabilitymessageinfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityOverrideProfile.capabilityMessageInfo)
  return _msg;
}
inline void SolarCapabilityOverrideProfile::set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  if (capabilitymessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilitymessageinfo));
    if (message_arena != submessage_arena) {
      capabilitymessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilitymessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityOverrideProfile.capabilityMessageInfo)
}

// .solarmodule.SolarCapabilityOverride solarCapabilityOverride = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCapabilityOverrideProfile::_internal_has_solarcapabilityoverride() const {
  return this != internal_default_instance() && _impl_.solarcapabilityoverride_ != nullptr;
}
inline bool SolarCapabilityOverrideProfile::has_solarcapabilityoverride() const {
  return _internal_has_solarcapabilityoverride();
}
inline void SolarCapabilityOverrideProfile::clear_solarcapabilityoverride() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcapabilityoverride_ != nullptr) {
    delete _impl_.solarcapabilityoverride_;
  }
  _impl_.solarcapabilityoverride_ = nullptr;
}
inline const ::solarmodule::SolarCapabilityOverride& SolarCapabilityOverrideProfile::_internal_solarcapabilityoverride() const {
  const ::solarmodule::SolarCapabilityOverride* p = _impl_.solarcapabilityoverride_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarCapabilityOverride&>(
      ::solarmodule::_SolarCapabilityOverride_default_instance_);
}
inline const ::solarmodule::SolarCapabilityOverride& SolarCapabilityOverrideProfile::solarcapabilityoverride() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityOverrideProfile.solarCapabilityOverride)
  return _internal_solarcapabilityoverride();
}
inline void SolarCapabilityOverrideProfile::unsafe_arena_set_allocated_solarcapabilityoverride(
    ::solarmodule::SolarCapabilityOverride* solarcapabilityoverride) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcapabilityoverride_);
  }
  _impl_.solarcapabilityoverride_ = solarcapabilityoverride;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityOverrideProfile.solarCapabilityOverride)
}
inline ::solarmodule::SolarCapabilityOverride* SolarCapabilityOverrideProfile::release_solarcapabilityoverride() {
  
  ::solarmodule::SolarCapabilityOverride* temp = _impl_.solarcapabilityoverride_;
  _impl_.solarcapabilityoverride_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarCapabilityOverride* SolarCapabilityOverrideProfile::unsafe_arena_release_solarcapabilityoverride() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityOverrideProfile.solarCapabilityOverride)
  
  ::solarmodule::SolarCapabilityOverride* temp = _impl_.solarcapabilityoverride_;
  _impl_.solarcapabilityoverride_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarCapabilityOverride* SolarCapabilityOverrideProfile::_internal_mutable_solarcapabilityoverride() {
  
  if (_impl_.solarcapabilityoverride_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarCapabilityOverride>(GetArenaForAllocation());
    _impl_.solarcapabilityoverride_ = p;
  }
  return _impl_.solarcapabilityoverride_;
}
inline ::solarmodule::SolarCapabilityOverride* SolarCapabilityOverrideProfile::mutable_solarcapabilityoverride() {
  ::solarmodule::SolarCapabilityOverride* _msg = _internal_mutable_solarcapabilityoverride();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityOverrideProfile.solarCapabilityOverride)
  return _msg;
}
inline void SolarCapabilityOverrideProfile::set_allocated_solarcapabilityoverride(::solarmodule::SolarCapabilityOverride* solarcapabilityoverride) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcapabilityoverride_;
  }
  if (solarcapabilityoverride) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcapabilityoverride);
    if (message_arena != submessage_arena) {
      solarcapabilityoverride = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcapabilityoverride, submessage_arena);
    }

  } else {

  }
  _impl_.solarcapabilityoverride_ = solarcapabilityoverride;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityOverrideProfile.solarCapabilityOverride)
}

// .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCapabilityOverrideProfile::_internal_has_solarinverter() const {
  return this != internal_default_instance() && _impl_.solarinverter_ != nullptr;
}
inline bool SolarCapabilityOverrideProfile::has_solarinverter() const {
  return _internal_has_solarinverter();
}
inline void SolarCapabilityOverrideProfile::clear_solarinverter() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarinverter_ != nullptr) {
    delete _impl_.solarinverter_;
  }
  _impl_.solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarCapabilityOverrideProfile::_internal_solarinverter() const {
  const ::solarmodule::SolarInverter* p = _impl_.solarinverter_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarInverter&>(
      ::solarmodule::_SolarInverter_default_instance_);
}
inline const ::solarmodule::SolarInverter& SolarCapabilityOverrideProfile::solarinverter() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityOverrideProfile.solarInverter)
  return _internal_solarinverter();
}
inline void SolarCapabilityOverrideProfile::unsafe_arena_set_allocated_solarinverter(
    ::solarmodule::SolarInverter* solarinverter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarinverter_);
  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityOverrideProfile.solarInverter)
}
inline ::solarmodule::SolarInverter* SolarCapabilityOverrideProfile::release_solarinverter() {
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarInverter* SolarCapabilityOverrideProfile::unsafe_arena_release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityOverrideProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarCapabilityOverrideProfile::_internal_mutable_solarinverter() {
  
  if (_impl_.solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaForAllocation());
    _impl_.solarinverter_ = p;
  }
  return _impl_.solarinverter_;
}
inline ::solarmodule::SolarInverter* SolarCapabilityOverrideProfile::mutable_solarinverter() {
  ::solarmodule::SolarInverter* _msg = _internal_mutable_solarinverter();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityOverrideProfile.solarInverter)
  return _msg;
}
inline void SolarCapabilityOverrideProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarinverter_;
  }
  if (solarinverter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarinverter);
    if (message_arena != submessage_arena) {
      solarinverter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }

  } else {

  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityOverrideProfile.solarInverter)
}

// -------------------------------------------------------------------

// SolarCapabilityRatings

// .commonmodule.SourceCapabilityRatings sourceCapabilityRatings = 1 [(.uml.option_parent_message) = true];
inline bool SolarCapabilityRatings::_internal_has_sourcecapabilityratings() const {
  return this != internal_default_instance() && _impl_.sourcecapabilityratings_ != nullptr;
}
inline bool SolarCapabilityRatings::has_sourcecapabilityratings() const {
  return _internal_has_sourcecapabilityratings();
}
inline const ::commonmodule::SourceCapabilityRatings& SolarCapabilityRatings::_internal_sourcecapabilityratings() const {
  const ::commonmodule::SourceCapabilityRatings* p = _impl_.sourcecapabilityratings_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SourceCapabilityRatings&>(
      ::commonmodule::_SourceCapabilityRatings_default_instance_);
}
inline const ::commonmodule::SourceCapabilityRatings& SolarCapabilityRatings::sourcecapabilityratings() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityRatings.sourceCapabilityRatings)
  return _internal_sourcecapabilityratings();
}
inline void SolarCapabilityRatings::unsafe_arena_set_allocated_sourcecapabilityratings(
    ::commonmodule::SourceCapabilityRatings* sourcecapabilityratings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityratings_);
  }
  _impl_.sourcecapabilityratings_ = sourcecapabilityratings;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityRatings.sourceCapabilityRatings)
}
inline ::commonmodule::SourceCapabilityRatings* SolarCapabilityRatings::release_sourcecapabilityratings() {
  
  ::commonmodule::SourceCapabilityRatings* temp = _impl_.sourcecapabilityratings_;
  _impl_.sourcecapabilityratings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::SourceCapabilityRatings* SolarCapabilityRatings::unsafe_arena_release_sourcecapabilityratings() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityRatings.sourceCapabilityRatings)
  
  ::commonmodule::SourceCapabilityRatings* temp = _impl_.sourcecapabilityratings_;
  _impl_.sourcecapabilityratings_ = nullptr;
  return temp;
}
inline ::commonmodule::SourceCapabilityRatings* SolarCapabilityRatings::_internal_mutable_sourcecapabilityratings() {
  
  if (_impl_.sourcecapabilityratings_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::SourceCapabilityRatings>(GetArenaForAllocation());
    _impl_.sourcecapabilityratings_ = p;
  }
  return _impl_.sourcecapabilityratings_;
}
inline ::commonmodule::SourceCapabilityRatings* SolarCapabilityRatings::mutable_sourcecapabilityratings() {
  ::commonmodule::SourceCapabilityRatings* _msg = _internal_mutable_sourcecapabilityratings();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityRatings.sourceCapabilityRatings)
  return _msg;
}
inline void SolarCapabilityRatings::set_allocated_sourcecapabilityratings(::commonmodule::SourceCapabilityRatings* sourcecapabilityratings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityratings_);
  }
  if (sourcecapabilityratings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sourcecapabilityratings));
    if (message_arena != submessage_arena) {
      sourcecapabilityratings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sourcecapabilityratings, submessage_arena);
    }

  } else {

  }
  _impl_.sourcecapabilityratings_ = sourcecapabilityratings;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityRatings.sourceCapabilityRatings)
}

// -------------------------------------------------------------------

// SolarCapability

// .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarCapability::_internal_has_nameplatevalue() const {
  return this != internal_default_instance() && _impl_.nameplatevalue_ != nullptr;
}
inline bool SolarCapability::has_nameplatevalue() const {
  return _internal_has_nameplatevalue();
}
inline const ::commonmodule::NameplateValue& SolarCapability::_internal_nameplatevalue() const {
  const ::commonmodule::NameplateValue* p = _impl_.nameplatevalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::NameplateValue&>(
      ::commonmodule::_NameplateValue_default_instance_);
}
inline const ::commonmodule::NameplateValue& SolarCapability::nameplatevalue() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapability.nameplateValue)
  return _internal_nameplatevalue();
}
inline void SolarCapability::unsafe_arena_set_allocated_nameplatevalue(
    ::commonmodule::NameplateValue* nameplatevalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nameplatevalue_);
  }
  _impl_.nameplatevalue_ = nameplatevalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapability.nameplateValue)
}
inline ::commonmodule::NameplateValue* SolarCapability::release_nameplatevalue() {
  
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::NameplateValue* SolarCapability::unsafe_arena_release_nameplatevalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapability.nameplateValue)
  
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
  return temp;
}
inline ::commonmodule::NameplateValue* SolarCapability::_internal_mutable_nameplatevalue() {
  
  if (_impl_.nameplatevalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::NameplateValue>(GetArenaForAllocation());
    _impl_.nameplatevalue_ = p;
  }
  return _impl_.nameplatevalue_;
}
inline ::commonmodule::NameplateValue* SolarCapability::mutable_nameplatevalue() {
  ::commonmodule::NameplateValue* _msg = _internal_mutable_nameplatevalue();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapability.nameplateValue)
  return _msg;
}
inline void SolarCapability::set_allocated_nameplatevalue(::commonmodule::NameplateValue* nameplatevalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nameplatevalue_);
  }
  if (nameplatevalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nameplatevalue));
    if (message_arena != submessage_arena) {
      nameplatevalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nameplatevalue, submessage_arena);
    }

  } else {

  }
  _impl_.nameplatevalue_ = nameplatevalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapability.nameplateValue)
}

// .solarmodule.SolarCapabilityConfiguration solarCapabilityConfiguration = 2;
inline bool SolarCapability::_internal_has_solarcapabilityconfiguration() const {
  return this != internal_default_instance() && _impl_.solarcapabilityconfiguration_ != nullptr;
}
inline bool SolarCapability::has_solarcapabilityconfiguration() const {
  return _internal_has_solarcapabilityconfiguration();
}
inline void SolarCapability::clear_solarcapabilityconfiguration() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcapabilityconfiguration_ != nullptr) {
    delete _impl_.solarcapabilityconfiguration_;
  }
  _impl_.solarcapabilityconfiguration_ = nullptr;
}
inline const ::solarmodule::SolarCapabilityConfiguration& SolarCapability::_internal_solarcapabilityconfiguration() const {
  const ::solarmodule::SolarCapabilityConfiguration* p = _impl_.solarcapabilityconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarCapabilityConfiguration&>(
      ::solarmodule::_SolarCapabilityConfiguration_default_instance_);
}
inline const ::solarmodule::SolarCapabilityConfiguration& SolarCapability::solarcapabilityconfiguration() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapability.solarCapabilityConfiguration)
  return _internal_solarcapabilityconfiguration();
}
inline void SolarCapability::unsafe_arena_set_allocated_solarcapabilityconfiguration(
    ::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcapabilityconfiguration_);
  }
  _impl_.solarcapabilityconfiguration_ = solarcapabilityconfiguration;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapability.solarCapabilityConfiguration)
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapability::release_solarcapabilityconfiguration() {
  
  ::solarmodule::SolarCapabilityConfiguration* temp = _impl_.solarcapabilityconfiguration_;
  _impl_.solarcapabilityconfiguration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapability::unsafe_arena_release_solarcapabilityconfiguration() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapability.solarCapabilityConfiguration)
  
  ::solarmodule::SolarCapabilityConfiguration* temp = _impl_.solarcapabilityconfiguration_;
  _impl_.solarcapabilityconfiguration_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapability::_internal_mutable_solarcapabilityconfiguration() {
  
  if (_impl_.solarcapabilityconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarCapabilityConfiguration>(GetArenaForAllocation());
    _impl_.solarcapabilityconfiguration_ = p;
  }
  return _impl_.solarcapabilityconfiguration_;
}
inline ::solarmodule::SolarCapabilityConfiguration* SolarCapability::mutable_solarcapabilityconfiguration() {
  ::solarmodule::SolarCapabilityConfiguration* _msg = _internal_mutable_solarcapabilityconfiguration();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapability.solarCapabilityConfiguration)
  return _msg;
}
inline void SolarCapability::set_allocated_solarcapabilityconfiguration(::solarmodule::SolarCapabilityConfiguration* solarcapabilityconfiguration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcapabilityconfiguration_;
  }
  if (solarcapabilityconfiguration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcapabilityconfiguration);
    if (message_arena != submessage_arena) {
      solarcapabilityconfiguration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcapabilityconfiguration, submessage_arena);
    }

  } else {

  }
  _impl_.solarcapabilityconfiguration_ = solarcapabilityconfiguration;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapability.solarCapabilityConfiguration)
}

// .solarmodule.SolarCapabilityRatings solarCapabilityRatings = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCapability::_internal_has_solarcapabilityratings() const {
  return this != internal_default_instance() && _impl_.solarcapabilityratings_ != nullptr;
}
inline bool SolarCapability::has_solarcapabilityratings() const {
  return _internal_has_solarcapabilityratings();
}
inline void SolarCapability::clear_solarcapabilityratings() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcapabilityratings_ != nullptr) {
    delete _impl_.solarcapabilityratings_;
  }
  _impl_.solarcapabilityratings_ = nullptr;
}
inline const ::solarmodule::SolarCapabilityRatings& SolarCapability::_internal_solarcapabilityratings() const {
  const ::solarmodule::SolarCapabilityRatings* p = _impl_.solarcapabilityratings_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarCapabilityRatings&>(
      ::solarmodule::_SolarCapabilityRatings_default_instance_);
}
inline const ::solarmodule::SolarCapabilityRatings& SolarCapability::solarcapabilityratings() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapability.solarCapabilityRatings)
  return _internal_solarcapabilityratings();
}
inline void SolarCapability::unsafe_arena_set_allocated_solarcapabilityratings(
    ::solarmodule::SolarCapabilityRatings* solarcapabilityratings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcapabilityratings_);
  }
  _impl_.solarcapabilityratings_ = solarcapabilityratings;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapability.solarCapabilityRatings)
}
inline ::solarmodule::SolarCapabilityRatings* SolarCapability::release_solarcapabilityratings() {
  
  ::solarmodule::SolarCapabilityRatings* temp = _impl_.solarcapabilityratings_;
  _impl_.solarcapabilityratings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarCapabilityRatings* SolarCapability::unsafe_arena_release_solarcapabilityratings() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapability.solarCapabilityRatings)
  
  ::solarmodule::SolarCapabilityRatings* temp = _impl_.solarcapabilityratings_;
  _impl_.solarcapabilityratings_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarCapabilityRatings* SolarCapability::_internal_mutable_solarcapabilityratings() {
  
  if (_impl_.solarcapabilityratings_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarCapabilityRatings>(GetArenaForAllocation());
    _impl_.solarcapabilityratings_ = p;
  }
  return _impl_.solarcapabilityratings_;
}
inline ::solarmodule::SolarCapabilityRatings* SolarCapability::mutable_solarcapabilityratings() {
  ::solarmodule::SolarCapabilityRatings* _msg = _internal_mutable_solarcapabilityratings();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapability.solarCapabilityRatings)
  return _msg;
}
inline void SolarCapability::set_allocated_solarcapabilityratings(::solarmodule::SolarCapabilityRatings* solarcapabilityratings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcapabilityratings_;
  }
  if (solarcapabilityratings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcapabilityratings);
    if (message_arena != submessage_arena) {
      solarcapabilityratings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcapabilityratings, submessage_arena);
    }

  } else {

  }
  _impl_.solarcapabilityratings_ = solarcapabilityratings;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapability.solarCapabilityRatings)
}

// -------------------------------------------------------------------

// SolarCapabilityProfile

// .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarCapabilityProfile::_internal_has_capabilitymessageinfo() const {
  return this != internal_default_instance() && _impl_.capabilitymessageinfo_ != nullptr;
}
inline bool SolarCapabilityProfile::has_capabilitymessageinfo() const {
  return _internal_has_capabilitymessageinfo();
}
inline const ::commonmodule::CapabilityMessageInfo& SolarCapabilityProfile::_internal_capabilitymessageinfo() const {
  const ::commonmodule::CapabilityMessageInfo* p = _impl_.capabilitymessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CapabilityMessageInfo&>(
      ::commonmodule::_CapabilityMessageInfo_default_instance_);
}
inline const ::commonmodule::CapabilityMessageInfo& SolarCapabilityProfile::capabilitymessageinfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityProfile.capabilityMessageInfo)
  return _internal_capabilitymessageinfo();
}
inline void SolarCapabilityProfile::unsafe_arena_set_allocated_capabilitymessageinfo(
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityProfile.capabilityMessageInfo)
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityProfile::release_capabilitymessageinfo() {
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityProfile::unsafe_arena_release_capabilitymessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityProfile.capabilityMessageInfo)
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityProfile::_internal_mutable_capabilitymessageinfo() {
  
  if (_impl_.capabilitymessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CapabilityMessageInfo>(GetArenaForAllocation());
    _impl_.capabilitymessageinfo_ = p;
  }
  return _impl_.capabilitymessageinfo_;
}
inline ::commonmodule::CapabilityMessageInfo* SolarCapabilityProfile::mutable_capabilitymessageinfo() {
  ::commonmodule::CapabilityMessageInfo* _msg = _internal_mutable_capabilitymessageinfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityProfile.capabilityMessageInfo)
  return _msg;
}
inline void SolarCapabilityProfile::set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  if (capabilitymessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilitymessageinfo));
    if (message_arena != submessage_arena) {
      capabilitymessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilitymessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityProfile.capabilityMessageInfo)
}

// .solarmodule.SolarCapability solarCapability = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCapabilityProfile::_internal_has_solarcapability() const {
  return this != internal_default_instance() && _impl_.solarcapability_ != nullptr;
}
inline bool SolarCapabilityProfile::has_solarcapability() const {
  return _internal_has_solarcapability();
}
inline void SolarCapabilityProfile::clear_solarcapability() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcapability_ != nullptr) {
    delete _impl_.solarcapability_;
  }
  _impl_.solarcapability_ = nullptr;
}
inline const ::solarmodule::SolarCapability& SolarCapabilityProfile::_internal_solarcapability() const {
  const ::solarmodule::SolarCapability* p = _impl_.solarcapability_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarCapability&>(
      ::solarmodule::_SolarCapability_default_instance_);
}
inline const ::solarmodule::SolarCapability& SolarCapabilityProfile::solarcapability() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityProfile.solarCapability)
  return _internal_solarcapability();
}
inline void SolarCapabilityProfile::unsafe_arena_set_allocated_solarcapability(
    ::solarmodule::SolarCapability* solarcapability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcapability_);
  }
  _impl_.solarcapability_ = solarcapability;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityProfile.solarCapability)
}
inline ::solarmodule::SolarCapability* SolarCapabilityProfile::release_solarcapability() {
  
  ::solarmodule::SolarCapability* temp = _impl_.solarcapability_;
  _impl_.solarcapability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarCapability* SolarCapabilityProfile::unsafe_arena_release_solarcapability() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityProfile.solarCapability)
  
  ::solarmodule::SolarCapability* temp = _impl_.solarcapability_;
  _impl_.solarcapability_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarCapability* SolarCapabilityProfile::_internal_mutable_solarcapability() {
  
  if (_impl_.solarcapability_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarCapability>(GetArenaForAllocation());
    _impl_.solarcapability_ = p;
  }
  return _impl_.solarcapability_;
}
inline ::solarmodule::SolarCapability* SolarCapabilityProfile::mutable_solarcapability() {
  ::solarmodule::SolarCapability* _msg = _internal_mutable_solarcapability();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityProfile.solarCapability)
  return _msg;
}
inline void SolarCapabilityProfile::set_allocated_solarcapability(::solarmodule::SolarCapability* solarcapability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcapability_;
  }
  if (solarcapability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcapability);
    if (message_arena != submessage_arena) {
      solarcapability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcapability, submessage_arena);
    }

  } else {

  }
  _impl_.solarcapability_ = solarcapability;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityProfile.solarCapability)
}

// .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCapabilityProfile::_internal_has_solarinverter() const {
  return this != internal_default_instance() && _impl_.solarinverter_ != nullptr;
}
inline bool SolarCapabilityProfile::has_solarinverter() const {
  return _internal_has_solarinverter();
}
inline void SolarCapabilityProfile::clear_solarinverter() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarinverter_ != nullptr) {
    delete _impl_.solarinverter_;
  }
  _impl_.solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarCapabilityProfile::_internal_solarinverter() const {
  const ::solarmodule::SolarInverter* p = _impl_.solarinverter_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarInverter&>(
      ::solarmodule::_SolarInverter_default_instance_);
}
inline const ::solarmodule::SolarInverter& SolarCapabilityProfile::solarinverter() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCapabilityProfile.solarInverter)
  return _internal_solarinverter();
}
inline void SolarCapabilityProfile::unsafe_arena_set_allocated_solarinverter(
    ::solarmodule::SolarInverter* solarinverter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarinverter_);
  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCapabilityProfile.solarInverter)
}
inline ::solarmodule::SolarInverter* SolarCapabilityProfile::release_solarinverter() {
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarInverter* SolarCapabilityProfile::unsafe_arena_release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCapabilityProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarCapabilityProfile::_internal_mutable_solarinverter() {
  
  if (_impl_.solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaForAllocation());
    _impl_.solarinverter_ = p;
  }
  return _impl_.solarinverter_;
}
inline ::solarmodule::SolarInverter* SolarCapabilityProfile::mutable_solarinverter() {
  ::solarmodule::SolarInverter* _msg = _internal_mutable_solarinverter();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCapabilityProfile.solarInverter)
  return _msg;
}
inline void SolarCapabilityProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarinverter_;
  }
  if (solarinverter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarinverter);
    if (message_arena != submessage_arena) {
      solarinverter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }

  } else {

  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCapabilityProfile.solarInverter)
}

// -------------------------------------------------------------------

// SolarPoint

// .commonmodule.ENG_GridConnectModeKind mode = 2;
inline bool SolarPoint::_internal_has_mode() const {
  return this != internal_default_instance() && _impl_.mode_ != nullptr;
}
inline bool SolarPoint::has_mode() const {
  return _internal_has_mode();
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarPoint::_internal_mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(
      ::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarPoint::mode() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.mode)
  return _internal_mode();
}
inline void SolarPoint::unsafe_arena_set_allocated_mode(
    ::commonmodule::ENG_GridConnectModeKind* mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.mode)
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPoint::release_mode() {
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPoint::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPoint::_internal_mutable_mode() {
  
  if (_impl_.mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaForAllocation());
    _impl_.mode_ = p;
  }
  return _impl_.mode_;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPoint::mutable_mode() {
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.mode)
  return _msg;
}
inline void SolarPoint::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  if (mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mode));
    if (message_arena != submessage_arena) {
      mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }

  } else {

  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.mode)
}

// .commonmodule.RampRate rampRates = 5;
inline bool SolarPoint::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool SolarPoint::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& SolarPoint::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& SolarPoint::ramprates() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.rampRates)
  return _internal_ramprates();
}
inline void SolarPoint::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.rampRates)
}
inline ::commonmodule::RampRate* SolarPoint::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* SolarPoint::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* SolarPoint::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* SolarPoint::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.rampRates)
  return _msg;
}
inline void SolarPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.rampRates)
}

// .commonmodule.ControlSPC reset = 8;
inline bool SolarPoint::_internal_has_reset() const {
  return this != internal_default_instance() && _impl_.reset_ != nullptr;
}
inline bool SolarPoint::has_reset() const {
  return _internal_has_reset();
}
inline const ::commonmodule::ControlSPC& SolarPoint::_internal_reset() const {
  const ::commonmodule::ControlSPC* p = _impl_.reset_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& SolarPoint::reset() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.reset)
  return _internal_reset();
}
inline void SolarPoint::unsafe_arena_set_allocated_reset(
    ::commonmodule::ControlSPC* reset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.reset)
}
inline ::commonmodule::ControlSPC* SolarPoint::release_reset() {
  
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPoint::unsafe_arena_release_reset() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.reset)
  
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPoint::_internal_mutable_reset() {
  
  if (_impl_.reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.reset_ = p;
  }
  return _impl_.reset_;
}
inline ::commonmodule::ControlSPC* SolarPoint::mutable_reset() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_reset();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.reset)
  return _msg;
}
inline void SolarPoint::set_allocated_reset(::commonmodule::ControlSPC* reset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  if (reset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reset));
    if (message_arena != submessage_arena) {
      reset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }

  } else {

  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.reset)
}

// .commonmodule.Optional_StateKind state = 9;
inline bool SolarPoint::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool SolarPoint::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& SolarPoint::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& SolarPoint::state() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.state)
  return _internal_state();
}
inline void SolarPoint::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.state)
}
inline ::commonmodule::Optional_StateKind* SolarPoint::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* SolarPoint::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* SolarPoint::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* SolarPoint::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.state)
  return _msg;
}
inline void SolarPoint::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.state)
}

// .commonmodule.EnterServiceAPC enterServiceOperation = 12;
inline bool SolarPoint::_internal_has_enterserviceoperation() const {
  return this != internal_default_instance() && _impl_.enterserviceoperation_ != nullptr;
}
inline bool SolarPoint::has_enterserviceoperation() const {
  return _internal_has_enterserviceoperation();
}
inline const ::commonmodule::EnterServiceAPC& SolarPoint::_internal_enterserviceoperation() const {
  const ::commonmodule::EnterServiceAPC* p = _impl_.enterserviceoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnterServiceAPC&>(
      ::commonmodule::_EnterServiceAPC_default_instance_);
}
inline const ::commonmodule::EnterServiceAPC& SolarPoint::enterserviceoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.enterServiceOperation)
  return _internal_enterserviceoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_enterserviceoperation(
    ::commonmodule::EnterServiceAPC* enterserviceoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.enterServiceOperation)
}
inline ::commonmodule::EnterServiceAPC* SolarPoint::release_enterserviceoperation() {
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnterServiceAPC* SolarPoint::unsafe_arena_release_enterserviceoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.enterServiceOperation)
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::EnterServiceAPC* SolarPoint::_internal_mutable_enterserviceoperation() {
  
  if (_impl_.enterserviceoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnterServiceAPC>(GetArenaForAllocation());
    _impl_.enterserviceoperation_ = p;
  }
  return _impl_.enterserviceoperation_;
}
inline ::commonmodule::EnterServiceAPC* SolarPoint::mutable_enterserviceoperation() {
  ::commonmodule::EnterServiceAPC* _msg = _internal_mutable_enterserviceoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.enterServiceOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  if (enterserviceoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enterserviceoperation));
    if (message_arena != submessage_arena) {
      enterserviceoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enterserviceoperation, submessage_arena);
    }

  } else {

  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.enterServiceOperation)
}

// .commonmodule.HzWAPC hzWOperation = 13;
inline bool SolarPoint::_internal_has_hzwoperation() const {
  return this != internal_default_instance() && _impl_.hzwoperation_ != nullptr;
}
inline bool SolarPoint::has_hzwoperation() const {
  return _internal_has_hzwoperation();
}
inline const ::commonmodule::HzWAPC& SolarPoint::_internal_hzwoperation() const {
  const ::commonmodule::HzWAPC* p = _impl_.hzwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWAPC&>(
      ::commonmodule::_HzWAPC_default_instance_);
}
inline const ::commonmodule::HzWAPC& SolarPoint::hzwoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.hzWOperation)
  return _internal_hzwoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_hzwoperation(
    ::commonmodule::HzWAPC* hzwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.hzWOperation)
}
inline ::commonmodule::HzWAPC* SolarPoint::release_hzwoperation() {
  
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::HzWAPC* SolarPoint::unsafe_arena_release_hzwoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.hzWOperation)
  
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWAPC* SolarPoint::_internal_mutable_hzwoperation() {
  
  if (_impl_.hzwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::HzWAPC>(GetArenaForAllocation());
    _impl_.hzwoperation_ = p;
  }
  return _impl_.hzwoperation_;
}
inline ::commonmodule::HzWAPC* SolarPoint::mutable_hzwoperation() {
  ::commonmodule::HzWAPC* _msg = _internal_mutable_hzwoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.hzWOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_hzwoperation(::commonmodule::HzWAPC* hzwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  if (hzwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hzwoperation));
    if (message_arena != submessage_arena) {
      hzwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hzwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.hzWOperation)
}

// .commonmodule.LimitWAPC limitWOperation = 14;
inline bool SolarPoint::_internal_has_limitwoperation() const {
  return this != internal_default_instance() && _impl_.limitwoperation_ != nullptr;
}
inline bool SolarPoint::has_limitwoperation() const {
  return _internal_has_limitwoperation();
}
inline const ::commonmodule::LimitWAPC& SolarPoint::_internal_limitwoperation() const {
  const ::commonmodule::LimitWAPC* p = _impl_.limitwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LimitWAPC&>(
      ::commonmodule::_LimitWAPC_default_instance_);
}
inline const ::commonmodule::LimitWAPC& SolarPoint::limitwoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.limitWOperation)
  return _internal_limitwoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_limitwoperation(
    ::commonmodule::LimitWAPC* limitwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.limitWOperation)
}
inline ::commonmodule::LimitWAPC* SolarPoint::release_limitwoperation() {
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LimitWAPC* SolarPoint::unsafe_arena_release_limitwoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.limitWOperation)
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::LimitWAPC* SolarPoint::_internal_mutable_limitwoperation() {
  
  if (_impl_.limitwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LimitWAPC>(GetArenaForAllocation());
    _impl_.limitwoperation_ = p;
  }
  return _impl_.limitwoperation_;
}
inline ::commonmodule::LimitWAPC* SolarPoint::mutable_limitwoperation() {
  ::commonmodule::LimitWAPC* _msg = _internal_mutable_limitwoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.limitWOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  if (limitwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limitwoperation));
    if (message_arena != submessage_arena) {
      limitwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limitwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.limitWOperation)
}

// .commonmodule.PFSPC pFOperation = 15;
inline bool SolarPoint::_internal_has_pfoperation() const {
  return this != internal_default_instance() && _impl_.pfoperation_ != nullptr;
}
inline bool SolarPoint::has_pfoperation() const {
  return _internal_has_pfoperation();
}
inline const ::commonmodule::PFSPC& SolarPoint::_internal_pfoperation() const {
  const ::commonmodule::PFSPC* p = _impl_.pfoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PFSPC&>(
      ::commonmodule::_PFSPC_default_instance_);
}
inline const ::commonmodule::PFSPC& SolarPoint::pfoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.pFOperation)
  return _internal_pfoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_pfoperation(
    ::commonmodule::PFSPC* pfoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.pFOperation)
}
inline ::commonmodule::PFSPC* SolarPoint::release_pfoperation() {
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PFSPC* SolarPoint::unsafe_arena_release_pfoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.pFOperation)
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::PFSPC* SolarPoint::_internal_mutable_pfoperation() {
  
  if (_impl_.pfoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PFSPC>(GetArenaForAllocation());
    _impl_.pfoperation_ = p;
  }
  return _impl_.pfoperation_;
}
inline ::commonmodule::PFSPC* SolarPoint::mutable_pfoperation() {
  ::commonmodule::PFSPC* _msg = _internal_mutable_pfoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.pFOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  if (pfoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pfoperation));
    if (message_arena != submessage_arena) {
      pfoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pfoperation, submessage_arena);
    }

  } else {

  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.pFOperation)
}

// .commonmodule.TmHzCSG tmHzTripOperation = 16;
inline bool SolarPoint::_internal_has_tmhztripoperation() const {
  return this != internal_default_instance() && _impl_.tmhztripoperation_ != nullptr;
}
inline bool SolarPoint::has_tmhztripoperation() const {
  return _internal_has_tmhztripoperation();
}
inline const ::commonmodule::TmHzCSG& SolarPoint::_internal_tmhztripoperation() const {
  const ::commonmodule::TmHzCSG* p = _impl_.tmhztripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmHzCSG&>(
      ::commonmodule::_TmHzCSG_default_instance_);
}
inline const ::commonmodule::TmHzCSG& SolarPoint::tmhztripoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.tmHzTripOperation)
  return _internal_tmhztripoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_tmhztripoperation(
    ::commonmodule::TmHzCSG* tmhztripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.tmHzTripOperation)
}
inline ::commonmodule::TmHzCSG* SolarPoint::release_tmhztripoperation() {
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmHzCSG* SolarPoint::unsafe_arena_release_tmhztripoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.tmHzTripOperation)
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmHzCSG* SolarPoint::_internal_mutable_tmhztripoperation() {
  
  if (_impl_.tmhztripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmHzCSG>(GetArenaForAllocation());
    _impl_.tmhztripoperation_ = p;
  }
  return _impl_.tmhztripoperation_;
}
inline ::commonmodule::TmHzCSG* SolarPoint::mutable_tmhztripoperation() {
  ::commonmodule::TmHzCSG* _msg = _internal_mutable_tmhztripoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.tmHzTripOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  if (tmhztripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmhztripoperation));
    if (message_arena != submessage_arena) {
      tmhztripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmhztripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.tmHzTripOperation)
}

// .commonmodule.TmVoltCSG tmVoltTripOperation = 17;
inline bool SolarPoint::_internal_has_tmvolttripoperation() const {
  return this != internal_default_instance() && _impl_.tmvolttripoperation_ != nullptr;
}
inline bool SolarPoint::has_tmvolttripoperation() const {
  return _internal_has_tmvolttripoperation();
}
inline const ::commonmodule::TmVoltCSG& SolarPoint::_internal_tmvolttripoperation() const {
  const ::commonmodule::TmVoltCSG* p = _impl_.tmvolttripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmVoltCSG&>(
      ::commonmodule::_TmVoltCSG_default_instance_);
}
inline const ::commonmodule::TmVoltCSG& SolarPoint::tmvolttripoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.tmVoltTripOperation)
  return _internal_tmvolttripoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_tmvolttripoperation(
    ::commonmodule::TmVoltCSG* tmvolttripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.tmVoltTripOperation)
}
inline ::commonmodule::TmVoltCSG* SolarPoint::release_tmvolttripoperation() {
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmVoltCSG* SolarPoint::unsafe_arena_release_tmvolttripoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.tmVoltTripOperation)
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmVoltCSG* SolarPoint::_internal_mutable_tmvolttripoperation() {
  
  if (_impl_.tmvolttripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmVoltCSG>(GetArenaForAllocation());
    _impl_.tmvolttripoperation_ = p;
  }
  return _impl_.tmvolttripoperation_;
}
inline ::commonmodule::TmVoltCSG* SolarPoint::mutable_tmvolttripoperation() {
  ::commonmodule::TmVoltCSG* _msg = _internal_mutable_tmvolttripoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.tmVoltTripOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  if (tmvolttripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmvolttripoperation));
    if (message_arena != submessage_arena) {
      tmvolttripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmvolttripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.tmVoltTripOperation)
}

// .commonmodule.VarSPC vArOperation = 18;
inline bool SolarPoint::_internal_has_varoperation() const {
  return this != internal_default_instance() && _impl_.varoperation_ != nullptr;
}
inline bool SolarPoint::has_varoperation() const {
  return _internal_has_varoperation();
}
inline const ::commonmodule::VarSPC& SolarPoint::_internal_varoperation() const {
  const ::commonmodule::VarSPC* p = _impl_.varoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VarSPC&>(
      ::commonmodule::_VarSPC_default_instance_);
}
inline const ::commonmodule::VarSPC& SolarPoint::varoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.vArOperation)
  return _internal_varoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_varoperation(
    ::commonmodule::VarSPC* varoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.vArOperation)
}
inline ::commonmodule::VarSPC* SolarPoint::release_varoperation() {
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VarSPC* SolarPoint::unsafe_arena_release_varoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.vArOperation)
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VarSPC* SolarPoint::_internal_mutable_varoperation() {
  
  if (_impl_.varoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VarSPC>(GetArenaForAllocation());
    _impl_.varoperation_ = p;
  }
  return _impl_.varoperation_;
}
inline ::commonmodule::VarSPC* SolarPoint::mutable_varoperation() {
  ::commonmodule::VarSPC* _msg = _internal_mutable_varoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.vArOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_varoperation(::commonmodule::VarSPC* varoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  if (varoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(varoperation));
    if (message_arena != submessage_arena) {
      varoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varoperation, submessage_arena);
    }

  } else {

  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.vArOperation)
}

// .commonmodule.VoltVarCSG voltVarOperation = 19;
inline bool SolarPoint::_internal_has_voltvaroperation() const {
  return this != internal_default_instance() && _impl_.voltvaroperation_ != nullptr;
}
inline bool SolarPoint::has_voltvaroperation() const {
  return _internal_has_voltvaroperation();
}
inline const ::commonmodule::VoltVarCSG& SolarPoint::_internal_voltvaroperation() const {
  const ::commonmodule::VoltVarCSG* p = _impl_.voltvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltVarCSG&>(
      ::commonmodule::_VoltVarCSG_default_instance_);
}
inline const ::commonmodule::VoltVarCSG& SolarPoint::voltvaroperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.voltVarOperation)
  return _internal_voltvaroperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_voltvaroperation(
    ::commonmodule::VoltVarCSG* voltvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.voltVarOperation)
}
inline ::commonmodule::VoltVarCSG* SolarPoint::release_voltvaroperation() {
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltVarCSG* SolarPoint::unsafe_arena_release_voltvaroperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.voltVarOperation)
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltVarCSG* SolarPoint::_internal_mutable_voltvaroperation() {
  
  if (_impl_.voltvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltVarCSG>(GetArenaForAllocation());
    _impl_.voltvaroperation_ = p;
  }
  return _impl_.voltvaroperation_;
}
inline ::commonmodule::VoltVarCSG* SolarPoint::mutable_voltvaroperation() {
  ::commonmodule::VoltVarCSG* _msg = _internal_mutable_voltvaroperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.voltVarOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  if (voltvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltvaroperation));
    if (message_arena != submessage_arena) {
      voltvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.voltVarOperation)
}

// .commonmodule.VoltWCSG voltWOperation = 20;
inline bool SolarPoint::_internal_has_voltwoperation() const {
  return this != internal_default_instance() && _impl_.voltwoperation_ != nullptr;
}
inline bool SolarPoint::has_voltwoperation() const {
  return _internal_has_voltwoperation();
}
inline const ::commonmodule::VoltWCSG& SolarPoint::_internal_voltwoperation() const {
  const ::commonmodule::VoltWCSG* p = _impl_.voltwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltWCSG&>(
      ::commonmodule::_VoltWCSG_default_instance_);
}
inline const ::commonmodule::VoltWCSG& SolarPoint::voltwoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.voltWOperation)
  return _internal_voltwoperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_voltwoperation(
    ::commonmodule::VoltWCSG* voltwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.voltWOperation)
}
inline ::commonmodule::VoltWCSG* SolarPoint::release_voltwoperation() {
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltWCSG* SolarPoint::unsafe_arena_release_voltwoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.voltWOperation)
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltWCSG* SolarPoint::_internal_mutable_voltwoperation() {
  
  if (_impl_.voltwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltWCSG>(GetArenaForAllocation());
    _impl_.voltwoperation_ = p;
  }
  return _impl_.voltwoperation_;
}
inline ::commonmodule::VoltWCSG* SolarPoint::mutable_voltwoperation() {
  ::commonmodule::VoltWCSG* _msg = _internal_mutable_voltwoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.voltWOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  if (voltwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltwoperation));
    if (message_arena != submessage_arena) {
      voltwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.voltWOperation)
}

// .commonmodule.WVarCSG wVarOperation = 21;
inline bool SolarPoint::_internal_has_wvaroperation() const {
  return this != internal_default_instance() && _impl_.wvaroperation_ != nullptr;
}
inline bool SolarPoint::has_wvaroperation() const {
  return _internal_has_wvaroperation();
}
inline const ::commonmodule::WVarCSG& SolarPoint::_internal_wvaroperation() const {
  const ::commonmodule::WVarCSG* p = _impl_.wvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WVarCSG&>(
      ::commonmodule::_WVarCSG_default_instance_);
}
inline const ::commonmodule::WVarCSG& SolarPoint::wvaroperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.wVarOperation)
  return _internal_wvaroperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_wvaroperation(
    ::commonmodule::WVarCSG* wvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.wVarOperation)
}
inline ::commonmodule::WVarCSG* SolarPoint::release_wvaroperation() {
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WVarCSG* SolarPoint::unsafe_arena_release_wvaroperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.wVarOperation)
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WVarCSG* SolarPoint::_internal_mutable_wvaroperation() {
  
  if (_impl_.wvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WVarCSG>(GetArenaForAllocation());
    _impl_.wvaroperation_ = p;
  }
  return _impl_.wvaroperation_;
}
inline ::commonmodule::WVarCSG* SolarPoint::mutable_wvaroperation() {
  ::commonmodule::WVarCSG* _msg = _internal_mutable_wvaroperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.wVarOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  if (wvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wvaroperation));
    if (message_arena != submessage_arena) {
      wvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.wVarOperation)
}

// .commonmodule.ControlSPC blackStartEnabled = 22;
inline bool SolarPoint::_internal_has_blackstartenabled() const {
  return this != internal_default_instance() && _impl_.blackstartenabled_ != nullptr;
}
inline bool SolarPoint::has_blackstartenabled() const {
  return _internal_has_blackstartenabled();
}
inline const ::commonmodule::ControlSPC& SolarPoint::_internal_blackstartenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.blackstartenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& SolarPoint::blackstartenabled() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.blackStartEnabled)
  return _internal_blackstartenabled();
}
inline void SolarPoint::unsafe_arena_set_allocated_blackstartenabled(
    ::commonmodule::ControlSPC* blackstartenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.blackStartEnabled)
}
inline ::commonmodule::ControlSPC* SolarPoint::release_blackstartenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPoint::unsafe_arena_release_blackstartenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.blackStartEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPoint::_internal_mutable_blackstartenabled() {
  
  if (_impl_.blackstartenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.blackstartenabled_ = p;
  }
  return _impl_.blackstartenabled_;
}
inline ::commonmodule::ControlSPC* SolarPoint::mutable_blackstartenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_blackstartenabled();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.blackStartEnabled)
  return _msg;
}
inline void SolarPoint::set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  if (blackstartenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blackstartenabled));
    if (message_arena != submessage_arena) {
      blackstartenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blackstartenabled, submessage_arena);
    }

  } else {

  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.blackStartEnabled)
}

// .commonmodule.WSPC wOperation = 24;
inline bool SolarPoint::_internal_has_woperation() const {
  return this != internal_default_instance() && _impl_.woperation_ != nullptr;
}
inline bool SolarPoint::has_woperation() const {
  return _internal_has_woperation();
}
inline const ::commonmodule::WSPC& SolarPoint::_internal_woperation() const {
  const ::commonmodule::WSPC* p = _impl_.woperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WSPC&>(
      ::commonmodule::_WSPC_default_instance_);
}
inline const ::commonmodule::WSPC& SolarPoint::woperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPoint.wOperation)
  return _internal_woperation();
}
inline void SolarPoint::unsafe_arena_set_allocated_woperation(
    ::commonmodule::WSPC* woperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.woperation_);
  }
  _impl_.woperation_ = woperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPoint.wOperation)
}
inline ::commonmodule::WSPC* SolarPoint::release_woperation() {
  
  ::commonmodule::WSPC* temp = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WSPC* SolarPoint::unsafe_arena_release_woperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPoint.wOperation)
  
  ::commonmodule::WSPC* temp = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WSPC* SolarPoint::_internal_mutable_woperation() {
  
  if (_impl_.woperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WSPC>(GetArenaForAllocation());
    _impl_.woperation_ = p;
  }
  return _impl_.woperation_;
}
inline ::commonmodule::WSPC* SolarPoint::mutable_woperation() {
  ::commonmodule::WSPC* _msg = _internal_mutable_woperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPoint.wOperation)
  return _msg;
}
inline void SolarPoint::set_allocated_woperation(::commonmodule::WSPC* woperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.woperation_);
  }
  if (woperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(woperation));
    if (message_arena != submessage_arena) {
      woperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, woperation, submessage_arena);
    }

  } else {

  }
  _impl_.woperation_ = woperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPoint.wOperation)
}

// -------------------------------------------------------------------

// SolarCurvePoint

// .solarmodule.SolarPoint control = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCurvePoint::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool SolarCurvePoint::has_control() const {
  return _internal_has_control();
}
inline void SolarCurvePoint::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::solarmodule::SolarPoint& SolarCurvePoint::_internal_control() const {
  const ::solarmodule::SolarPoint* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarPoint&>(
      ::solarmodule::_SolarPoint_default_instance_);
}
inline const ::solarmodule::SolarPoint& SolarCurvePoint::control() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCurvePoint.control)
  return _internal_control();
}
inline void SolarCurvePoint::unsafe_arena_set_allocated_control(
    ::solarmodule::SolarPoint* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCurvePoint.control)
}
inline ::solarmodule::SolarPoint* SolarCurvePoint::release_control() {
  
  ::solarmodule::SolarPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarPoint* SolarCurvePoint::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCurvePoint.control)
  
  ::solarmodule::SolarPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarPoint* SolarCurvePoint::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarPoint>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::solarmodule::SolarPoint* SolarCurvePoint::mutable_control() {
  ::solarmodule::SolarPoint* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCurvePoint.control)
  return _msg;
}
inline void SolarCurvePoint::set_allocated_control(::solarmodule::SolarPoint* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }

  } else {

  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCurvePoint.control)
}

// .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarCurvePoint::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool SolarCurvePoint::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::commonmodule::ControlTimestamp& SolarCurvePoint::_internal_starttime() const {
  const ::commonmodule::ControlTimestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlTimestamp&>(
      ::commonmodule::_ControlTimestamp_default_instance_);
}
inline const ::commonmodule::ControlTimestamp& SolarCurvePoint::starttime() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCurvePoint.startTime)
  return _internal_starttime();
}
inline void SolarCurvePoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::ControlTimestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarCurvePoint.startTime)
}
inline ::commonmodule::ControlTimestamp* SolarCurvePoint::release_starttime() {
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlTimestamp* SolarCurvePoint::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarCurvePoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* SolarCurvePoint::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::commonmodule::ControlTimestamp* SolarCurvePoint::mutable_starttime() {
  ::commonmodule::ControlTimestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCurvePoint.startTime)
  return _msg;
}
inline void SolarCurvePoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }

  } else {

  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarCurvePoint.startTime)
}

// -------------------------------------------------------------------

// SolarCSG

// repeated .solarmodule.SolarCurvePoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int SolarCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int SolarCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void SolarCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::solarmodule::SolarCurvePoint* SolarCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::solarmodule::SolarCurvePoint >*
SolarCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:solarmodule.SolarCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::solarmodule::SolarCurvePoint& SolarCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::solarmodule::SolarCurvePoint& SolarCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::solarmodule::SolarCurvePoint* SolarCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::solarmodule::SolarCurvePoint* SolarCSG::add_crvpts() {
  ::solarmodule::SolarCurvePoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:solarmodule.SolarCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::solarmodule::SolarCurvePoint >&
SolarCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:solarmodule.SolarCSG.crvPts)
  return _impl_.crvpts_;
}

// -------------------------------------------------------------------

// SolarControlScheduleFSCH

// .solarmodule.SolarCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarControlScheduleFSCH::_internal_has_valdcsg() const {
  return this != internal_default_instance() && _impl_.valdcsg_ != nullptr;
}
inline bool SolarControlScheduleFSCH::has_valdcsg() const {
  return _internal_has_valdcsg();
}
inline void SolarControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaForAllocation() == nullptr && _impl_.valdcsg_ != nullptr) {
    delete _impl_.valdcsg_;
  }
  _impl_.valdcsg_ = nullptr;
}
inline const ::solarmodule::SolarCSG& SolarControlScheduleFSCH::_internal_valdcsg() const {
  const ::solarmodule::SolarCSG* p = _impl_.valdcsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarCSG&>(
      ::solarmodule::_SolarCSG_default_instance_);
}
inline const ::solarmodule::SolarCSG& SolarControlScheduleFSCH::valdcsg() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlScheduleFSCH.ValDCSG)
  return _internal_valdcsg();
}
inline void SolarControlScheduleFSCH::unsafe_arena_set_allocated_valdcsg(
    ::solarmodule::SolarCSG* valdcsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valdcsg_);
  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControlScheduleFSCH.ValDCSG)
}
inline ::solarmodule::SolarCSG* SolarControlScheduleFSCH::release_valdcsg() {
  
  ::solarmodule::SolarCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarCSG* SolarControlScheduleFSCH::unsafe_arena_release_valdcsg() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlScheduleFSCH.ValDCSG)
  
  ::solarmodule::SolarCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarCSG* SolarControlScheduleFSCH::_internal_mutable_valdcsg() {
  
  if (_impl_.valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarCSG>(GetArenaForAllocation());
    _impl_.valdcsg_ = p;
  }
  return _impl_.valdcsg_;
}
inline ::solarmodule::SolarCSG* SolarControlScheduleFSCH::mutable_valdcsg() {
  ::solarmodule::SolarCSG* _msg = _internal_mutable_valdcsg();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlScheduleFSCH.ValDCSG)
  return _msg;
}
inline void SolarControlScheduleFSCH::set_allocated_valdcsg(::solarmodule::SolarCSG* valdcsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.valdcsg_;
  }
  if (valdcsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(valdcsg);
    if (message_arena != submessage_arena) {
      valdcsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }

  } else {

  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// SolarControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool SolarControlFSCC::_internal_has_controlfscc() const {
  return this != internal_default_instance() && _impl_.controlfscc_ != nullptr;
}
inline bool SolarControlFSCC::has_controlfscc() const {
  return _internal_has_controlfscc();
}
inline const ::commonmodule::ControlFSCC& SolarControlFSCC::_internal_controlfscc() const {
  const ::commonmodule::ControlFSCC* p = _impl_.controlfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlFSCC&>(
      ::commonmodule::_ControlFSCC_default_instance_);
}
inline const ::commonmodule::ControlFSCC& SolarControlFSCC::controlfscc() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlFSCC.controlFSCC)
  return _internal_controlfscc();
}
inline void SolarControlFSCC::unsafe_arena_set_allocated_controlfscc(
    ::commonmodule::ControlFSCC* controlfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControlFSCC.controlFSCC)
}
inline ::commonmodule::ControlFSCC* SolarControlFSCC::release_controlfscc() {
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlFSCC* SolarControlFSCC::unsafe_arena_release_controlfscc() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* SolarControlFSCC::_internal_mutable_controlfscc() {
  
  if (_impl_.controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaForAllocation());
    _impl_.controlfscc_ = p;
  }
  return _impl_.controlfscc_;
}
inline ::commonmodule::ControlFSCC* SolarControlFSCC::mutable_controlfscc() {
  ::commonmodule::ControlFSCC* _msg = _internal_mutable_controlfscc();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlFSCC.controlFSCC)
  return _msg;
}
inline void SolarControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  if (controlfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlfscc));
    if (message_arena != submessage_arena) {
      controlfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }

  } else {

  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlFSCC.controlFSCC)
}

// .solarmodule.SolarControlScheduleFSCH SolarControlScheduleFSCH = 2;
inline bool SolarControlFSCC::_internal_has_solarcontrolschedulefsch() const {
  return this != internal_default_instance() && _impl_.solarcontrolschedulefsch_ != nullptr;
}
inline bool SolarControlFSCC::has_solarcontrolschedulefsch() const {
  return _internal_has_solarcontrolschedulefsch();
}
inline void SolarControlFSCC::clear_solarcontrolschedulefsch() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcontrolschedulefsch_ != nullptr) {
    delete _impl_.solarcontrolschedulefsch_;
  }
  _impl_.solarcontrolschedulefsch_ = nullptr;
}
inline const ::solarmodule::SolarControlScheduleFSCH& SolarControlFSCC::_internal_solarcontrolschedulefsch() const {
  const ::solarmodule::SolarControlScheduleFSCH* p = _impl_.solarcontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarControlScheduleFSCH&>(
      ::solarmodule::_SolarControlScheduleFSCH_default_instance_);
}
inline const ::solarmodule::SolarControlScheduleFSCH& SolarControlFSCC::solarcontrolschedulefsch() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
  return _internal_solarcontrolschedulefsch();
}
inline void SolarControlFSCC::unsafe_arena_set_allocated_solarcontrolschedulefsch(
    ::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcontrolschedulefsch_);
  }
  _impl_.solarcontrolschedulefsch_ = solarcontrolschedulefsch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
}
inline ::solarmodule::SolarControlScheduleFSCH* SolarControlFSCC::release_solarcontrolschedulefsch() {
  
  ::solarmodule::SolarControlScheduleFSCH* temp = _impl_.solarcontrolschedulefsch_;
  _impl_.solarcontrolschedulefsch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarControlScheduleFSCH* SolarControlFSCC::unsafe_arena_release_solarcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
  
  ::solarmodule::SolarControlScheduleFSCH* temp = _impl_.solarcontrolschedulefsch_;
  _impl_.solarcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarControlScheduleFSCH* SolarControlFSCC::_internal_mutable_solarcontrolschedulefsch() {
  
  if (_impl_.solarcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarControlScheduleFSCH>(GetArenaForAllocation());
    _impl_.solarcontrolschedulefsch_ = p;
  }
  return _impl_.solarcontrolschedulefsch_;
}
inline ::solarmodule::SolarControlScheduleFSCH* SolarControlFSCC::mutable_solarcontrolschedulefsch() {
  ::solarmodule::SolarControlScheduleFSCH* _msg = _internal_mutable_solarcontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
  return _msg;
}
inline void SolarControlFSCC::set_allocated_solarcontrolschedulefsch(::solarmodule::SolarControlScheduleFSCH* solarcontrolschedulefsch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcontrolschedulefsch_;
  }
  if (solarcontrolschedulefsch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcontrolschedulefsch);
    if (message_arena != submessage_arena) {
      solarcontrolschedulefsch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcontrolschedulefsch, submessage_arena);
    }

  } else {

  }
  _impl_.solarcontrolschedulefsch_ = solarcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlFSCC.SolarControlScheduleFSCH)
}

// -------------------------------------------------------------------

// SolarControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool SolarControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& SolarControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& SolarControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControl.controlValue)
  return _internal_controlvalue();
}
inline void SolarControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControl.controlValue)
}
inline ::commonmodule::ControlValue* SolarControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* SolarControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* SolarControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* SolarControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControl.controlValue)
  return _msg;
}
inline void SolarControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool SolarControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool SolarControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& SolarControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& SolarControl::check() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControl.check)
  return _internal_check();
}
inline void SolarControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControl.check)
}
inline ::commonmodule::CheckConditions* SolarControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* SolarControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* SolarControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* SolarControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControl.check)
  return _msg;
}
inline void SolarControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControl.check)
}

// .solarmodule.SolarControlFSCC solarControlFSCC = 3;
inline bool SolarControl::_internal_has_solarcontrolfscc() const {
  return this != internal_default_instance() && _impl_.solarcontrolfscc_ != nullptr;
}
inline bool SolarControl::has_solarcontrolfscc() const {
  return _internal_has_solarcontrolfscc();
}
inline void SolarControl::clear_solarcontrolfscc() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcontrolfscc_ != nullptr) {
    delete _impl_.solarcontrolfscc_;
  }
  _impl_.solarcontrolfscc_ = nullptr;
}
inline const ::solarmodule::SolarControlFSCC& SolarControl::_internal_solarcontrolfscc() const {
  const ::solarmodule::SolarControlFSCC* p = _impl_.solarcontrolfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarControlFSCC&>(
      ::solarmodule::_SolarControlFSCC_default_instance_);
}
inline const ::solarmodule::SolarControlFSCC& SolarControl::solarcontrolfscc() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControl.solarControlFSCC)
  return _internal_solarcontrolfscc();
}
inline void SolarControl::unsafe_arena_set_allocated_solarcontrolfscc(
    ::solarmodule::SolarControlFSCC* solarcontrolfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcontrolfscc_);
  }
  _impl_.solarcontrolfscc_ = solarcontrolfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControl.solarControlFSCC)
}
inline ::solarmodule::SolarControlFSCC* SolarControl::release_solarcontrolfscc() {
  
  ::solarmodule::SolarControlFSCC* temp = _impl_.solarcontrolfscc_;
  _impl_.solarcontrolfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarControlFSCC* SolarControl::unsafe_arena_release_solarcontrolfscc() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControl.solarControlFSCC)
  
  ::solarmodule::SolarControlFSCC* temp = _impl_.solarcontrolfscc_;
  _impl_.solarcontrolfscc_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarControlFSCC* SolarControl::_internal_mutable_solarcontrolfscc() {
  
  if (_impl_.solarcontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarControlFSCC>(GetArenaForAllocation());
    _impl_.solarcontrolfscc_ = p;
  }
  return _impl_.solarcontrolfscc_;
}
inline ::solarmodule::SolarControlFSCC* SolarControl::mutable_solarcontrolfscc() {
  ::solarmodule::SolarControlFSCC* _msg = _internal_mutable_solarcontrolfscc();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControl.solarControlFSCC)
  return _msg;
}
inline void SolarControl::set_allocated_solarcontrolfscc(::solarmodule::SolarControlFSCC* solarcontrolfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcontrolfscc_;
  }
  if (solarcontrolfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcontrolfscc);
    if (message_arena != submessage_arena) {
      solarcontrolfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcontrolfscc, submessage_arena);
    }

  } else {

  }
  _impl_.solarcontrolfscc_ = solarcontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControl.solarControlFSCC)
}

// -------------------------------------------------------------------

// SolarControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool SolarControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& SolarControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& SolarControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void SolarControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* SolarControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SolarControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SolarControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* SolarControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlProfile.controlMessageInfo)
  return _msg;
}
inline void SolarControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlProfile.controlMessageInfo)
}

// .solarmodule.SolarControl solarControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarControlProfile::_internal_has_solarcontrol() const {
  return this != internal_default_instance() && _impl_.solarcontrol_ != nullptr;
}
inline bool SolarControlProfile::has_solarcontrol() const {
  return _internal_has_solarcontrol();
}
inline void SolarControlProfile::clear_solarcontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarcontrol_ != nullptr) {
    delete _impl_.solarcontrol_;
  }
  _impl_.solarcontrol_ = nullptr;
}
inline const ::solarmodule::SolarControl& SolarControlProfile::_internal_solarcontrol() const {
  const ::solarmodule::SolarControl* p = _impl_.solarcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarControl&>(
      ::solarmodule::_SolarControl_default_instance_);
}
inline const ::solarmodule::SolarControl& SolarControlProfile::solarcontrol() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlProfile.solarControl)
  return _internal_solarcontrol();
}
inline void SolarControlProfile::unsafe_arena_set_allocated_solarcontrol(
    ::solarmodule::SolarControl* solarcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarcontrol_);
  }
  _impl_.solarcontrol_ = solarcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControlProfile.solarControl)
}
inline ::solarmodule::SolarControl* SolarControlProfile::release_solarcontrol() {
  
  ::solarmodule::SolarControl* temp = _impl_.solarcontrol_;
  _impl_.solarcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarControl* SolarControlProfile::unsafe_arena_release_solarcontrol() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlProfile.solarControl)
  
  ::solarmodule::SolarControl* temp = _impl_.solarcontrol_;
  _impl_.solarcontrol_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarControl* SolarControlProfile::_internal_mutable_solarcontrol() {
  
  if (_impl_.solarcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarControl>(GetArenaForAllocation());
    _impl_.solarcontrol_ = p;
  }
  return _impl_.solarcontrol_;
}
inline ::solarmodule::SolarControl* SolarControlProfile::mutable_solarcontrol() {
  ::solarmodule::SolarControl* _msg = _internal_mutable_solarcontrol();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlProfile.solarControl)
  return _msg;
}
inline void SolarControlProfile::set_allocated_solarcontrol(::solarmodule::SolarControl* solarcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarcontrol_;
  }
  if (solarcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarcontrol);
    if (message_arena != submessage_arena) {
      solarcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.solarcontrol_ = solarcontrol;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlProfile.solarControl)
}

// .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarControlProfile::_internal_has_solarinverter() const {
  return this != internal_default_instance() && _impl_.solarinverter_ != nullptr;
}
inline bool SolarControlProfile::has_solarinverter() const {
  return _internal_has_solarinverter();
}
inline void SolarControlProfile::clear_solarinverter() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarinverter_ != nullptr) {
    delete _impl_.solarinverter_;
  }
  _impl_.solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarControlProfile::_internal_solarinverter() const {
  const ::solarmodule::SolarInverter* p = _impl_.solarinverter_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarInverter&>(
      ::solarmodule::_SolarInverter_default_instance_);
}
inline const ::solarmodule::SolarInverter& SolarControlProfile::solarinverter() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarControlProfile.solarInverter)
  return _internal_solarinverter();
}
inline void SolarControlProfile::unsafe_arena_set_allocated_solarinverter(
    ::solarmodule::SolarInverter* solarinverter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarinverter_);
  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarControlProfile.solarInverter)
}
inline ::solarmodule::SolarInverter* SolarControlProfile::release_solarinverter() {
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarInverter* SolarControlProfile::unsafe_arena_release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarControlProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarControlProfile::_internal_mutable_solarinverter() {
  
  if (_impl_.solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaForAllocation());
    _impl_.solarinverter_ = p;
  }
  return _impl_.solarinverter_;
}
inline ::solarmodule::SolarInverter* SolarControlProfile::mutable_solarinverter() {
  ::solarmodule::SolarInverter* _msg = _internal_mutable_solarinverter();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarControlProfile.solarInverter)
  return _msg;
}
inline void SolarControlProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarinverter_;
  }
  if (solarinverter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarinverter);
    if (message_arena != submessage_arena) {
      solarinverter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }

  } else {

  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarControlProfile.solarInverter)
}

// -------------------------------------------------------------------

// SolarDiscreteControlPV

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool SolarDiscreteControlPV::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && _impl_.logicalnodeforcontrol_ != nullptr;
}
inline bool SolarDiscreteControlPV::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline const ::commonmodule::LogicalNodeForControl& SolarDiscreteControlPV::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& SolarDiscreteControlPV::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControlPV.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void SolarDiscreteControlPV::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControlPV.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* SolarDiscreteControlPV::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* SolarDiscreteControlPV::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControlPV.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* SolarDiscreteControlPV::_internal_mutable_logicalnodeforcontrol() {
  
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaForAllocation());
    _impl_.logicalnodeforcontrol_ = p;
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* SolarDiscreteControlPV::mutable_logicalnodeforcontrol() {
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControlPV.logicalNodeForControl)
  return _msg;
}
inline void SolarDiscreteControlPV::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol));
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControlPV.logicalNodeForControl)
}

// .solarmodule.SolarPoint control = 2;
inline bool SolarDiscreteControlPV::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool SolarDiscreteControlPV::has_control() const {
  return _internal_has_control();
}
inline void SolarDiscreteControlPV::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::solarmodule::SolarPoint& SolarDiscreteControlPV::_internal_control() const {
  const ::solarmodule::SolarPoint* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarPoint&>(
      ::solarmodule::_SolarPoint_default_instance_);
}
inline const ::solarmodule::SolarPoint& SolarDiscreteControlPV::control() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControlPV.control)
  return _internal_control();
}
inline void SolarDiscreteControlPV::unsafe_arena_set_allocated_control(
    ::solarmodule::SolarPoint* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControlPV.control)
}
inline ::solarmodule::SolarPoint* SolarDiscreteControlPV::release_control() {
  
  ::solarmodule::SolarPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarPoint* SolarDiscreteControlPV::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControlPV.control)
  
  ::solarmodule::SolarPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarPoint* SolarDiscreteControlPV::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarPoint>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::solarmodule::SolarPoint* SolarDiscreteControlPV::mutable_control() {
  ::solarmodule::SolarPoint* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControlPV.control)
  return _msg;
}
inline void SolarDiscreteControlPV::set_allocated_control(::solarmodule::SolarPoint* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }

  } else {

  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControlPV.control)
}

// -------------------------------------------------------------------

// SolarDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarDiscreteControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool SolarDiscreteControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& SolarDiscreteControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& SolarDiscreteControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControl.controlValue)
  return _internal_controlvalue();
}
inline void SolarDiscreteControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControl.controlValue)
}
inline ::commonmodule::ControlValue* SolarDiscreteControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* SolarDiscreteControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* SolarDiscreteControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* SolarDiscreteControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControl.controlValue)
  return _msg;
}
inline void SolarDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool SolarDiscreteControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool SolarDiscreteControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& SolarDiscreteControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& SolarDiscreteControl::check() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControl.check)
  return _internal_check();
}
inline void SolarDiscreteControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControl.check)
}
inline ::commonmodule::CheckConditions* SolarDiscreteControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* SolarDiscreteControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* SolarDiscreteControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* SolarDiscreteControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControl.check)
  return _msg;
}
inline void SolarDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControl.check)
}

// .solarmodule.SolarDiscreteControlPV solarDiscreteControlPV = 3;
inline bool SolarDiscreteControl::_internal_has_solardiscretecontrolpv() const {
  return this != internal_default_instance() && _impl_.solardiscretecontrolpv_ != nullptr;
}
inline bool SolarDiscreteControl::has_solardiscretecontrolpv() const {
  return _internal_has_solardiscretecontrolpv();
}
inline void SolarDiscreteControl::clear_solardiscretecontrolpv() {
  if (GetArenaForAllocation() == nullptr && _impl_.solardiscretecontrolpv_ != nullptr) {
    delete _impl_.solardiscretecontrolpv_;
  }
  _impl_.solardiscretecontrolpv_ = nullptr;
}
inline const ::solarmodule::SolarDiscreteControlPV& SolarDiscreteControl::_internal_solardiscretecontrolpv() const {
  const ::solarmodule::SolarDiscreteControlPV* p = _impl_.solardiscretecontrolpv_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarDiscreteControlPV&>(
      ::solarmodule::_SolarDiscreteControlPV_default_instance_);
}
inline const ::solarmodule::SolarDiscreteControlPV& SolarDiscreteControl::solardiscretecontrolpv() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControl.solarDiscreteControlPV)
  return _internal_solardiscretecontrolpv();
}
inline void SolarDiscreteControl::unsafe_arena_set_allocated_solardiscretecontrolpv(
    ::solarmodule::SolarDiscreteControlPV* solardiscretecontrolpv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solardiscretecontrolpv_);
  }
  _impl_.solardiscretecontrolpv_ = solardiscretecontrolpv;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControl.solarDiscreteControlPV)
}
inline ::solarmodule::SolarDiscreteControlPV* SolarDiscreteControl::release_solardiscretecontrolpv() {
  
  ::solarmodule::SolarDiscreteControlPV* temp = _impl_.solardiscretecontrolpv_;
  _impl_.solardiscretecontrolpv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarDiscreteControlPV* SolarDiscreteControl::unsafe_arena_release_solardiscretecontrolpv() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControl.solarDiscreteControlPV)
  
  ::solarmodule::SolarDiscreteControlPV* temp = _impl_.solardiscretecontrolpv_;
  _impl_.solardiscretecontrolpv_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarDiscreteControlPV* SolarDiscreteControl::_internal_mutable_solardiscretecontrolpv() {
  
  if (_impl_.solardiscretecontrolpv_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarDiscreteControlPV>(GetArenaForAllocation());
    _impl_.solardiscretecontrolpv_ = p;
  }
  return _impl_.solardiscretecontrolpv_;
}
inline ::solarmodule::SolarDiscreteControlPV* SolarDiscreteControl::mutable_solardiscretecontrolpv() {
  ::solarmodule::SolarDiscreteControlPV* _msg = _internal_mutable_solardiscretecontrolpv();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControl.solarDiscreteControlPV)
  return _msg;
}
inline void SolarDiscreteControl::set_allocated_solardiscretecontrolpv(::solarmodule::SolarDiscreteControlPV* solardiscretecontrolpv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solardiscretecontrolpv_;
  }
  if (solardiscretecontrolpv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solardiscretecontrolpv);
    if (message_arena != submessage_arena) {
      solardiscretecontrolpv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solardiscretecontrolpv, submessage_arena);
    }

  } else {

  }
  _impl_.solardiscretecontrolpv_ = solardiscretecontrolpv;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControl.solarDiscreteControlPV)
}

// -------------------------------------------------------------------

// SolarDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarDiscreteControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool SolarDiscreteControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& SolarDiscreteControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& SolarDiscreteControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void SolarDiscreteControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* SolarDiscreteControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SolarDiscreteControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SolarDiscreteControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* SolarDiscreteControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControlProfile.controlMessageInfo)
  return _msg;
}
inline void SolarDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControlProfile.controlMessageInfo)
}

// .solarmodule.SolarDiscreteControl solarDiscreteControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarDiscreteControlProfile::_internal_has_solardiscretecontrol() const {
  return this != internal_default_instance() && _impl_.solardiscretecontrol_ != nullptr;
}
inline bool SolarDiscreteControlProfile::has_solardiscretecontrol() const {
  return _internal_has_solardiscretecontrol();
}
inline void SolarDiscreteControlProfile::clear_solardiscretecontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.solardiscretecontrol_ != nullptr) {
    delete _impl_.solardiscretecontrol_;
  }
  _impl_.solardiscretecontrol_ = nullptr;
}
inline const ::solarmodule::SolarDiscreteControl& SolarDiscreteControlProfile::_internal_solardiscretecontrol() const {
  const ::solarmodule::SolarDiscreteControl* p = _impl_.solardiscretecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarDiscreteControl&>(
      ::solarmodule::_SolarDiscreteControl_default_instance_);
}
inline const ::solarmodule::SolarDiscreteControl& SolarDiscreteControlProfile::solardiscretecontrol() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControlProfile.solarDiscreteControl)
  return _internal_solardiscretecontrol();
}
inline void SolarDiscreteControlProfile::unsafe_arena_set_allocated_solardiscretecontrol(
    ::solarmodule::SolarDiscreteControl* solardiscretecontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solardiscretecontrol_);
  }
  _impl_.solardiscretecontrol_ = solardiscretecontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControlProfile.solarDiscreteControl)
}
inline ::solarmodule::SolarDiscreteControl* SolarDiscreteControlProfile::release_solardiscretecontrol() {
  
  ::solarmodule::SolarDiscreteControl* temp = _impl_.solardiscretecontrol_;
  _impl_.solardiscretecontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarDiscreteControl* SolarDiscreteControlProfile::unsafe_arena_release_solardiscretecontrol() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControlProfile.solarDiscreteControl)
  
  ::solarmodule::SolarDiscreteControl* temp = _impl_.solardiscretecontrol_;
  _impl_.solardiscretecontrol_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarDiscreteControl* SolarDiscreteControlProfile::_internal_mutable_solardiscretecontrol() {
  
  if (_impl_.solardiscretecontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarDiscreteControl>(GetArenaForAllocation());
    _impl_.solardiscretecontrol_ = p;
  }
  return _impl_.solardiscretecontrol_;
}
inline ::solarmodule::SolarDiscreteControl* SolarDiscreteControlProfile::mutable_solardiscretecontrol() {
  ::solarmodule::SolarDiscreteControl* _msg = _internal_mutable_solardiscretecontrol();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControlProfile.solarDiscreteControl)
  return _msg;
}
inline void SolarDiscreteControlProfile::set_allocated_solardiscretecontrol(::solarmodule::SolarDiscreteControl* solardiscretecontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solardiscretecontrol_;
  }
  if (solardiscretecontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solardiscretecontrol);
    if (message_arena != submessage_arena) {
      solardiscretecontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solardiscretecontrol, submessage_arena);
    }

  } else {

  }
  _impl_.solardiscretecontrol_ = solardiscretecontrol;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControlProfile.solarDiscreteControl)
}

// .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarDiscreteControlProfile::_internal_has_solarinverter() const {
  return this != internal_default_instance() && _impl_.solarinverter_ != nullptr;
}
inline bool SolarDiscreteControlProfile::has_solarinverter() const {
  return _internal_has_solarinverter();
}
inline void SolarDiscreteControlProfile::clear_solarinverter() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarinverter_ != nullptr) {
    delete _impl_.solarinverter_;
  }
  _impl_.solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarDiscreteControlProfile::_internal_solarinverter() const {
  const ::solarmodule::SolarInverter* p = _impl_.solarinverter_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarInverter&>(
      ::solarmodule::_SolarInverter_default_instance_);
}
inline const ::solarmodule::SolarInverter& SolarDiscreteControlProfile::solarinverter() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarDiscreteControlProfile.solarInverter)
  return _internal_solarinverter();
}
inline void SolarDiscreteControlProfile::unsafe_arena_set_allocated_solarinverter(
    ::solarmodule::SolarInverter* solarinverter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarinverter_);
  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarDiscreteControlProfile.solarInverter)
}
inline ::solarmodule::SolarInverter* SolarDiscreteControlProfile::release_solarinverter() {
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarInverter* SolarDiscreteControlProfile::unsafe_arena_release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarDiscreteControlProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarDiscreteControlProfile::_internal_mutable_solarinverter() {
  
  if (_impl_.solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaForAllocation());
    _impl_.solarinverter_ = p;
  }
  return _impl_.solarinverter_;
}
inline ::solarmodule::SolarInverter* SolarDiscreteControlProfile::mutable_solarinverter() {
  ::solarmodule::SolarInverter* _msg = _internal_mutable_solarinverter();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarDiscreteControlProfile.solarInverter)
  return _msg;
}
inline void SolarDiscreteControlProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarinverter_;
  }
  if (solarinverter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarinverter);
    if (message_arena != submessage_arena) {
      solarinverter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }

  } else {

  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarDiscreteControlProfile.solarInverter)
}

// -------------------------------------------------------------------

// SolarPointStatus

// .commonmodule.StatusSPS frequencySetPointEnabled = 1;
inline bool SolarPointStatus::_internal_has_frequencysetpointenabled() const {
  return this != internal_default_instance() && _impl_.frequencysetpointenabled_ != nullptr;
}
inline bool SolarPointStatus::has_frequencysetpointenabled() const {
  return _internal_has_frequencysetpointenabled();
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::_internal_frequencysetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.frequencysetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::frequencysetpointenabled() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.frequencySetPointEnabled)
  return _internal_frequencysetpointenabled();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_frequencysetpointenabled(
    ::commonmodule::StatusSPS* frequencysetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpointenabled_);
  }
  _impl_.frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.frequencySetPointEnabled)
}
inline ::commonmodule::StatusSPS* SolarPointStatus::release_frequencysetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.frequencysetpointenabled_;
  _impl_.frequencysetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::unsafe_arena_release_frequencysetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.frequencySetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.frequencysetpointenabled_;
  _impl_.frequencysetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::_internal_mutable_frequencysetpointenabled() {
  
  if (_impl_.frequencysetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.frequencysetpointenabled_ = p;
  }
  return _impl_.frequencysetpointenabled_;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::mutable_frequencysetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_frequencysetpointenabled();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.frequencySetPointEnabled)
  return _msg;
}
inline void SolarPointStatus::set_allocated_frequencysetpointenabled(::commonmodule::StatusSPS* frequencysetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpointenabled_);
  }
  if (frequencysetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequencysetpointenabled));
    if (message_arena != submessage_arena) {
      frequencysetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencysetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.frequencySetPointEnabled)
}

// .commonmodule.ENG_GridConnectModeKind mode = 2;
inline bool SolarPointStatus::_internal_has_mode() const {
  return this != internal_default_instance() && _impl_.mode_ != nullptr;
}
inline bool SolarPointStatus::has_mode() const {
  return _internal_has_mode();
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarPointStatus::_internal_mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(
      ::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarPointStatus::mode() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.mode)
  return _internal_mode();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_mode(
    ::commonmodule::ENG_GridConnectModeKind* mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.mode)
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPointStatus::release_mode() {
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPointStatus::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPointStatus::_internal_mutable_mode() {
  
  if (_impl_.mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaForAllocation());
    _impl_.mode_ = p;
  }
  return _impl_.mode_;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarPointStatus::mutable_mode() {
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.mode)
  return _msg;
}
inline void SolarPointStatus::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  if (mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mode));
    if (message_arena != submessage_arena) {
      mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }

  } else {

  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.mode)
}

// .google.protobuf.FloatValue pctHzDroop = 3;
inline bool SolarPointStatus::_internal_has_pcthzdroop() const {
  return this != internal_default_instance() && _impl_.pcthzdroop_ != nullptr;
}
inline bool SolarPointStatus::has_pcthzdroop() const {
  return _internal_has_pcthzdroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SolarPointStatus::_internal_pcthzdroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pcthzdroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SolarPointStatus::pcthzdroop() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.pctHzDroop)
  return _internal_pcthzdroop();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_pcthzdroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pcthzdroop_);
  }
  _impl_.pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.pctHzDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::release_pcthzdroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pcthzdroop_;
  _impl_.pcthzdroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::unsafe_arena_release_pcthzdroop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.pctHzDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pcthzdroop_;
  _impl_.pcthzdroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::_internal_mutable_pcthzdroop() {
  
  if (_impl_.pcthzdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pcthzdroop_ = p;
  }
  return _impl_.pcthzdroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::mutable_pcthzdroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pcthzdroop();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.pctHzDroop)
  return _msg;
}
inline void SolarPointStatus::set_allocated_pcthzdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pcthzdroop_);
  }
  if (pcthzdroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcthzdroop));
    if (message_arena != submessage_arena) {
      pcthzdroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pcthzdroop, submessage_arena);
    }

  } else {

  }
  _impl_.pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.pctHzDroop)
}

// .google.protobuf.FloatValue pctVDroop = 4;
inline bool SolarPointStatus::_internal_has_pctvdroop() const {
  return this != internal_default_instance() && _impl_.pctvdroop_ != nullptr;
}
inline bool SolarPointStatus::has_pctvdroop() const {
  return _internal_has_pctvdroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SolarPointStatus::_internal_pctvdroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pctvdroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SolarPointStatus::pctvdroop() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.pctVDroop)
  return _internal_pctvdroop();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_pctvdroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pctvdroop_);
  }
  _impl_.pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.pctVDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::release_pctvdroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pctvdroop_;
  _impl_.pctvdroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::unsafe_arena_release_pctvdroop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.pctVDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pctvdroop_;
  _impl_.pctvdroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::_internal_mutable_pctvdroop() {
  
  if (_impl_.pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pctvdroop_ = p;
  }
  return _impl_.pctvdroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SolarPointStatus::mutable_pctvdroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pctvdroop();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.pctVDroop)
  return _msg;
}
inline void SolarPointStatus::set_allocated_pctvdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pctvdroop_);
  }
  if (pctvdroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pctvdroop));
    if (message_arena != submessage_arena) {
      pctvdroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }

  } else {

  }
  _impl_.pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.pctVDroop)
}

// .commonmodule.RampRate rampRates = 5;
inline bool SolarPointStatus::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool SolarPointStatus::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& SolarPointStatus::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& SolarPointStatus::ramprates() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.rampRates)
  return _internal_ramprates();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.rampRates)
}
inline ::commonmodule::RampRate* SolarPointStatus::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* SolarPointStatus::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* SolarPointStatus::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* SolarPointStatus::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.rampRates)
  return _msg;
}
inline void SolarPointStatus::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.rampRates)
}

// .commonmodule.StatusSPS reactivePwrSetPointEnabled = 6;
inline bool SolarPointStatus::_internal_has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.reactivepwrsetpointenabled_ != nullptr;
}
inline bool SolarPointStatus::has_reactivepwrsetpointenabled() const {
  return _internal_has_reactivepwrsetpointenabled();
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::_internal_reactivepwrsetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.reactivepwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::reactivepwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
  return _internal_reactivepwrsetpointenabled();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_reactivepwrsetpointenabled(
    ::commonmodule::StatusSPS* reactivepwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
}
inline ::commonmodule::StatusSPS* SolarPointStatus::release_reactivepwrsetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::unsafe_arena_release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::_internal_mutable_reactivepwrsetpointenabled() {
  
  if (_impl_.reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.reactivepwrsetpointenabled_ = p;
  }
  return _impl_.reactivepwrsetpointenabled_;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::mutable_reactivepwrsetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_reactivepwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
  return _msg;
}
inline void SolarPointStatus::set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPS* reactivepwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reactivepwrsetpointenabled));
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.reactivePwrSetPointEnabled)
}

// .commonmodule.StatusSPS realPwrSetPointEnabled = 7;
inline bool SolarPointStatus::_internal_has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.realpwrsetpointenabled_ != nullptr;
}
inline bool SolarPointStatus::has_realpwrsetpointenabled() const {
  return _internal_has_realpwrsetpointenabled();
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::_internal_realpwrsetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.realpwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::realpwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
  return _internal_realpwrsetpointenabled();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_realpwrsetpointenabled(
    ::commonmodule::StatusSPS* realpwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
}
inline ::commonmodule::StatusSPS* SolarPointStatus::release_realpwrsetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::unsafe_arena_release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::_internal_mutable_realpwrsetpointenabled() {
  
  if (_impl_.realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.realpwrsetpointenabled_ = p;
  }
  return _impl_.realpwrsetpointenabled_;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::mutable_realpwrsetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_realpwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
  return _msg;
}
inline void SolarPointStatus::set_allocated_realpwrsetpointenabled(::commonmodule::StatusSPS* realpwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(realpwrsetpointenabled));
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.realPwrSetPointEnabled)
}

// .commonmodule.Optional_StateKind state = 8;
inline bool SolarPointStatus::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool SolarPointStatus::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& SolarPointStatus::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& SolarPointStatus::state() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.state)
  return _internal_state();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.state)
}
inline ::commonmodule::Optional_StateKind* SolarPointStatus::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* SolarPointStatus::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* SolarPointStatus::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* SolarPointStatus::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.state)
  return _msg;
}
inline void SolarPointStatus::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.state)
}

// .commonmodule.StatusSPS voltageSetPointEnabled = 9;
inline bool SolarPointStatus::_internal_has_voltagesetpointenabled() const {
  return this != internal_default_instance() && _impl_.voltagesetpointenabled_ != nullptr;
}
inline bool SolarPointStatus::has_voltagesetpointenabled() const {
  return _internal_has_voltagesetpointenabled();
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::_internal_voltagesetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.voltagesetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& SolarPointStatus::voltagesetpointenabled() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.voltageSetPointEnabled)
  return _internal_voltagesetpointenabled();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_voltagesetpointenabled(
    ::commonmodule::StatusSPS* voltagesetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.voltageSetPointEnabled)
}
inline ::commonmodule::StatusSPS* SolarPointStatus::release_voltagesetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::unsafe_arena_release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.voltageSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::_internal_mutable_voltagesetpointenabled() {
  
  if (_impl_.voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.voltagesetpointenabled_ = p;
  }
  return _impl_.voltagesetpointenabled_;
}
inline ::commonmodule::StatusSPS* SolarPointStatus::mutable_voltagesetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_voltagesetpointenabled();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.voltageSetPointEnabled)
  return _msg;
}
inline void SolarPointStatus::set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* voltagesetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesetpointenabled));
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.voltageSetPointEnabled)
}

// .commonmodule.ControlSPC blackStartEnabled = 10;
inline bool SolarPointStatus::_internal_has_blackstartenabled() const {
  return this != internal_default_instance() && _impl_.blackstartenabled_ != nullptr;
}
inline bool SolarPointStatus::has_blackstartenabled() const {
  return _internal_has_blackstartenabled();
}
inline const ::commonmodule::ControlSPC& SolarPointStatus::_internal_blackstartenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.blackstartenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& SolarPointStatus::blackstartenabled() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.blackStartEnabled)
  return _internal_blackstartenabled();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_blackstartenabled(
    ::commonmodule::ControlSPC* blackstartenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.blackStartEnabled)
}
inline ::commonmodule::ControlSPC* SolarPointStatus::release_blackstartenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPointStatus::unsafe_arena_release_blackstartenabled() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.blackStartEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPointStatus::_internal_mutable_blackstartenabled() {
  
  if (_impl_.blackstartenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.blackstartenabled_ = p;
  }
  return _impl_.blackstartenabled_;
}
inline ::commonmodule::ControlSPC* SolarPointStatus::mutable_blackstartenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_blackstartenabled();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.blackStartEnabled)
  return _msg;
}
inline void SolarPointStatus::set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  if (blackstartenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blackstartenabled));
    if (message_arena != submessage_arena) {
      blackstartenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blackstartenabled, submessage_arena);
    }

  } else {

  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.blackStartEnabled)
}

// .commonmodule.EnterServiceAPC enterServiceOperation = 11;
inline bool SolarPointStatus::_internal_has_enterserviceoperation() const {
  return this != internal_default_instance() && _impl_.enterserviceoperation_ != nullptr;
}
inline bool SolarPointStatus::has_enterserviceoperation() const {
  return _internal_has_enterserviceoperation();
}
inline const ::commonmodule::EnterServiceAPC& SolarPointStatus::_internal_enterserviceoperation() const {
  const ::commonmodule::EnterServiceAPC* p = _impl_.enterserviceoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnterServiceAPC&>(
      ::commonmodule::_EnterServiceAPC_default_instance_);
}
inline const ::commonmodule::EnterServiceAPC& SolarPointStatus::enterserviceoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.enterServiceOperation)
  return _internal_enterserviceoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_enterserviceoperation(
    ::commonmodule::EnterServiceAPC* enterserviceoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.enterServiceOperation)
}
inline ::commonmodule::EnterServiceAPC* SolarPointStatus::release_enterserviceoperation() {
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnterServiceAPC* SolarPointStatus::unsafe_arena_release_enterserviceoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.enterServiceOperation)
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::EnterServiceAPC* SolarPointStatus::_internal_mutable_enterserviceoperation() {
  
  if (_impl_.enterserviceoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnterServiceAPC>(GetArenaForAllocation());
    _impl_.enterserviceoperation_ = p;
  }
  return _impl_.enterserviceoperation_;
}
inline ::commonmodule::EnterServiceAPC* SolarPointStatus::mutable_enterserviceoperation() {
  ::commonmodule::EnterServiceAPC* _msg = _internal_mutable_enterserviceoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.enterServiceOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  if (enterserviceoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enterserviceoperation));
    if (message_arena != submessage_arena) {
      enterserviceoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enterserviceoperation, submessage_arena);
    }

  } else {

  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.enterServiceOperation)
}

// .commonmodule.HzWPoint hzWOperation = 12;
inline bool SolarPointStatus::_internal_has_hzwoperation() const {
  return this != internal_default_instance() && _impl_.hzwoperation_ != nullptr;
}
inline bool SolarPointStatus::has_hzwoperation() const {
  return _internal_has_hzwoperation();
}
inline const ::commonmodule::HzWPoint& SolarPointStatus::_internal_hzwoperation() const {
  const ::commonmodule::HzWPoint* p = _impl_.hzwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWPoint&>(
      ::commonmodule::_HzWPoint_default_instance_);
}
inline const ::commonmodule::HzWPoint& SolarPointStatus::hzwoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.hzWOperation)
  return _internal_hzwoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_hzwoperation(
    ::commonmodule::HzWPoint* hzwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.hzWOperation)
}
inline ::commonmodule::HzWPoint* SolarPointStatus::release_hzwoperation() {
  
  ::commonmodule::HzWPoint* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::HzWPoint* SolarPointStatus::unsafe_arena_release_hzwoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.hzWOperation)
  
  ::commonmodule::HzWPoint* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWPoint* SolarPointStatus::_internal_mutable_hzwoperation() {
  
  if (_impl_.hzwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::HzWPoint>(GetArenaForAllocation());
    _impl_.hzwoperation_ = p;
  }
  return _impl_.hzwoperation_;
}
inline ::commonmodule::HzWPoint* SolarPointStatus::mutable_hzwoperation() {
  ::commonmodule::HzWPoint* _msg = _internal_mutable_hzwoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.hzWOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_hzwoperation(::commonmodule::HzWPoint* hzwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  if (hzwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hzwoperation));
    if (message_arena != submessage_arena) {
      hzwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hzwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.hzWOperation)
}

// .commonmodule.LimitWAPC limitWOperation = 13;
inline bool SolarPointStatus::_internal_has_limitwoperation() const {
  return this != internal_default_instance() && _impl_.limitwoperation_ != nullptr;
}
inline bool SolarPointStatus::has_limitwoperation() const {
  return _internal_has_limitwoperation();
}
inline const ::commonmodule::LimitWAPC& SolarPointStatus::_internal_limitwoperation() const {
  const ::commonmodule::LimitWAPC* p = _impl_.limitwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LimitWAPC&>(
      ::commonmodule::_LimitWAPC_default_instance_);
}
inline const ::commonmodule::LimitWAPC& SolarPointStatus::limitwoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.limitWOperation)
  return _internal_limitwoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_limitwoperation(
    ::commonmodule::LimitWAPC* limitwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.limitWOperation)
}
inline ::commonmodule::LimitWAPC* SolarPointStatus::release_limitwoperation() {
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LimitWAPC* SolarPointStatus::unsafe_arena_release_limitwoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.limitWOperation)
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::LimitWAPC* SolarPointStatus::_internal_mutable_limitwoperation() {
  
  if (_impl_.limitwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LimitWAPC>(GetArenaForAllocation());
    _impl_.limitwoperation_ = p;
  }
  return _impl_.limitwoperation_;
}
inline ::commonmodule::LimitWAPC* SolarPointStatus::mutable_limitwoperation() {
  ::commonmodule::LimitWAPC* _msg = _internal_mutable_limitwoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.limitWOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  if (limitwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limitwoperation));
    if (message_arena != submessage_arena) {
      limitwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limitwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.limitWOperation)
}

// .commonmodule.PFSPC pFOperation = 14;
inline bool SolarPointStatus::_internal_has_pfoperation() const {
  return this != internal_default_instance() && _impl_.pfoperation_ != nullptr;
}
inline bool SolarPointStatus::has_pfoperation() const {
  return _internal_has_pfoperation();
}
inline const ::commonmodule::PFSPC& SolarPointStatus::_internal_pfoperation() const {
  const ::commonmodule::PFSPC* p = _impl_.pfoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PFSPC&>(
      ::commonmodule::_PFSPC_default_instance_);
}
inline const ::commonmodule::PFSPC& SolarPointStatus::pfoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.pFOperation)
  return _internal_pfoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_pfoperation(
    ::commonmodule::PFSPC* pfoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.pFOperation)
}
inline ::commonmodule::PFSPC* SolarPointStatus::release_pfoperation() {
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PFSPC* SolarPointStatus::unsafe_arena_release_pfoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.pFOperation)
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::PFSPC* SolarPointStatus::_internal_mutable_pfoperation() {
  
  if (_impl_.pfoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PFSPC>(GetArenaForAllocation());
    _impl_.pfoperation_ = p;
  }
  return _impl_.pfoperation_;
}
inline ::commonmodule::PFSPC* SolarPointStatus::mutable_pfoperation() {
  ::commonmodule::PFSPC* _msg = _internal_mutable_pfoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.pFOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  if (pfoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pfoperation));
    if (message_arena != submessage_arena) {
      pfoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pfoperation, submessage_arena);
    }

  } else {

  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.pFOperation)
}

// .commonmodule.ControlSPC syncBackToGrid = 15;
inline bool SolarPointStatus::_internal_has_syncbacktogrid() const {
  return this != internal_default_instance() && _impl_.syncbacktogrid_ != nullptr;
}
inline bool SolarPointStatus::has_syncbacktogrid() const {
  return _internal_has_syncbacktogrid();
}
inline const ::commonmodule::ControlSPC& SolarPointStatus::_internal_syncbacktogrid() const {
  const ::commonmodule::ControlSPC* p = _impl_.syncbacktogrid_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& SolarPointStatus::syncbacktogrid() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.syncBackToGrid)
  return _internal_syncbacktogrid();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_syncbacktogrid(
    ::commonmodule::ControlSPC* syncbacktogrid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.syncbacktogrid_);
  }
  _impl_.syncbacktogrid_ = syncbacktogrid;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.syncBackToGrid)
}
inline ::commonmodule::ControlSPC* SolarPointStatus::release_syncbacktogrid() {
  
  ::commonmodule::ControlSPC* temp = _impl_.syncbacktogrid_;
  _impl_.syncbacktogrid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPointStatus::unsafe_arena_release_syncbacktogrid() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.syncBackToGrid)
  
  ::commonmodule::ControlSPC* temp = _impl_.syncbacktogrid_;
  _impl_.syncbacktogrid_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* SolarPointStatus::_internal_mutable_syncbacktogrid() {
  
  if (_impl_.syncbacktogrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.syncbacktogrid_ = p;
  }
  return _impl_.syncbacktogrid_;
}
inline ::commonmodule::ControlSPC* SolarPointStatus::mutable_syncbacktogrid() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_syncbacktogrid();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.syncBackToGrid)
  return _msg;
}
inline void SolarPointStatus::set_allocated_syncbacktogrid(::commonmodule::ControlSPC* syncbacktogrid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.syncbacktogrid_);
  }
  if (syncbacktogrid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(syncbacktogrid));
    if (message_arena != submessage_arena) {
      syncbacktogrid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, syncbacktogrid, submessage_arena);
    }

  } else {

  }
  _impl_.syncbacktogrid_ = syncbacktogrid;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.syncBackToGrid)
}

// .commonmodule.TmHzCSG tmHzTripOperation = 16;
inline bool SolarPointStatus::_internal_has_tmhztripoperation() const {
  return this != internal_default_instance() && _impl_.tmhztripoperation_ != nullptr;
}
inline bool SolarPointStatus::has_tmhztripoperation() const {
  return _internal_has_tmhztripoperation();
}
inline const ::commonmodule::TmHzCSG& SolarPointStatus::_internal_tmhztripoperation() const {
  const ::commonmodule::TmHzCSG* p = _impl_.tmhztripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmHzCSG&>(
      ::commonmodule::_TmHzCSG_default_instance_);
}
inline const ::commonmodule::TmHzCSG& SolarPointStatus::tmhztripoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.tmHzTripOperation)
  return _internal_tmhztripoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_tmhztripoperation(
    ::commonmodule::TmHzCSG* tmhztripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.tmHzTripOperation)
}
inline ::commonmodule::TmHzCSG* SolarPointStatus::release_tmhztripoperation() {
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmHzCSG* SolarPointStatus::unsafe_arena_release_tmhztripoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.tmHzTripOperation)
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmHzCSG* SolarPointStatus::_internal_mutable_tmhztripoperation() {
  
  if (_impl_.tmhztripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmHzCSG>(GetArenaForAllocation());
    _impl_.tmhztripoperation_ = p;
  }
  return _impl_.tmhztripoperation_;
}
inline ::commonmodule::TmHzCSG* SolarPointStatus::mutable_tmhztripoperation() {
  ::commonmodule::TmHzCSG* _msg = _internal_mutable_tmhztripoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.tmHzTripOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  if (tmhztripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmhztripoperation));
    if (message_arena != submessage_arena) {
      tmhztripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmhztripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.tmHzTripOperation)
}

// .commonmodule.TmVoltCSG tmVoltTripOperation = 17;
inline bool SolarPointStatus::_internal_has_tmvolttripoperation() const {
  return this != internal_default_instance() && _impl_.tmvolttripoperation_ != nullptr;
}
inline bool SolarPointStatus::has_tmvolttripoperation() const {
  return _internal_has_tmvolttripoperation();
}
inline const ::commonmodule::TmVoltCSG& SolarPointStatus::_internal_tmvolttripoperation() const {
  const ::commonmodule::TmVoltCSG* p = _impl_.tmvolttripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmVoltCSG&>(
      ::commonmodule::_TmVoltCSG_default_instance_);
}
inline const ::commonmodule::TmVoltCSG& SolarPointStatus::tmvolttripoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.tmVoltTripOperation)
  return _internal_tmvolttripoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_tmvolttripoperation(
    ::commonmodule::TmVoltCSG* tmvolttripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.tmVoltTripOperation)
}
inline ::commonmodule::TmVoltCSG* SolarPointStatus::release_tmvolttripoperation() {
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmVoltCSG* SolarPointStatus::unsafe_arena_release_tmvolttripoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.tmVoltTripOperation)
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmVoltCSG* SolarPointStatus::_internal_mutable_tmvolttripoperation() {
  
  if (_impl_.tmvolttripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmVoltCSG>(GetArenaForAllocation());
    _impl_.tmvolttripoperation_ = p;
  }
  return _impl_.tmvolttripoperation_;
}
inline ::commonmodule::TmVoltCSG* SolarPointStatus::mutable_tmvolttripoperation() {
  ::commonmodule::TmVoltCSG* _msg = _internal_mutable_tmvolttripoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.tmVoltTripOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  if (tmvolttripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmvolttripoperation));
    if (message_arena != submessage_arena) {
      tmvolttripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmvolttripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.tmVoltTripOperation)
}

// .commonmodule.VarSPC vArOperation = 18;
inline bool SolarPointStatus::_internal_has_varoperation() const {
  return this != internal_default_instance() && _impl_.varoperation_ != nullptr;
}
inline bool SolarPointStatus::has_varoperation() const {
  return _internal_has_varoperation();
}
inline const ::commonmodule::VarSPC& SolarPointStatus::_internal_varoperation() const {
  const ::commonmodule::VarSPC* p = _impl_.varoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VarSPC&>(
      ::commonmodule::_VarSPC_default_instance_);
}
inline const ::commonmodule::VarSPC& SolarPointStatus::varoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.vArOperation)
  return _internal_varoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_varoperation(
    ::commonmodule::VarSPC* varoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.vArOperation)
}
inline ::commonmodule::VarSPC* SolarPointStatus::release_varoperation() {
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VarSPC* SolarPointStatus::unsafe_arena_release_varoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.vArOperation)
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VarSPC* SolarPointStatus::_internal_mutable_varoperation() {
  
  if (_impl_.varoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VarSPC>(GetArenaForAllocation());
    _impl_.varoperation_ = p;
  }
  return _impl_.varoperation_;
}
inline ::commonmodule::VarSPC* SolarPointStatus::mutable_varoperation() {
  ::commonmodule::VarSPC* _msg = _internal_mutable_varoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.vArOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_varoperation(::commonmodule::VarSPC* varoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  if (varoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(varoperation));
    if (message_arena != submessage_arena) {
      varoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varoperation, submessage_arena);
    }

  } else {

  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.vArOperation)
}

// .commonmodule.VoltVarCSG voltVarOperation = 19;
inline bool SolarPointStatus::_internal_has_voltvaroperation() const {
  return this != internal_default_instance() && _impl_.voltvaroperation_ != nullptr;
}
inline bool SolarPointStatus::has_voltvaroperation() const {
  return _internal_has_voltvaroperation();
}
inline const ::commonmodule::VoltVarCSG& SolarPointStatus::_internal_voltvaroperation() const {
  const ::commonmodule::VoltVarCSG* p = _impl_.voltvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltVarCSG&>(
      ::commonmodule::_VoltVarCSG_default_instance_);
}
inline const ::commonmodule::VoltVarCSG& SolarPointStatus::voltvaroperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.voltVarOperation)
  return _internal_voltvaroperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_voltvaroperation(
    ::commonmodule::VoltVarCSG* voltvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.voltVarOperation)
}
inline ::commonmodule::VoltVarCSG* SolarPointStatus::release_voltvaroperation() {
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltVarCSG* SolarPointStatus::unsafe_arena_release_voltvaroperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.voltVarOperation)
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltVarCSG* SolarPointStatus::_internal_mutable_voltvaroperation() {
  
  if (_impl_.voltvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltVarCSG>(GetArenaForAllocation());
    _impl_.voltvaroperation_ = p;
  }
  return _impl_.voltvaroperation_;
}
inline ::commonmodule::VoltVarCSG* SolarPointStatus::mutable_voltvaroperation() {
  ::commonmodule::VoltVarCSG* _msg = _internal_mutable_voltvaroperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.voltVarOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  if (voltvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltvaroperation));
    if (message_arena != submessage_arena) {
      voltvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.voltVarOperation)
}

// .commonmodule.VoltWCSG voltWOperation = 20;
inline bool SolarPointStatus::_internal_has_voltwoperation() const {
  return this != internal_default_instance() && _impl_.voltwoperation_ != nullptr;
}
inline bool SolarPointStatus::has_voltwoperation() const {
  return _internal_has_voltwoperation();
}
inline const ::commonmodule::VoltWCSG& SolarPointStatus::_internal_voltwoperation() const {
  const ::commonmodule::VoltWCSG* p = _impl_.voltwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltWCSG&>(
      ::commonmodule::_VoltWCSG_default_instance_);
}
inline const ::commonmodule::VoltWCSG& SolarPointStatus::voltwoperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.voltWOperation)
  return _internal_voltwoperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_voltwoperation(
    ::commonmodule::VoltWCSG* voltwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.voltWOperation)
}
inline ::commonmodule::VoltWCSG* SolarPointStatus::release_voltwoperation() {
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltWCSG* SolarPointStatus::unsafe_arena_release_voltwoperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.voltWOperation)
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltWCSG* SolarPointStatus::_internal_mutable_voltwoperation() {
  
  if (_impl_.voltwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltWCSG>(GetArenaForAllocation());
    _impl_.voltwoperation_ = p;
  }
  return _impl_.voltwoperation_;
}
inline ::commonmodule::VoltWCSG* SolarPointStatus::mutable_voltwoperation() {
  ::commonmodule::VoltWCSG* _msg = _internal_mutable_voltwoperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.voltWOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  if (voltwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltwoperation));
    if (message_arena != submessage_arena) {
      voltwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.voltWOperation)
}

// .commonmodule.WVarCSG wVarOperation = 21;
inline bool SolarPointStatus::_internal_has_wvaroperation() const {
  return this != internal_default_instance() && _impl_.wvaroperation_ != nullptr;
}
inline bool SolarPointStatus::has_wvaroperation() const {
  return _internal_has_wvaroperation();
}
inline const ::commonmodule::WVarCSG& SolarPointStatus::_internal_wvaroperation() const {
  const ::commonmodule::WVarCSG* p = _impl_.wvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WVarCSG&>(
      ::commonmodule::_WVarCSG_default_instance_);
}
inline const ::commonmodule::WVarCSG& SolarPointStatus::wvaroperation() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarPointStatus.wVarOperation)
  return _internal_wvaroperation();
}
inline void SolarPointStatus::unsafe_arena_set_allocated_wvaroperation(
    ::commonmodule::WVarCSG* wvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarPointStatus.wVarOperation)
}
inline ::commonmodule::WVarCSG* SolarPointStatus::release_wvaroperation() {
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WVarCSG* SolarPointStatus::unsafe_arena_release_wvaroperation() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarPointStatus.wVarOperation)
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WVarCSG* SolarPointStatus::_internal_mutable_wvaroperation() {
  
  if (_impl_.wvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WVarCSG>(GetArenaForAllocation());
    _impl_.wvaroperation_ = p;
  }
  return _impl_.wvaroperation_;
}
inline ::commonmodule::WVarCSG* SolarPointStatus::mutable_wvaroperation() {
  ::commonmodule::WVarCSG* _msg = _internal_mutable_wvaroperation();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarPointStatus.wVarOperation)
  return _msg;
}
inline void SolarPointStatus::set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  if (wvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wvaroperation));
    if (message_arena != submessage_arena) {
      wvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarPointStatus.wVarOperation)
}

// -------------------------------------------------------------------

// SolarEventAndStatusZGEN

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool SolarEventAndStatusZGEN::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SolarEventAndStatusZGEN::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SolarEventAndStatusZGEN::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SolarEventAndStatusZGEN::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SolarEventAndStatusZGEN::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SolarEventAndStatusZGEN::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SolarEventAndStatusZGEN::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS AuxPwrSt = 2;
inline bool SolarEventAndStatusZGEN::_internal_has_auxpwrst() const {
  return this != internal_default_instance() && _impl_.auxpwrst_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_auxpwrst() const {
  return _internal_has_auxpwrst();
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::_internal_auxpwrst() const {
  const ::commonmodule::StatusSPS* p = _impl_.auxpwrst_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::auxpwrst() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
  return _internal_auxpwrst();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_auxpwrst(
    ::commonmodule::StatusSPS* auxpwrst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auxpwrst_);
  }
  _impl_.auxpwrst_ = auxpwrst;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::release_auxpwrst() {
  
  ::commonmodule::StatusSPS* temp = _impl_.auxpwrst_;
  _impl_.auxpwrst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::unsafe_arena_release_auxpwrst() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
  
  ::commonmodule::StatusSPS* temp = _impl_.auxpwrst_;
  _impl_.auxpwrst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::_internal_mutable_auxpwrst() {
  
  if (_impl_.auxpwrst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.auxpwrst_ = p;
  }
  return _impl_.auxpwrst_;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::mutable_auxpwrst() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_auxpwrst();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auxpwrst_);
  }
  if (auxpwrst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auxpwrst));
    if (message_arena != submessage_arena) {
      auxpwrst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auxpwrst, submessage_arena);
    }

  } else {

  }
  _impl_.auxpwrst_ = auxpwrst;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.AuxPwrSt)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
inline bool SolarEventAndStatusZGEN::_internal_has_dynamictest() const {
  return this != internal_default_instance() && _impl_.dynamictest_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_dynamictest() const {
  return _internal_has_dynamictest();
}
inline const ::commonmodule::ENS_DynamicTestKind& SolarEventAndStatusZGEN::_internal_dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(
      ::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& SolarEventAndStatusZGEN::dynamictest() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
  return _internal_dynamictest();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* dynamictest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* SolarEventAndStatusZGEN::release_dynamictest() {
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SolarEventAndStatusZGEN::unsafe_arena_release_dynamictest() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SolarEventAndStatusZGEN::_internal_mutable_dynamictest() {
  
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaForAllocation());
    _impl_.dynamictest_ = p;
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* SolarEventAndStatusZGEN::mutable_dynamictest() {
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  if (dynamictest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamictest));
    if (message_arena != submessage_arena) {
      dynamictest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }

  } else {

  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.DynamicTest)
}

// .commonmodule.StatusSPS EmgStop = 4;
inline bool SolarEventAndStatusZGEN::_internal_has_emgstop() const {
  return this != internal_default_instance() && _impl_.emgstop_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_emgstop() const {
  return _internal_has_emgstop();
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::_internal_emgstop() const {
  const ::commonmodule::StatusSPS* p = _impl_.emgstop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::emgstop() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.EmgStop)
  return _internal_emgstop();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_emgstop(
    ::commonmodule::StatusSPS* emgstop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emgstop_);
  }
  _impl_.emgstop_ = emgstop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.EmgStop)
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::release_emgstop() {
  
  ::commonmodule::StatusSPS* temp = _impl_.emgstop_;
  _impl_.emgstop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::unsafe_arena_release_emgstop() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.EmgStop)
  
  ::commonmodule::StatusSPS* temp = _impl_.emgstop_;
  _impl_.emgstop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::_internal_mutable_emgstop() {
  
  if (_impl_.emgstop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.emgstop_ = p;
  }
  return _impl_.emgstop_;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::mutable_emgstop() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_emgstop();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.EmgStop)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_emgstop(::commonmodule::StatusSPS* emgstop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emgstop_);
  }
  if (emgstop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emgstop));
    if (message_arena != submessage_arena) {
      emgstop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emgstop, submessage_arena);
    }

  } else {

  }
  _impl_.emgstop_ = emgstop;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.EmgStop)
}

// .solarmodule.SolarPointStatus PointStatus = 5;
inline bool SolarEventAndStatusZGEN::_internal_has_pointstatus() const {
  return this != internal_default_instance() && _impl_.pointstatus_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_pointstatus() const {
  return _internal_has_pointstatus();
}
inline void SolarEventAndStatusZGEN::clear_pointstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.pointstatus_ != nullptr) {
    delete _impl_.pointstatus_;
  }
  _impl_.pointstatus_ = nullptr;
}
inline const ::solarmodule::SolarPointStatus& SolarEventAndStatusZGEN::_internal_pointstatus() const {
  const ::solarmodule::SolarPointStatus* p = _impl_.pointstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarPointStatus&>(
      ::solarmodule::_SolarPointStatus_default_instance_);
}
inline const ::solarmodule::SolarPointStatus& SolarEventAndStatusZGEN::pointstatus() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.PointStatus)
  return _internal_pointstatus();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_pointstatus(
    ::solarmodule::SolarPointStatus* pointstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointstatus_);
  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.PointStatus)
}
inline ::solarmodule::SolarPointStatus* SolarEventAndStatusZGEN::release_pointstatus() {
  
  ::solarmodule::SolarPointStatus* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarPointStatus* SolarEventAndStatusZGEN::unsafe_arena_release_pointstatus() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.PointStatus)
  
  ::solarmodule::SolarPointStatus* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarPointStatus* SolarEventAndStatusZGEN::_internal_mutable_pointstatus() {
  
  if (_impl_.pointstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarPointStatus>(GetArenaForAllocation());
    _impl_.pointstatus_ = p;
  }
  return _impl_.pointstatus_;
}
inline ::solarmodule::SolarPointStatus* SolarEventAndStatusZGEN::mutable_pointstatus() {
  ::solarmodule::SolarPointStatus* _msg = _internal_mutable_pointstatus();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.PointStatus)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_pointstatus(::solarmodule::SolarPointStatus* pointstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pointstatus_;
  }
  if (pointstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pointstatus);
    if (message_arena != submessage_arena) {
      pointstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointstatus, submessage_arena);
    }

  } else {

  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.PointStatus)
}

// .commonmodule.Optional_AlrmKind Alrm = 6;
inline bool SolarEventAndStatusZGEN::_internal_has_alrm() const {
  return this != internal_default_instance() && _impl_.alrm_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_alrm() const {
  return _internal_has_alrm();
}
inline const ::commonmodule::Optional_AlrmKind& SolarEventAndStatusZGEN::_internal_alrm() const {
  const ::commonmodule::Optional_AlrmKind* p = _impl_.alrm_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_AlrmKind&>(
      ::commonmodule::_Optional_AlrmKind_default_instance_);
}
inline const ::commonmodule::Optional_AlrmKind& SolarEventAndStatusZGEN::alrm() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.Alrm)
  return _internal_alrm();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_alrm(
    ::commonmodule::Optional_AlrmKind* alrm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alrm_);
  }
  _impl_.alrm_ = alrm;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.Alrm)
}
inline ::commonmodule::Optional_AlrmKind* SolarEventAndStatusZGEN::release_alrm() {
  
  ::commonmodule::Optional_AlrmKind* temp = _impl_.alrm_;
  _impl_.alrm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_AlrmKind* SolarEventAndStatusZGEN::unsafe_arena_release_alrm() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.Alrm)
  
  ::commonmodule::Optional_AlrmKind* temp = _impl_.alrm_;
  _impl_.alrm_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_AlrmKind* SolarEventAndStatusZGEN::_internal_mutable_alrm() {
  
  if (_impl_.alrm_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_AlrmKind>(GetArenaForAllocation());
    _impl_.alrm_ = p;
  }
  return _impl_.alrm_;
}
inline ::commonmodule::Optional_AlrmKind* SolarEventAndStatusZGEN::mutable_alrm() {
  ::commonmodule::Optional_AlrmKind* _msg = _internal_mutable_alrm();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.Alrm)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_alrm(::commonmodule::Optional_AlrmKind* alrm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alrm_);
  }
  if (alrm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alrm));
    if (message_arena != submessage_arena) {
      alrm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alrm, submessage_arena);
    }

  } else {

  }
  _impl_.alrm_ = alrm;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.Alrm)
}

// .commonmodule.StatusSPS GnSynSt = 7;
inline bool SolarEventAndStatusZGEN::_internal_has_gnsynst() const {
  return this != internal_default_instance() && _impl_.gnsynst_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_gnsynst() const {
  return _internal_has_gnsynst();
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::_internal_gnsynst() const {
  const ::commonmodule::StatusSPS* p = _impl_.gnsynst_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& SolarEventAndStatusZGEN::gnsynst() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.GnSynSt)
  return _internal_gnsynst();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_gnsynst(
    ::commonmodule::StatusSPS* gnsynst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gnsynst_);
  }
  _impl_.gnsynst_ = gnsynst;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.GnSynSt)
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::release_gnsynst() {
  
  ::commonmodule::StatusSPS* temp = _impl_.gnsynst_;
  _impl_.gnsynst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::unsafe_arena_release_gnsynst() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.GnSynSt)
  
  ::commonmodule::StatusSPS* temp = _impl_.gnsynst_;
  _impl_.gnsynst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::_internal_mutable_gnsynst() {
  
  if (_impl_.gnsynst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.gnsynst_ = p;
  }
  return _impl_.gnsynst_;
}
inline ::commonmodule::StatusSPS* SolarEventAndStatusZGEN::mutable_gnsynst() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_gnsynst();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.GnSynSt)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_gnsynst(::commonmodule::StatusSPS* gnsynst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gnsynst_);
  }
  if (gnsynst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gnsynst));
    if (message_arena != submessage_arena) {
      gnsynst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gnsynst, submessage_arena);
    }

  } else {

  }
  _impl_.gnsynst_ = gnsynst;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.GnSynSt)
}

// .commonmodule.Optional_GridConnectionStateKind GridConnectionState = 8;
inline bool SolarEventAndStatusZGEN::_internal_has_gridconnectionstate() const {
  return this != internal_default_instance() && _impl_.gridconnectionstate_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_gridconnectionstate() const {
  return _internal_has_gridconnectionstate();
}
inline const ::commonmodule::Optional_GridConnectionStateKind& SolarEventAndStatusZGEN::_internal_gridconnectionstate() const {
  const ::commonmodule::Optional_GridConnectionStateKind* p = _impl_.gridconnectionstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_GridConnectionStateKind&>(
      ::commonmodule::_Optional_GridConnectionStateKind_default_instance_);
}
inline const ::commonmodule::Optional_GridConnectionStateKind& SolarEventAndStatusZGEN::gridconnectionstate() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.GridConnectionState)
  return _internal_gridconnectionstate();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_gridconnectionstate(
    ::commonmodule::Optional_GridConnectionStateKind* gridconnectionstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gridconnectionstate_);
  }
  _impl_.gridconnectionstate_ = gridconnectionstate;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.GridConnectionState)
}
inline ::commonmodule::Optional_GridConnectionStateKind* SolarEventAndStatusZGEN::release_gridconnectionstate() {
  
  ::commonmodule::Optional_GridConnectionStateKind* temp = _impl_.gridconnectionstate_;
  _impl_.gridconnectionstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_GridConnectionStateKind* SolarEventAndStatusZGEN::unsafe_arena_release_gridconnectionstate() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.GridConnectionState)
  
  ::commonmodule::Optional_GridConnectionStateKind* temp = _impl_.gridconnectionstate_;
  _impl_.gridconnectionstate_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_GridConnectionStateKind* SolarEventAndStatusZGEN::_internal_mutable_gridconnectionstate() {
  
  if (_impl_.gridconnectionstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_GridConnectionStateKind>(GetArenaForAllocation());
    _impl_.gridconnectionstate_ = p;
  }
  return _impl_.gridconnectionstate_;
}
inline ::commonmodule::Optional_GridConnectionStateKind* SolarEventAndStatusZGEN::mutable_gridconnectionstate() {
  ::commonmodule::Optional_GridConnectionStateKind* _msg = _internal_mutable_gridconnectionstate();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.GridConnectionState)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_gridconnectionstate(::commonmodule::Optional_GridConnectionStateKind* gridconnectionstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gridconnectionstate_);
  }
  if (gridconnectionstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gridconnectionstate));
    if (message_arena != submessage_arena) {
      gridconnectionstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gridconnectionstate, submessage_arena);
    }

  } else {

  }
  _impl_.gridconnectionstate_ = gridconnectionstate;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.GridConnectionState)
}

// .google.protobuf.StringValue ManAlrmInfo = 9;
inline bool SolarEventAndStatusZGEN::_internal_has_manalrminfo() const {
  return this != internal_default_instance() && _impl_.manalrminfo_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_manalrminfo() const {
  return _internal_has_manalrminfo();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& SolarEventAndStatusZGEN::_internal_manalrminfo() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.manalrminfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& SolarEventAndStatusZGEN::manalrminfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.ManAlrmInfo)
  return _internal_manalrminfo();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_manalrminfo(
    ::PROTOBUF_NAMESPACE_ID::StringValue* manalrminfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.manalrminfo_);
  }
  _impl_.manalrminfo_ = manalrminfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.ManAlrmInfo)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* SolarEventAndStatusZGEN::release_manalrminfo() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.manalrminfo_;
  _impl_.manalrminfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* SolarEventAndStatusZGEN::unsafe_arena_release_manalrminfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.ManAlrmInfo)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.manalrminfo_;
  _impl_.manalrminfo_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* SolarEventAndStatusZGEN::_internal_mutable_manalrminfo() {
  
  if (_impl_.manalrminfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.manalrminfo_ = p;
  }
  return _impl_.manalrminfo_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* SolarEventAndStatusZGEN::mutable_manalrminfo() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_manalrminfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.ManAlrmInfo)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_manalrminfo(::PROTOBUF_NAMESPACE_ID::StringValue* manalrminfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.manalrminfo_);
  }
  if (manalrminfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(manalrminfo));
    if (message_arena != submessage_arena) {
      manalrminfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manalrminfo, submessage_arena);
    }

  } else {

  }
  _impl_.manalrminfo_ = manalrminfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.ManAlrmInfo)
}

// .commonmodule.Optional_OperatingStateKind OperatingState = 10;
inline bool SolarEventAndStatusZGEN::_internal_has_operatingstate() const {
  return this != internal_default_instance() && _impl_.operatingstate_ != nullptr;
}
inline bool SolarEventAndStatusZGEN::has_operatingstate() const {
  return _internal_has_operatingstate();
}
inline const ::commonmodule::Optional_OperatingStateKind& SolarEventAndStatusZGEN::_internal_operatingstate() const {
  const ::commonmodule::Optional_OperatingStateKind* p = _impl_.operatingstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_OperatingStateKind&>(
      ::commonmodule::_Optional_OperatingStateKind_default_instance_);
}
inline const ::commonmodule::Optional_OperatingStateKind& SolarEventAndStatusZGEN::operatingstate() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventAndStatusZGEN.OperatingState)
  return _internal_operatingstate();
}
inline void SolarEventAndStatusZGEN::unsafe_arena_set_allocated_operatingstate(
    ::commonmodule::Optional_OperatingStateKind* operatingstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operatingstate_);
  }
  _impl_.operatingstate_ = operatingstate;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventAndStatusZGEN.OperatingState)
}
inline ::commonmodule::Optional_OperatingStateKind* SolarEventAndStatusZGEN::release_operatingstate() {
  
  ::commonmodule::Optional_OperatingStateKind* temp = _impl_.operatingstate_;
  _impl_.operatingstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_OperatingStateKind* SolarEventAndStatusZGEN::unsafe_arena_release_operatingstate() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventAndStatusZGEN.OperatingState)
  
  ::commonmodule::Optional_OperatingStateKind* temp = _impl_.operatingstate_;
  _impl_.operatingstate_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_OperatingStateKind* SolarEventAndStatusZGEN::_internal_mutable_operatingstate() {
  
  if (_impl_.operatingstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_OperatingStateKind>(GetArenaForAllocation());
    _impl_.operatingstate_ = p;
  }
  return _impl_.operatingstate_;
}
inline ::commonmodule::Optional_OperatingStateKind* SolarEventAndStatusZGEN::mutable_operatingstate() {
  ::commonmodule::Optional_OperatingStateKind* _msg = _internal_mutable_operatingstate();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventAndStatusZGEN.OperatingState)
  return _msg;
}
inline void SolarEventAndStatusZGEN::set_allocated_operatingstate(::commonmodule::Optional_OperatingStateKind* operatingstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operatingstate_);
  }
  if (operatingstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(operatingstate));
    if (message_arena != submessage_arena) {
      operatingstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operatingstate, submessage_arena);
    }

  } else {

  }
  _impl_.operatingstate_ = operatingstate;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventAndStatusZGEN.OperatingState)
}

// -------------------------------------------------------------------

// SolarEventZGEN

// .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool SolarEventZGEN::_internal_has_solareventandstatuszgen() const {
  return this != internal_default_instance() && _impl_.solareventandstatuszgen_ != nullptr;
}
inline bool SolarEventZGEN::has_solareventandstatuszgen() const {
  return _internal_has_solareventandstatuszgen();
}
inline void SolarEventZGEN::clear_solareventandstatuszgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.solareventandstatuszgen_ != nullptr) {
    delete _impl_.solareventandstatuszgen_;
  }
  _impl_.solareventandstatuszgen_ = nullptr;
}
inline const ::solarmodule::SolarEventAndStatusZGEN& SolarEventZGEN::_internal_solareventandstatuszgen() const {
  const ::solarmodule::SolarEventAndStatusZGEN* p = _impl_.solareventandstatuszgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarEventAndStatusZGEN&>(
      ::solarmodule::_SolarEventAndStatusZGEN_default_instance_);
}
inline const ::solarmodule::SolarEventAndStatusZGEN& SolarEventZGEN::solareventandstatuszgen() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
  return _internal_solareventandstatuszgen();
}
inline void SolarEventZGEN::unsafe_arena_set_allocated_solareventandstatuszgen(
    ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solareventandstatuszgen_);
  }
  _impl_.solareventandstatuszgen_ = solareventandstatuszgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarEventZGEN::release_solareventandstatuszgen() {
  
  ::solarmodule::SolarEventAndStatusZGEN* temp = _impl_.solareventandstatuszgen_;
  _impl_.solareventandstatuszgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarEventZGEN::unsafe_arena_release_solareventandstatuszgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
  
  ::solarmodule::SolarEventAndStatusZGEN* temp = _impl_.solareventandstatuszgen_;
  _impl_.solareventandstatuszgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarEventZGEN::_internal_mutable_solareventandstatuszgen() {
  
  if (_impl_.solareventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEventAndStatusZGEN>(GetArenaForAllocation());
    _impl_.solareventandstatuszgen_ = p;
  }
  return _impl_.solareventandstatuszgen_;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarEventZGEN::mutable_solareventandstatuszgen() {
  ::solarmodule::SolarEventAndStatusZGEN* _msg = _internal_mutable_solareventandstatuszgen();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
  return _msg;
}
inline void SolarEventZGEN::set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solareventandstatuszgen_;
  }
  if (solareventandstatuszgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solareventandstatuszgen);
    if (message_arena != submessage_arena) {
      solareventandstatuszgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solareventandstatuszgen, submessage_arena);
    }

  } else {

  }
  _impl_.solareventandstatuszgen_ = solareventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventZGEN.solarEventAndStatusZGEN)
}

// .commonmodule.ENG_GridConnectModeKind GriMod = 2;
inline bool SolarEventZGEN::_internal_has_grimod() const {
  return this != internal_default_instance() && _impl_.grimod_ != nullptr;
}
inline bool SolarEventZGEN::has_grimod() const {
  return _internal_has_grimod();
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarEventZGEN::_internal_grimod() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.grimod_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(
      ::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarEventZGEN::grimod() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventZGEN.GriMod)
  return _internal_grimod();
}
inline void SolarEventZGEN::unsafe_arena_set_allocated_grimod(
    ::commonmodule::ENG_GridConnectModeKind* grimod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grimod_);
  }
  _impl_.grimod_ = grimod;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventZGEN.GriMod)
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarEventZGEN::release_grimod() {
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.grimod_;
  _impl_.grimod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarEventZGEN::unsafe_arena_release_grimod() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventZGEN.GriMod)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.grimod_;
  _impl_.grimod_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarEventZGEN::_internal_mutable_grimod() {
  
  if (_impl_.grimod_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaForAllocation());
    _impl_.grimod_ = p;
  }
  return _impl_.grimod_;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarEventZGEN::mutable_grimod() {
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_grimod();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventZGEN.GriMod)
  return _msg;
}
inline void SolarEventZGEN::set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grimod_);
  }
  if (grimod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grimod));
    if (message_arena != submessage_arena) {
      grimod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grimod, submessage_arena);
    }

  } else {

  }
  _impl_.grimod_ = grimod;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventZGEN.GriMod)
}

// -------------------------------------------------------------------

// SolarEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarEvent::_internal_has_eventvalue() const {
  return this != internal_default_instance() && _impl_.eventvalue_ != nullptr;
}
inline bool SolarEvent::has_eventvalue() const {
  return _internal_has_eventvalue();
}
inline const ::commonmodule::EventValue& SolarEvent::_internal_eventvalue() const {
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(
      ::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& SolarEvent::eventvalue() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEvent.eventValue)
  return _internal_eventvalue();
}
inline void SolarEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* eventvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEvent.eventValue)
}
inline ::commonmodule::EventValue* SolarEvent::release_eventvalue() {
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventValue* SolarEvent::unsafe_arena_release_eventvalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEvent.eventValue)
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* SolarEvent::_internal_mutable_eventvalue() {
  
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaForAllocation());
    _impl_.eventvalue_ = p;
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* SolarEvent::mutable_eventvalue() {
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEvent.eventValue)
  return _msg;
}
inline void SolarEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  if (eventvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventvalue));
    if (message_arena != submessage_arena) {
      eventvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }

  } else {

  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEvent.eventValue)
}

// .solarmodule.SolarEventZGEN solarEventZGEN = 2;
inline bool SolarEvent::_internal_has_solareventzgen() const {
  return this != internal_default_instance() && _impl_.solareventzgen_ != nullptr;
}
inline bool SolarEvent::has_solareventzgen() const {
  return _internal_has_solareventzgen();
}
inline void SolarEvent::clear_solareventzgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.solareventzgen_ != nullptr) {
    delete _impl_.solareventzgen_;
  }
  _impl_.solareventzgen_ = nullptr;
}
inline const ::solarmodule::SolarEventZGEN& SolarEvent::_internal_solareventzgen() const {
  const ::solarmodule::SolarEventZGEN* p = _impl_.solareventzgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarEventZGEN&>(
      ::solarmodule::_SolarEventZGEN_default_instance_);
}
inline const ::solarmodule::SolarEventZGEN& SolarEvent::solareventzgen() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEvent.solarEventZGEN)
  return _internal_solareventzgen();
}
inline void SolarEvent::unsafe_arena_set_allocated_solareventzgen(
    ::solarmodule::SolarEventZGEN* solareventzgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solareventzgen_);
  }
  _impl_.solareventzgen_ = solareventzgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEvent.solarEventZGEN)
}
inline ::solarmodule::SolarEventZGEN* SolarEvent::release_solareventzgen() {
  
  ::solarmodule::SolarEventZGEN* temp = _impl_.solareventzgen_;
  _impl_.solareventzgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarEventZGEN* SolarEvent::unsafe_arena_release_solareventzgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEvent.solarEventZGEN)
  
  ::solarmodule::SolarEventZGEN* temp = _impl_.solareventzgen_;
  _impl_.solareventzgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEventZGEN* SolarEvent::_internal_mutable_solareventzgen() {
  
  if (_impl_.solareventzgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEventZGEN>(GetArenaForAllocation());
    _impl_.solareventzgen_ = p;
  }
  return _impl_.solareventzgen_;
}
inline ::solarmodule::SolarEventZGEN* SolarEvent::mutable_solareventzgen() {
  ::solarmodule::SolarEventZGEN* _msg = _internal_mutable_solareventzgen();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEvent.solarEventZGEN)
  return _msg;
}
inline void SolarEvent::set_allocated_solareventzgen(::solarmodule::SolarEventZGEN* solareventzgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solareventzgen_;
  }
  if (solareventzgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solareventzgen);
    if (message_arena != submessage_arena) {
      solareventzgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solareventzgen, submessage_arena);
    }

  } else {

  }
  _impl_.solareventzgen_ = solareventzgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEvent.solarEventZGEN)
}

// -------------------------------------------------------------------

// SolarEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && _impl_.eventmessageinfo_ != nullptr;
}
inline bool SolarEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& SolarEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& SolarEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void SolarEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* SolarEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventMessageInfo* SolarEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* SolarEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaForAllocation());
    _impl_.eventmessageinfo_ = p;
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* SolarEventProfile::mutable_eventmessageinfo() {
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventProfile.eventMessageInfo)
  return _msg;
}
inline void SolarEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo));
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventProfile.eventMessageInfo)
}

// .solarmodule.SolarEvent solarEvent = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarEventProfile::_internal_has_solarevent() const {
  return this != internal_default_instance() && _impl_.solarevent_ != nullptr;
}
inline bool SolarEventProfile::has_solarevent() const {
  return _internal_has_solarevent();
}
inline void SolarEventProfile::clear_solarevent() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarevent_ != nullptr) {
    delete _impl_.solarevent_;
  }
  _impl_.solarevent_ = nullptr;
}
inline const ::solarmodule::SolarEvent& SolarEventProfile::_internal_solarevent() const {
  const ::solarmodule::SolarEvent* p = _impl_.solarevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarEvent&>(
      ::solarmodule::_SolarEvent_default_instance_);
}
inline const ::solarmodule::SolarEvent& SolarEventProfile::solarevent() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventProfile.solarEvent)
  return _internal_solarevent();
}
inline void SolarEventProfile::unsafe_arena_set_allocated_solarevent(
    ::solarmodule::SolarEvent* solarevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarevent_);
  }
  _impl_.solarevent_ = solarevent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventProfile.solarEvent)
}
inline ::solarmodule::SolarEvent* SolarEventProfile::release_solarevent() {
  
  ::solarmodule::SolarEvent* temp = _impl_.solarevent_;
  _impl_.solarevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarEvent* SolarEventProfile::unsafe_arena_release_solarevent() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventProfile.solarEvent)
  
  ::solarmodule::SolarEvent* temp = _impl_.solarevent_;
  _impl_.solarevent_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEvent* SolarEventProfile::_internal_mutable_solarevent() {
  
  if (_impl_.solarevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEvent>(GetArenaForAllocation());
    _impl_.solarevent_ = p;
  }
  return _impl_.solarevent_;
}
inline ::solarmodule::SolarEvent* SolarEventProfile::mutable_solarevent() {
  ::solarmodule::SolarEvent* _msg = _internal_mutable_solarevent();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventProfile.solarEvent)
  return _msg;
}
inline void SolarEventProfile::set_allocated_solarevent(::solarmodule::SolarEvent* solarevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarevent_;
  }
  if (solarevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarevent);
    if (message_arena != submessage_arena) {
      solarevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarevent, submessage_arena);
    }

  } else {

  }
  _impl_.solarevent_ = solarevent;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventProfile.solarEvent)
}

// .solarmodule.SolarInverter solarInverter = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarEventProfile::_internal_has_solarinverter() const {
  return this != internal_default_instance() && _impl_.solarinverter_ != nullptr;
}
inline bool SolarEventProfile::has_solarinverter() const {
  return _internal_has_solarinverter();
}
inline void SolarEventProfile::clear_solarinverter() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarinverter_ != nullptr) {
    delete _impl_.solarinverter_;
  }
  _impl_.solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarEventProfile::_internal_solarinverter() const {
  const ::solarmodule::SolarInverter* p = _impl_.solarinverter_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarInverter&>(
      ::solarmodule::_SolarInverter_default_instance_);
}
inline const ::solarmodule::SolarInverter& SolarEventProfile::solarinverter() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarEventProfile.solarInverter)
  return _internal_solarinverter();
}
inline void SolarEventProfile::unsafe_arena_set_allocated_solarinverter(
    ::solarmodule::SolarInverter* solarinverter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarinverter_);
  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarEventProfile.solarInverter)
}
inline ::solarmodule::SolarInverter* SolarEventProfile::release_solarinverter() {
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarInverter* SolarEventProfile::unsafe_arena_release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarEventProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarEventProfile::_internal_mutable_solarinverter() {
  
  if (_impl_.solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaForAllocation());
    _impl_.solarinverter_ = p;
  }
  return _impl_.solarinverter_;
}
inline ::solarmodule::SolarInverter* SolarEventProfile::mutable_solarinverter() {
  ::solarmodule::SolarInverter* _msg = _internal_mutable_solarinverter();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarEventProfile.solarInverter)
  return _msg;
}
inline void SolarEventProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarinverter_;
  }
  if (solarinverter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarinverter);
    if (message_arena != submessage_arena) {
      solarinverter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }

  } else {

  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarEventProfile.solarInverter)
}

// -------------------------------------------------------------------

// SolarReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool SolarReading::_internal_has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && _impl_.conductingequipmentterminalreading_ != nullptr;
}
inline bool SolarReading::has_conductingequipmentterminalreading() const {
  return _internal_has_conductingequipmentterminalreading();
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& SolarReading::_internal_conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(
      ::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& SolarReading::conductingequipmentterminalreading() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void SolarReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SolarReading::release_conductingequipmentterminalreading() {
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SolarReading::unsafe_arena_release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SolarReading::_internal_mutable_conductingequipmentterminalreading() {
  
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaForAllocation());
    _impl_.conductingequipmentterminalreading_ = p;
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SolarReading::mutable_conductingequipmentterminalreading() {
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void SolarReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipmentterminalreading));
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool SolarReading::_internal_has_phasemmtn() const {
  return this != internal_default_instance() && _impl_.phasemmtn_ != nullptr;
}
inline bool SolarReading::has_phasemmtn() const {
  return _internal_has_phasemmtn();
}
inline const ::commonmodule::PhaseMMTN& SolarReading::_internal_phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(
      ::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& SolarReading::phasemmtn() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void SolarReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* phasemmtn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* SolarReading::release_phasemmtn() {
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseMMTN* SolarReading::unsafe_arena_release_phasemmtn() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* SolarReading::_internal_mutable_phasemmtn() {
  
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaForAllocation());
    _impl_.phasemmtn_ = p;
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* SolarReading::mutable_phasemmtn() {
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.phaseMMTN)
  return _msg;
}
inline void SolarReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  if (phasemmtn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phasemmtn));
    if (message_arena != submessage_arena) {
      phasemmtn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }

  } else {

  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool SolarReading::_internal_has_readingmmtr() const {
  return this != internal_default_instance() && _impl_.readingmmtr_ != nullptr;
}
inline bool SolarReading::has_readingmmtr() const {
  return _internal_has_readingmmtr();
}
inline const ::commonmodule::ReadingMMTR& SolarReading::_internal_readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(
      ::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& SolarReading::readingmmtr() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void SolarReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* readingmmtr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* SolarReading::release_readingmmtr() {
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTR* SolarReading::unsafe_arena_release_readingmmtr() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* SolarReading::_internal_mutable_readingmmtr() {
  
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaForAllocation());
    _impl_.readingmmtr_ = p;
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* SolarReading::mutable_readingmmtr() {
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.readingMMTR)
  return _msg;
}
inline void SolarReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  if (readingmmtr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmtr));
    if (message_arena != submessage_arena) {
      readingmmtr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool SolarReading::_internal_has_readingmmxu() const {
  return this != internal_default_instance() && _impl_.readingmmxu_ != nullptr;
}
inline bool SolarReading::has_readingmmxu() const {
  return _internal_has_readingmmxu();
}
inline const ::commonmodule::ReadingMMXU& SolarReading::_internal_readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& SolarReading::readingmmxu() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void SolarReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* readingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* SolarReading::release_readingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* SolarReading::unsafe_arena_release_readingmmxu() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* SolarReading::_internal_mutable_readingmmxu() {
  
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.readingmmxu_ = p;
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* SolarReading::mutable_readingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReading.readingMMXU)
  return _msg;
}
inline void SolarReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  if (readingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmxu));
    if (message_arena != submessage_arena) {
      readingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReading.readingMMXU)
}

// -------------------------------------------------------------------

// SolarReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarReadingProfile::_internal_has_readingmessageinfo() const {
  return this != internal_default_instance() && _impl_.readingmessageinfo_ != nullptr;
}
inline bool SolarReadingProfile::has_readingmessageinfo() const {
  return _internal_has_readingmessageinfo();
}
inline const ::commonmodule::ReadingMessageInfo& SolarReadingProfile::_internal_readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(
      ::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& SolarReadingProfile::readingmessageinfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void SolarReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* SolarReadingProfile::release_readingmessageinfo() {
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* SolarReadingProfile::unsafe_arena_release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* SolarReadingProfile::_internal_mutable_readingmessageinfo() {
  
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaForAllocation());
    _impl_.readingmessageinfo_ = p;
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* SolarReadingProfile::mutable_readingmessageinfo() {
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReadingProfile.readingMessageInfo)
  return _msg;
}
inline void SolarReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmessageinfo));
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReadingProfile.readingMessageInfo)
}

// .solarmodule.SolarInverter solarInverter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarReadingProfile::_internal_has_solarinverter() const {
  return this != internal_default_instance() && _impl_.solarinverter_ != nullptr;
}
inline bool SolarReadingProfile::has_solarinverter() const {
  return _internal_has_solarinverter();
}
inline void SolarReadingProfile::clear_solarinverter() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarinverter_ != nullptr) {
    delete _impl_.solarinverter_;
  }
  _impl_.solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarReadingProfile::_internal_solarinverter() const {
  const ::solarmodule::SolarInverter* p = _impl_.solarinverter_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarInverter&>(
      ::solarmodule::_SolarInverter_default_instance_);
}
inline const ::solarmodule::SolarInverter& SolarReadingProfile::solarinverter() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarReadingProfile.solarInverter)
  return _internal_solarinverter();
}
inline void SolarReadingProfile::unsafe_arena_set_allocated_solarinverter(
    ::solarmodule::SolarInverter* solarinverter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarinverter_);
  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarReadingProfile.solarInverter)
}
inline ::solarmodule::SolarInverter* SolarReadingProfile::release_solarinverter() {
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarInverter* SolarReadingProfile::unsafe_arena_release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReadingProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarReadingProfile::_internal_mutable_solarinverter() {
  
  if (_impl_.solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaForAllocation());
    _impl_.solarinverter_ = p;
  }
  return _impl_.solarinverter_;
}
inline ::solarmodule::SolarInverter* SolarReadingProfile::mutable_solarinverter() {
  ::solarmodule::SolarInverter* _msg = _internal_mutable_solarinverter();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReadingProfile.solarInverter)
  return _msg;
}
inline void SolarReadingProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarinverter_;
  }
  if (solarinverter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarinverter);
    if (message_arena != submessage_arena) {
      solarinverter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }

  } else {

  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReadingProfile.solarInverter)
}

// .solarmodule.SolarReading solarReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarReadingProfile::_internal_has_solarreading() const {
  return this != internal_default_instance() && _impl_.solarreading_ != nullptr;
}
inline bool SolarReadingProfile::has_solarreading() const {
  return _internal_has_solarreading();
}
inline void SolarReadingProfile::clear_solarreading() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarreading_ != nullptr) {
    delete _impl_.solarreading_;
  }
  _impl_.solarreading_ = nullptr;
}
inline const ::solarmodule::SolarReading& SolarReadingProfile::_internal_solarreading() const {
  const ::solarmodule::SolarReading* p = _impl_.solarreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarReading&>(
      ::solarmodule::_SolarReading_default_instance_);
}
inline const ::solarmodule::SolarReading& SolarReadingProfile::solarreading() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarReadingProfile.solarReading)
  return _internal_solarreading();
}
inline void SolarReadingProfile::unsafe_arena_set_allocated_solarreading(
    ::solarmodule::SolarReading* solarreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarreading_);
  }
  _impl_.solarreading_ = solarreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarReadingProfile.solarReading)
}
inline ::solarmodule::SolarReading* SolarReadingProfile::release_solarreading() {
  
  ::solarmodule::SolarReading* temp = _impl_.solarreading_;
  _impl_.solarreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarReading* SolarReadingProfile::unsafe_arena_release_solarreading() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarReadingProfile.solarReading)
  
  ::solarmodule::SolarReading* temp = _impl_.solarreading_;
  _impl_.solarreading_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarReading* SolarReadingProfile::_internal_mutable_solarreading() {
  
  if (_impl_.solarreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarReading>(GetArenaForAllocation());
    _impl_.solarreading_ = p;
  }
  return _impl_.solarreading_;
}
inline ::solarmodule::SolarReading* SolarReadingProfile::mutable_solarreading() {
  ::solarmodule::SolarReading* _msg = _internal_mutable_solarreading();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarReadingProfile.solarReading)
  return _msg;
}
inline void SolarReadingProfile::set_allocated_solarreading(::solarmodule::SolarReading* solarreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarreading_;
  }
  if (solarreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarreading);
    if (message_arena != submessage_arena) {
      solarreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarreading, submessage_arena);
    }

  } else {

  }
  _impl_.solarreading_ = solarreading;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarReadingProfile.solarReading)
}

// -------------------------------------------------------------------

// SolarStatusZGEN

// .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool SolarStatusZGEN::_internal_has_solareventandstatuszgen() const {
  return this != internal_default_instance() && _impl_.solareventandstatuszgen_ != nullptr;
}
inline bool SolarStatusZGEN::has_solareventandstatuszgen() const {
  return _internal_has_solareventandstatuszgen();
}
inline void SolarStatusZGEN::clear_solareventandstatuszgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.solareventandstatuszgen_ != nullptr) {
    delete _impl_.solareventandstatuszgen_;
  }
  _impl_.solareventandstatuszgen_ = nullptr;
}
inline const ::solarmodule::SolarEventAndStatusZGEN& SolarStatusZGEN::_internal_solareventandstatuszgen() const {
  const ::solarmodule::SolarEventAndStatusZGEN* p = _impl_.solareventandstatuszgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarEventAndStatusZGEN&>(
      ::solarmodule::_SolarEventAndStatusZGEN_default_instance_);
}
inline const ::solarmodule::SolarEventAndStatusZGEN& SolarStatusZGEN::solareventandstatuszgen() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
  return _internal_solareventandstatuszgen();
}
inline void SolarStatusZGEN::unsafe_arena_set_allocated_solareventandstatuszgen(
    ::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solareventandstatuszgen_);
  }
  _impl_.solareventandstatuszgen_ = solareventandstatuszgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarStatusZGEN::release_solareventandstatuszgen() {
  
  ::solarmodule::SolarEventAndStatusZGEN* temp = _impl_.solareventandstatuszgen_;
  _impl_.solareventandstatuszgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarStatusZGEN::unsafe_arena_release_solareventandstatuszgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
  
  ::solarmodule::SolarEventAndStatusZGEN* temp = _impl_.solareventandstatuszgen_;
  _impl_.solareventandstatuszgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarStatusZGEN::_internal_mutable_solareventandstatuszgen() {
  
  if (_impl_.solareventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarEventAndStatusZGEN>(GetArenaForAllocation());
    _impl_.solareventandstatuszgen_ = p;
  }
  return _impl_.solareventandstatuszgen_;
}
inline ::solarmodule::SolarEventAndStatusZGEN* SolarStatusZGEN::mutable_solareventandstatuszgen() {
  ::solarmodule::SolarEventAndStatusZGEN* _msg = _internal_mutable_solareventandstatuszgen();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
  return _msg;
}
inline void SolarStatusZGEN::set_allocated_solareventandstatuszgen(::solarmodule::SolarEventAndStatusZGEN* solareventandstatuszgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solareventandstatuszgen_;
  }
  if (solareventandstatuszgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solareventandstatuszgen);
    if (message_arena != submessage_arena) {
      solareventandstatuszgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solareventandstatuszgen, submessage_arena);
    }

  } else {

  }
  _impl_.solareventandstatuszgen_ = solareventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusZGEN.solarEventAndStatusZGEN)
}

// .commonmodule.ENG_GridConnectModeKind GriMod = 2;
inline bool SolarStatusZGEN::_internal_has_grimod() const {
  return this != internal_default_instance() && _impl_.grimod_ != nullptr;
}
inline bool SolarStatusZGEN::has_grimod() const {
  return _internal_has_grimod();
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarStatusZGEN::_internal_grimod() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.grimod_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(
      ::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& SolarStatusZGEN::grimod() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusZGEN.GriMod)
  return _internal_grimod();
}
inline void SolarStatusZGEN::unsafe_arena_set_allocated_grimod(
    ::commonmodule::ENG_GridConnectModeKind* grimod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grimod_);
  }
  _impl_.grimod_ = grimod;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarStatusZGEN.GriMod)
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarStatusZGEN::release_grimod() {
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.grimod_;
  _impl_.grimod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarStatusZGEN::unsafe_arena_release_grimod() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusZGEN.GriMod)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.grimod_;
  _impl_.grimod_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarStatusZGEN::_internal_mutable_grimod() {
  
  if (_impl_.grimod_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaForAllocation());
    _impl_.grimod_ = p;
  }
  return _impl_.grimod_;
}
inline ::commonmodule::ENG_GridConnectModeKind* SolarStatusZGEN::mutable_grimod() {
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_grimod();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusZGEN.GriMod)
  return _msg;
}
inline void SolarStatusZGEN::set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grimod_);
  }
  if (grimod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grimod));
    if (message_arena != submessage_arena) {
      grimod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grimod, submessage_arena);
    }

  } else {

  }
  _impl_.grimod_ = grimod;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusZGEN.GriMod)
}

// -------------------------------------------------------------------

// SolarStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool SolarStatus::_internal_has_statusvalue() const {
  return this != internal_default_instance() && _impl_.statusvalue_ != nullptr;
}
inline bool SolarStatus::has_statusvalue() const {
  return _internal_has_statusvalue();
}
inline const ::commonmodule::StatusValue& SolarStatus::_internal_statusvalue() const {
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(
      ::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& SolarStatus::statusvalue() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatus.statusValue)
  return _internal_statusvalue();
}
inline void SolarStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* statusvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarStatus.statusValue)
}
inline ::commonmodule::StatusValue* SolarStatus::release_statusvalue() {
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusValue* SolarStatus::unsafe_arena_release_statusvalue() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* SolarStatus::_internal_mutable_statusvalue() {
  
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaForAllocation());
    _impl_.statusvalue_ = p;
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* SolarStatus::mutable_statusvalue() {
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatus.statusValue)
  return _msg;
}
inline void SolarStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  if (statusvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusvalue));
    if (message_arena != submessage_arena) {
      statusvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }

  } else {

  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatus.statusValue)
}

// .solarmodule.SolarStatusZGEN solarStatusZGEN = 2;
inline bool SolarStatus::_internal_has_solarstatuszgen() const {
  return this != internal_default_instance() && _impl_.solarstatuszgen_ != nullptr;
}
inline bool SolarStatus::has_solarstatuszgen() const {
  return _internal_has_solarstatuszgen();
}
inline void SolarStatus::clear_solarstatuszgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarstatuszgen_ != nullptr) {
    delete _impl_.solarstatuszgen_;
  }
  _impl_.solarstatuszgen_ = nullptr;
}
inline const ::solarmodule::SolarStatusZGEN& SolarStatus::_internal_solarstatuszgen() const {
  const ::solarmodule::SolarStatusZGEN* p = _impl_.solarstatuszgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarStatusZGEN&>(
      ::solarmodule::_SolarStatusZGEN_default_instance_);
}
inline const ::solarmodule::SolarStatusZGEN& SolarStatus::solarstatuszgen() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatus.solarStatusZGEN)
  return _internal_solarstatuszgen();
}
inline void SolarStatus::unsafe_arena_set_allocated_solarstatuszgen(
    ::solarmodule::SolarStatusZGEN* solarstatuszgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarstatuszgen_);
  }
  _impl_.solarstatuszgen_ = solarstatuszgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarStatus.solarStatusZGEN)
}
inline ::solarmodule::SolarStatusZGEN* SolarStatus::release_solarstatuszgen() {
  
  ::solarmodule::SolarStatusZGEN* temp = _impl_.solarstatuszgen_;
  _impl_.solarstatuszgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarStatusZGEN* SolarStatus::unsafe_arena_release_solarstatuszgen() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatus.solarStatusZGEN)
  
  ::solarmodule::SolarStatusZGEN* temp = _impl_.solarstatuszgen_;
  _impl_.solarstatuszgen_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarStatusZGEN* SolarStatus::_internal_mutable_solarstatuszgen() {
  
  if (_impl_.solarstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarStatusZGEN>(GetArenaForAllocation());
    _impl_.solarstatuszgen_ = p;
  }
  return _impl_.solarstatuszgen_;
}
inline ::solarmodule::SolarStatusZGEN* SolarStatus::mutable_solarstatuszgen() {
  ::solarmodule::SolarStatusZGEN* _msg = _internal_mutable_solarstatuszgen();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatus.solarStatusZGEN)
  return _msg;
}
inline void SolarStatus::set_allocated_solarstatuszgen(::solarmodule::SolarStatusZGEN* solarstatuszgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarstatuszgen_;
  }
  if (solarstatuszgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarstatuszgen);
    if (message_arena != submessage_arena) {
      solarstatuszgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarstatuszgen, submessage_arena);
    }

  } else {

  }
  _impl_.solarstatuszgen_ = solarstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatus.solarStatusZGEN)
}

// -------------------------------------------------------------------

// SolarStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SolarStatusProfile::_internal_has_statusmessageinfo() const {
  return this != internal_default_instance() && _impl_.statusmessageinfo_ != nullptr;
}
inline bool SolarStatusProfile::has_statusmessageinfo() const {
  return _internal_has_statusmessageinfo();
}
inline const ::commonmodule::StatusMessageInfo& SolarStatusProfile::_internal_statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(
      ::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& SolarStatusProfile::statusmessageinfo() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void SolarStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* statusmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* SolarStatusProfile::release_statusmessageinfo() {
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusMessageInfo* SolarStatusProfile::unsafe_arena_release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* SolarStatusProfile::_internal_mutable_statusmessageinfo() {
  
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaForAllocation());
    _impl_.statusmessageinfo_ = p;
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* SolarStatusProfile::mutable_statusmessageinfo() {
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusProfile.statusMessageInfo)
  return _msg;
}
inline void SolarStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusmessageinfo));
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusProfile.statusMessageInfo)
}

// .solarmodule.SolarInverter solarInverter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarStatusProfile::_internal_has_solarinverter() const {
  return this != internal_default_instance() && _impl_.solarinverter_ != nullptr;
}
inline bool SolarStatusProfile::has_solarinverter() const {
  return _internal_has_solarinverter();
}
inline void SolarStatusProfile::clear_solarinverter() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarinverter_ != nullptr) {
    delete _impl_.solarinverter_;
  }
  _impl_.solarinverter_ = nullptr;
}
inline const ::solarmodule::SolarInverter& SolarStatusProfile::_internal_solarinverter() const {
  const ::solarmodule::SolarInverter* p = _impl_.solarinverter_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarInverter&>(
      ::solarmodule::_SolarInverter_default_instance_);
}
inline const ::solarmodule::SolarInverter& SolarStatusProfile::solarinverter() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusProfile.solarInverter)
  return _internal_solarinverter();
}
inline void SolarStatusProfile::unsafe_arena_set_allocated_solarinverter(
    ::solarmodule::SolarInverter* solarinverter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarinverter_);
  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarStatusProfile.solarInverter)
}
inline ::solarmodule::SolarInverter* SolarStatusProfile::release_solarinverter() {
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarInverter* SolarStatusProfile::unsafe_arena_release_solarinverter() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusProfile.solarInverter)
  
  ::solarmodule::SolarInverter* temp = _impl_.solarinverter_;
  _impl_.solarinverter_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarInverter* SolarStatusProfile::_internal_mutable_solarinverter() {
  
  if (_impl_.solarinverter_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarInverter>(GetArenaForAllocation());
    _impl_.solarinverter_ = p;
  }
  return _impl_.solarinverter_;
}
inline ::solarmodule::SolarInverter* SolarStatusProfile::mutable_solarinverter() {
  ::solarmodule::SolarInverter* _msg = _internal_mutable_solarinverter();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusProfile.solarInverter)
  return _msg;
}
inline void SolarStatusProfile::set_allocated_solarinverter(::solarmodule::SolarInverter* solarinverter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarinverter_;
  }
  if (solarinverter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarinverter);
    if (message_arena != submessage_arena) {
      solarinverter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarinverter, submessage_arena);
    }

  } else {

  }
  _impl_.solarinverter_ = solarinverter;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusProfile.solarInverter)
}

// .solarmodule.SolarStatus solarStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SolarStatusProfile::_internal_has_solarstatus() const {
  return this != internal_default_instance() && _impl_.solarstatus_ != nullptr;
}
inline bool SolarStatusProfile::has_solarstatus() const {
  return _internal_has_solarstatus();
}
inline void SolarStatusProfile::clear_solarstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.solarstatus_ != nullptr) {
    delete _impl_.solarstatus_;
  }
  _impl_.solarstatus_ = nullptr;
}
inline const ::solarmodule::SolarStatus& SolarStatusProfile::_internal_solarstatus() const {
  const ::solarmodule::SolarStatus* p = _impl_.solarstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::solarmodule::SolarStatus&>(
      ::solarmodule::_SolarStatus_default_instance_);
}
inline const ::solarmodule::SolarStatus& SolarStatusProfile::solarstatus() const {
  // @@protoc_insertion_point(field_get:solarmodule.SolarStatusProfile.solarStatus)
  return _internal_solarstatus();
}
inline void SolarStatusProfile::unsafe_arena_set_allocated_solarstatus(
    ::solarmodule::SolarStatus* solarstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solarstatus_);
  }
  _impl_.solarstatus_ = solarstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:solarmodule.SolarStatusProfile.solarStatus)
}
inline ::solarmodule::SolarStatus* SolarStatusProfile::release_solarstatus() {
  
  ::solarmodule::SolarStatus* temp = _impl_.solarstatus_;
  _impl_.solarstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::solarmodule::SolarStatus* SolarStatusProfile::unsafe_arena_release_solarstatus() {
  // @@protoc_insertion_point(field_release:solarmodule.SolarStatusProfile.solarStatus)
  
  ::solarmodule::SolarStatus* temp = _impl_.solarstatus_;
  _impl_.solarstatus_ = nullptr;
  return temp;
}
inline ::solarmodule::SolarStatus* SolarStatusProfile::_internal_mutable_solarstatus() {
  
  if (_impl_.solarstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::solarmodule::SolarStatus>(GetArenaForAllocation());
    _impl_.solarstatus_ = p;
  }
  return _impl_.solarstatus_;
}
inline ::solarmodule::SolarStatus* SolarStatusProfile::mutable_solarstatus() {
  ::solarmodule::SolarStatus* _msg = _internal_mutable_solarstatus();
  // @@protoc_insertion_point(field_mutable:solarmodule.SolarStatusProfile.solarStatus)
  return _msg;
}
inline void SolarStatusProfile::set_allocated_solarstatus(::solarmodule::SolarStatus* solarstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.solarstatus_;
  }
  if (solarstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(solarstatus);
    if (message_arena != submessage_arena) {
      solarstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solarstatus, submessage_arena);
    }

  } else {

  }
  _impl_.solarstatus_ = solarstatus;
  // @@protoc_insertion_point(field_set_allocated:solarmodule.SolarStatusProfile.solarStatus)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace solarmodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_solarmodule_2fsolarmodule_2eproto_2epb_2eh
