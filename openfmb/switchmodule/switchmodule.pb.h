// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: switchmodule/switchmodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_switchmodule_2fswitchmodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_switchmodule_2fswitchmodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_switchmodule_2fswitchmodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_switchmodule_2fswitchmodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_switchmodule_2fswitchmodule_2eproto;
namespace switchmodule {
class ProtectedSwitch;
struct ProtectedSwitchDefaultTypeInternal;
extern ProtectedSwitchDefaultTypeInternal _ProtectedSwitch_default_instance_;
class SwitchDiscreteControl;
struct SwitchDiscreteControlDefaultTypeInternal;
extern SwitchDiscreteControlDefaultTypeInternal _SwitchDiscreteControl_default_instance_;
class SwitchDiscreteControlProfile;
struct SwitchDiscreteControlProfileDefaultTypeInternal;
extern SwitchDiscreteControlProfileDefaultTypeInternal _SwitchDiscreteControlProfile_default_instance_;
class SwitchDiscreteControlXSWI;
struct SwitchDiscreteControlXSWIDefaultTypeInternal;
extern SwitchDiscreteControlXSWIDefaultTypeInternal _SwitchDiscreteControlXSWI_default_instance_;
class SwitchEvent;
struct SwitchEventDefaultTypeInternal;
extern SwitchEventDefaultTypeInternal _SwitchEvent_default_instance_;
class SwitchEventProfile;
struct SwitchEventProfileDefaultTypeInternal;
extern SwitchEventProfileDefaultTypeInternal _SwitchEventProfile_default_instance_;
class SwitchEventXSWI;
struct SwitchEventXSWIDefaultTypeInternal;
extern SwitchEventXSWIDefaultTypeInternal _SwitchEventXSWI_default_instance_;
class SwitchReading;
struct SwitchReadingDefaultTypeInternal;
extern SwitchReadingDefaultTypeInternal _SwitchReading_default_instance_;
class SwitchReadingProfile;
struct SwitchReadingProfileDefaultTypeInternal;
extern SwitchReadingProfileDefaultTypeInternal _SwitchReadingProfile_default_instance_;
class SwitchStatus;
struct SwitchStatusDefaultTypeInternal;
extern SwitchStatusDefaultTypeInternal _SwitchStatus_default_instance_;
class SwitchStatusProfile;
struct SwitchStatusProfileDefaultTypeInternal;
extern SwitchStatusProfileDefaultTypeInternal _SwitchStatusProfile_default_instance_;
class SwitchStatusXSWI;
struct SwitchStatusXSWIDefaultTypeInternal;
extern SwitchStatusXSWIDefaultTypeInternal _SwitchStatusXSWI_default_instance_;
}  // namespace switchmodule
PROTOBUF_NAMESPACE_OPEN
template <>
::switchmodule::ProtectedSwitch* Arena::CreateMaybeMessage<::switchmodule::ProtectedSwitch>(Arena*);
template <>
::switchmodule::SwitchDiscreteControl* Arena::CreateMaybeMessage<::switchmodule::SwitchDiscreteControl>(Arena*);
template <>
::switchmodule::SwitchDiscreteControlProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchDiscreteControlProfile>(Arena*);
template <>
::switchmodule::SwitchDiscreteControlXSWI* Arena::CreateMaybeMessage<::switchmodule::SwitchDiscreteControlXSWI>(Arena*);
template <>
::switchmodule::SwitchEvent* Arena::CreateMaybeMessage<::switchmodule::SwitchEvent>(Arena*);
template <>
::switchmodule::SwitchEventProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchEventProfile>(Arena*);
template <>
::switchmodule::SwitchEventXSWI* Arena::CreateMaybeMessage<::switchmodule::SwitchEventXSWI>(Arena*);
template <>
::switchmodule::SwitchReading* Arena::CreateMaybeMessage<::switchmodule::SwitchReading>(Arena*);
template <>
::switchmodule::SwitchReadingProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchReadingProfile>(Arena*);
template <>
::switchmodule::SwitchStatus* Arena::CreateMaybeMessage<::switchmodule::SwitchStatus>(Arena*);
template <>
::switchmodule::SwitchStatusProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchStatusProfile>(Arena*);
template <>
::switchmodule::SwitchStatusXSWI* Arena::CreateMaybeMessage<::switchmodule::SwitchStatusXSWI>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace switchmodule {

// ===================================================================


// -------------------------------------------------------------------

class SwitchDiscreteControlXSWI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchDiscreteControlXSWI) */ {
 public:
  inline SwitchDiscreteControlXSWI() : SwitchDiscreteControlXSWI(nullptr) {}
  ~SwitchDiscreteControlXSWI() override;
  explicit PROTOBUF_CONSTEXPR SwitchDiscreteControlXSWI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchDiscreteControlXSWI(const SwitchDiscreteControlXSWI& from);
  SwitchDiscreteControlXSWI(SwitchDiscreteControlXSWI&& from) noexcept
    : SwitchDiscreteControlXSWI() {
    *this = ::std::move(from);
  }

  inline SwitchDiscreteControlXSWI& operator=(const SwitchDiscreteControlXSWI& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchDiscreteControlXSWI& operator=(SwitchDiscreteControlXSWI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchDiscreteControlXSWI& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchDiscreteControlXSWI* internal_default_instance() {
    return reinterpret_cast<const SwitchDiscreteControlXSWI*>(
               &_SwitchDiscreteControlXSWI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SwitchDiscreteControlXSWI& a, SwitchDiscreteControlXSWI& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchDiscreteControlXSWI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchDiscreteControlXSWI* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchDiscreteControlXSWI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchDiscreteControlXSWI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchDiscreteControlXSWI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchDiscreteControlXSWI& from) {
    SwitchDiscreteControlXSWI::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchDiscreteControlXSWI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchDiscreteControlXSWI";
  }
  protected:
  explicit SwitchDiscreteControlXSWI(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kPosFieldNumber = 2,
    kResetProtectionPickupFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;

  public:
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();
  // .commonmodule.PhaseDPC Pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;

  public:
  void clear_pos() ;
  const ::commonmodule::PhaseDPC& pos() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseDPC* release_pos();
  ::commonmodule::PhaseDPC* mutable_pos();
  void set_allocated_pos(::commonmodule::PhaseDPC* pos);
  private:
  const ::commonmodule::PhaseDPC& _internal_pos() const;
  ::commonmodule::PhaseDPC* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::commonmodule::PhaseDPC* pos);
  ::commonmodule::PhaseDPC* unsafe_arena_release_pos();
  // .commonmodule.ControlSPC ResetProtectionPickup = 3;
  bool has_resetprotectionpickup() const;
  private:
  bool _internal_has_resetprotectionpickup() const;

  public:
  void clear_resetprotectionpickup() ;
  const ::commonmodule::ControlSPC& resetprotectionpickup() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_resetprotectionpickup();
  ::commonmodule::ControlSPC* mutable_resetprotectionpickup();
  void set_allocated_resetprotectionpickup(::commonmodule::ControlSPC* resetprotectionpickup);
  private:
  const ::commonmodule::ControlSPC& _internal_resetprotectionpickup() const;
  ::commonmodule::ControlSPC* _internal_mutable_resetprotectionpickup();
  public:
  void unsafe_arena_set_allocated_resetprotectionpickup(
      ::commonmodule::ControlSPC* resetprotectionpickup);
  ::commonmodule::ControlSPC* unsafe_arena_release_resetprotectionpickup();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchDiscreteControlXSWI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
    ::commonmodule::PhaseDPC* pos_;
    ::commonmodule::ControlSPC* resetprotectionpickup_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchDiscreteControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchDiscreteControl) */ {
 public:
  inline SwitchDiscreteControl() : SwitchDiscreteControl(nullptr) {}
  ~SwitchDiscreteControl() override;
  explicit PROTOBUF_CONSTEXPR SwitchDiscreteControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchDiscreteControl(const SwitchDiscreteControl& from);
  SwitchDiscreteControl(SwitchDiscreteControl&& from) noexcept
    : SwitchDiscreteControl() {
    *this = ::std::move(from);
  }

  inline SwitchDiscreteControl& operator=(const SwitchDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchDiscreteControl& operator=(SwitchDiscreteControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchDiscreteControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchDiscreteControl* internal_default_instance() {
    return reinterpret_cast<const SwitchDiscreteControl*>(
               &_SwitchDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SwitchDiscreteControl& a, SwitchDiscreteControl& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchDiscreteControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchDiscreteControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchDiscreteControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchDiscreteControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchDiscreteControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchDiscreteControl& from) {
    SwitchDiscreteControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchDiscreteControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchDiscreteControl";
  }
  protected:
  explicit SwitchDiscreteControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kSwitchDiscreteControlXSWIFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .switchmodule.SwitchDiscreteControlXSWI switchDiscreteControlXSWI = 3;
  bool has_switchdiscretecontrolxswi() const;
  private:
  bool _internal_has_switchdiscretecontrolxswi() const;

  public:
  void clear_switchdiscretecontrolxswi() ;
  const ::switchmodule::SwitchDiscreteControlXSWI& switchdiscretecontrolxswi() const;
  PROTOBUF_NODISCARD ::switchmodule::SwitchDiscreteControlXSWI* release_switchdiscretecontrolxswi();
  ::switchmodule::SwitchDiscreteControlXSWI* mutable_switchdiscretecontrolxswi();
  void set_allocated_switchdiscretecontrolxswi(::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi);
  private:
  const ::switchmodule::SwitchDiscreteControlXSWI& _internal_switchdiscretecontrolxswi() const;
  ::switchmodule::SwitchDiscreteControlXSWI* _internal_mutable_switchdiscretecontrolxswi();
  public:
  void unsafe_arena_set_allocated_switchdiscretecontrolxswi(
      ::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi);
  ::switchmodule::SwitchDiscreteControlXSWI* unsafe_arena_release_switchdiscretecontrolxswi();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchDiscreteControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class ProtectedSwitch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.ProtectedSwitch) */ {
 public:
  inline ProtectedSwitch() : ProtectedSwitch(nullptr) {}
  ~ProtectedSwitch() override;
  explicit PROTOBUF_CONSTEXPR ProtectedSwitch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtectedSwitch(const ProtectedSwitch& from);
  ProtectedSwitch(ProtectedSwitch&& from) noexcept
    : ProtectedSwitch() {
    *this = ::std::move(from);
  }

  inline ProtectedSwitch& operator=(const ProtectedSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtectedSwitch& operator=(ProtectedSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtectedSwitch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtectedSwitch* internal_default_instance() {
    return reinterpret_cast<const ProtectedSwitch*>(
               &_ProtectedSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProtectedSwitch& a, ProtectedSwitch& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtectedSwitch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtectedSwitch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtectedSwitch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtectedSwitch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtectedSwitch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtectedSwitch& from) {
    ProtectedSwitch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtectedSwitch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.ProtectedSwitch";
  }
  protected:
  explicit ProtectedSwitch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  private:
  bool _internal_has_conductingequipment() const;

  public:
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);
  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_conductingequipment();
  public:
  void unsafe_arena_set_allocated_conductingequipment(
      ::commonmodule::ConductingEquipment* conductingequipment);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_conductingequipment();
  // @@protoc_insertion_point(class_scope:switchmodule.ProtectedSwitch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipment* conductingequipment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchDiscreteControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchDiscreteControlProfile) */ {
 public:
  inline SwitchDiscreteControlProfile() : SwitchDiscreteControlProfile(nullptr) {}
  ~SwitchDiscreteControlProfile() override;
  explicit PROTOBUF_CONSTEXPR SwitchDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchDiscreteControlProfile(const SwitchDiscreteControlProfile& from);
  SwitchDiscreteControlProfile(SwitchDiscreteControlProfile&& from) noexcept
    : SwitchDiscreteControlProfile() {
    *this = ::std::move(from);
  }

  inline SwitchDiscreteControlProfile& operator=(const SwitchDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchDiscreteControlProfile& operator=(SwitchDiscreteControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchDiscreteControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchDiscreteControlProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchDiscreteControlProfile*>(
               &_SwitchDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SwitchDiscreteControlProfile& a, SwitchDiscreteControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchDiscreteControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchDiscreteControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchDiscreteControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchDiscreteControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchDiscreteControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchDiscreteControlProfile& from) {
    SwitchDiscreteControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchDiscreteControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchDiscreteControlProfile";
  }
  protected:
  explicit SwitchDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kProtectedSwitchFieldNumber = 2,
    kSwitchDiscreteControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  private:
  bool _internal_has_protectedswitch() const;

  public:
  void clear_protectedswitch() ;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  PROTOBUF_NODISCARD ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);
  private:
  const ::switchmodule::ProtectedSwitch& _internal_protectedswitch() const;
  ::switchmodule::ProtectedSwitch* _internal_mutable_protectedswitch();
  public:
  void unsafe_arena_set_allocated_protectedswitch(
      ::switchmodule::ProtectedSwitch* protectedswitch);
  ::switchmodule::ProtectedSwitch* unsafe_arena_release_protectedswitch();
  // .switchmodule.SwitchDiscreteControl switchDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchdiscretecontrol() const;
  private:
  bool _internal_has_switchdiscretecontrol() const;

  public:
  void clear_switchdiscretecontrol() ;
  const ::switchmodule::SwitchDiscreteControl& switchdiscretecontrol() const;
  PROTOBUF_NODISCARD ::switchmodule::SwitchDiscreteControl* release_switchdiscretecontrol();
  ::switchmodule::SwitchDiscreteControl* mutable_switchdiscretecontrol();
  void set_allocated_switchdiscretecontrol(::switchmodule::SwitchDiscreteControl* switchdiscretecontrol);
  private:
  const ::switchmodule::SwitchDiscreteControl& _internal_switchdiscretecontrol() const;
  ::switchmodule::SwitchDiscreteControl* _internal_mutable_switchdiscretecontrol();
  public:
  void unsafe_arena_set_allocated_switchdiscretecontrol(
      ::switchmodule::SwitchDiscreteControl* switchdiscretecontrol);
  ::switchmodule::SwitchDiscreteControl* unsafe_arena_release_switchdiscretecontrol();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchDiscreteControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::switchmodule::ProtectedSwitch* protectedswitch_;
    ::switchmodule::SwitchDiscreteControl* switchdiscretecontrol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchEventXSWI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchEventXSWI) */ {
 public:
  inline SwitchEventXSWI() : SwitchEventXSWI(nullptr) {}
  ~SwitchEventXSWI() override;
  explicit PROTOBUF_CONSTEXPR SwitchEventXSWI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchEventXSWI(const SwitchEventXSWI& from);
  SwitchEventXSWI(SwitchEventXSWI&& from) noexcept
    : SwitchEventXSWI() {
    *this = ::std::move(from);
  }

  inline SwitchEventXSWI& operator=(const SwitchEventXSWI& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchEventXSWI& operator=(SwitchEventXSWI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchEventXSWI& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchEventXSWI* internal_default_instance() {
    return reinterpret_cast<const SwitchEventXSWI*>(
               &_SwitchEventXSWI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SwitchEventXSWI& a, SwitchEventXSWI& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchEventXSWI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchEventXSWI* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchEventXSWI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchEventXSWI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchEventXSWI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchEventXSWI& from) {
    SwitchEventXSWI::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchEventXSWI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchEventXSWI";
  }
  protected:
  explicit SwitchEventXSWI(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kDynamicTestFieldNumber = 2,
    kPosFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  private:
  bool _internal_has_dynamictest() const;

  public:
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);
  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* _internal_mutable_dynamictest();
  public:
  void unsafe_arena_set_allocated_dynamictest(
      ::commonmodule::ENS_DynamicTestKind* dynamictest);
  ::commonmodule::ENS_DynamicTestKind* unsafe_arena_release_dynamictest();
  // .commonmodule.PhaseDPS Pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;

  public:
  void clear_pos() ;
  const ::commonmodule::PhaseDPS& pos() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseDPS* release_pos();
  ::commonmodule::PhaseDPS* mutable_pos();
  void set_allocated_pos(::commonmodule::PhaseDPS* pos);
  private:
  const ::commonmodule::PhaseDPS& _internal_pos() const;
  ::commonmodule::PhaseDPS* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::commonmodule::PhaseDPS* pos);
  ::commonmodule::PhaseDPS* unsafe_arena_release_pos();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchEventXSWI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::ENS_DynamicTestKind* dynamictest_;
    ::commonmodule::PhaseDPS* pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchEvent) */ {
 public:
  inline SwitchEvent() : SwitchEvent(nullptr) {}
  ~SwitchEvent() override;
  explicit PROTOBUF_CONSTEXPR SwitchEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchEvent(const SwitchEvent& from);
  SwitchEvent(SwitchEvent&& from) noexcept
    : SwitchEvent() {
    *this = ::std::move(from);
  }

  inline SwitchEvent& operator=(const SwitchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchEvent& operator=(SwitchEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchEvent* internal_default_instance() {
    return reinterpret_cast<const SwitchEvent*>(
               &_SwitchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SwitchEvent& a, SwitchEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchEvent& from) {
    SwitchEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchEvent";
  }
  protected:
  explicit SwitchEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventValueFieldNumber = 1,
    kSwitchEventXSWIFieldNumber = 2,
  };
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  private:
  bool _internal_has_eventvalue() const;

  public:
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);
  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* _internal_mutable_eventvalue();
  public:
  void unsafe_arena_set_allocated_eventvalue(
      ::commonmodule::EventValue* eventvalue);
  ::commonmodule::EventValue* unsafe_arena_release_eventvalue();
  // .switchmodule.SwitchEventXSWI switchEventXSWI = 2;
  bool has_switcheventxswi() const;
  private:
  bool _internal_has_switcheventxswi() const;

  public:
  void clear_switcheventxswi() ;
  const ::switchmodule::SwitchEventXSWI& switcheventxswi() const;
  PROTOBUF_NODISCARD ::switchmodule::SwitchEventXSWI* release_switcheventxswi();
  ::switchmodule::SwitchEventXSWI* mutable_switcheventxswi();
  void set_allocated_switcheventxswi(::switchmodule::SwitchEventXSWI* switcheventxswi);
  private:
  const ::switchmodule::SwitchEventXSWI& _internal_switcheventxswi() const;
  ::switchmodule::SwitchEventXSWI* _internal_mutable_switcheventxswi();
  public:
  void unsafe_arena_set_allocated_switcheventxswi(
      ::switchmodule::SwitchEventXSWI* switcheventxswi);
  ::switchmodule::SwitchEventXSWI* unsafe_arena_release_switcheventxswi();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventValue* eventvalue_;
    ::switchmodule::SwitchEventXSWI* switcheventxswi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchEventProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchEventProfile) */ {
 public:
  inline SwitchEventProfile() : SwitchEventProfile(nullptr) {}
  ~SwitchEventProfile() override;
  explicit PROTOBUF_CONSTEXPR SwitchEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchEventProfile(const SwitchEventProfile& from);
  SwitchEventProfile(SwitchEventProfile&& from) noexcept
    : SwitchEventProfile() {
    *this = ::std::move(from);
  }

  inline SwitchEventProfile& operator=(const SwitchEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchEventProfile& operator=(SwitchEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchEventProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchEventProfile*>(
               &_SwitchEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SwitchEventProfile& a, SwitchEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchEventProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchEventProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchEventProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchEventProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchEventProfile& from) {
    SwitchEventProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchEventProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchEventProfile";
  }
  protected:
  explicit SwitchEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kProtectedSwitchFieldNumber = 2,
    kSwitchEventFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;

  public:
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();
  // .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  private:
  bool _internal_has_protectedswitch() const;

  public:
  void clear_protectedswitch() ;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  PROTOBUF_NODISCARD ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);
  private:
  const ::switchmodule::ProtectedSwitch& _internal_protectedswitch() const;
  ::switchmodule::ProtectedSwitch* _internal_mutable_protectedswitch();
  public:
  void unsafe_arena_set_allocated_protectedswitch(
      ::switchmodule::ProtectedSwitch* protectedswitch);
  ::switchmodule::ProtectedSwitch* unsafe_arena_release_protectedswitch();
  // .switchmodule.SwitchEvent switchEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchevent() const;
  private:
  bool _internal_has_switchevent() const;

  public:
  void clear_switchevent() ;
  const ::switchmodule::SwitchEvent& switchevent() const;
  PROTOBUF_NODISCARD ::switchmodule::SwitchEvent* release_switchevent();
  ::switchmodule::SwitchEvent* mutable_switchevent();
  void set_allocated_switchevent(::switchmodule::SwitchEvent* switchevent);
  private:
  const ::switchmodule::SwitchEvent& _internal_switchevent() const;
  ::switchmodule::SwitchEvent* _internal_mutable_switchevent();
  public:
  void unsafe_arena_set_allocated_switchevent(
      ::switchmodule::SwitchEvent* switchevent);
  ::switchmodule::SwitchEvent* unsafe_arena_release_switchevent();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventMessageInfo* eventmessageinfo_;
    ::switchmodule::ProtectedSwitch* protectedswitch_;
    ::switchmodule::SwitchEvent* switchevent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchReading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchReading) */ {
 public:
  inline SwitchReading() : SwitchReading(nullptr) {}
  ~SwitchReading() override;
  explicit PROTOBUF_CONSTEXPR SwitchReading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchReading(const SwitchReading& from);
  SwitchReading(SwitchReading&& from) noexcept
    : SwitchReading() {
    *this = ::std::move(from);
  }

  inline SwitchReading& operator=(const SwitchReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchReading& operator=(SwitchReading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchReading& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchReading* internal_default_instance() {
    return reinterpret_cast<const SwitchReading*>(
               &_SwitchReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SwitchReading& a, SwitchReading& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchReading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchReading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchReading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchReading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchReading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchReading& from) {
    SwitchReading::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchReading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchReading";
  }
  protected:
  explicit SwitchReading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kDiffReadingMMXUFieldNumber = 2,
    kPhaseMMTNFieldNumber = 3,
    kReadingMMTRFieldNumber = 4,
    kReadingMMXUFieldNumber = 5,
  };
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  private:
  bool _internal_has_conductingequipmentterminalreading() const;

  public:
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* _internal_mutable_conductingequipmentterminalreading();
  public:
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(
      ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  ::commonmodule::ConductingEquipmentTerminalReading* unsafe_arena_release_conductingequipmentterminalreading();
  // .commonmodule.ReadingMMXU diffReadingMMXU = 2;
  bool has_diffreadingmmxu() const;
  private:
  bool _internal_has_diffreadingmmxu() const;

  public:
  void clear_diffreadingmmxu() ;
  const ::commonmodule::ReadingMMXU& diffreadingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_diffreadingmmxu();
  ::commonmodule::ReadingMMXU* mutable_diffreadingmmxu();
  void set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_diffreadingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_diffreadingmmxu();
  public:
  void unsafe_arena_set_allocated_diffreadingmmxu(
      ::commonmodule::ReadingMMXU* diffreadingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_diffreadingmmxu();
  // .commonmodule.PhaseMMTN phaseMMTN = 3;
  bool has_phasemmtn() const;
  private:
  bool _internal_has_phasemmtn() const;

  public:
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);
  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* _internal_mutable_phasemmtn();
  public:
  void unsafe_arena_set_allocated_phasemmtn(
      ::commonmodule::PhaseMMTN* phasemmtn);
  ::commonmodule::PhaseMMTN* unsafe_arena_release_phasemmtn();
  // .commonmodule.ReadingMMTR readingMMTR = 4;
  bool has_readingmmtr() const;
  private:
  bool _internal_has_readingmmtr() const;

  public:
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);
  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* _internal_mutable_readingmmtr();
  public:
  void unsafe_arena_set_allocated_readingmmtr(
      ::commonmodule::ReadingMMTR* readingmmtr);
  ::commonmodule::ReadingMMTR* unsafe_arena_release_readingmmtr();
  // .commonmodule.ReadingMMXU readingMMXU = 5;
  bool has_readingmmxu() const;
  private:
  bool _internal_has_readingmmxu() const;

  public:
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_readingmmxu();
  public:
  void unsafe_arena_set_allocated_readingmmxu(
      ::commonmodule::ReadingMMXU* readingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_readingmmxu();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchReading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
    ::commonmodule::ReadingMMXU* diffreadingmmxu_;
    ::commonmodule::PhaseMMTN* phasemmtn_;
    ::commonmodule::ReadingMMTR* readingmmtr_;
    ::commonmodule::ReadingMMXU* readingmmxu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchReadingProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchReadingProfile) */ {
 public:
  inline SwitchReadingProfile() : SwitchReadingProfile(nullptr) {}
  ~SwitchReadingProfile() override;
  explicit PROTOBUF_CONSTEXPR SwitchReadingProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchReadingProfile(const SwitchReadingProfile& from);
  SwitchReadingProfile(SwitchReadingProfile&& from) noexcept
    : SwitchReadingProfile() {
    *this = ::std::move(from);
  }

  inline SwitchReadingProfile& operator=(const SwitchReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchReadingProfile& operator=(SwitchReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchReadingProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchReadingProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchReadingProfile*>(
               &_SwitchReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SwitchReadingProfile& a, SwitchReadingProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchReadingProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchReadingProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchReadingProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchReadingProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchReadingProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchReadingProfile& from) {
    SwitchReadingProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchReadingProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchReadingProfile";
  }
  protected:
  explicit SwitchReadingProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSwitchReadingFieldNumber = 3,
    kReadingMessageInfoFieldNumber = 1,
    kProtectedSwitchFieldNumber = 2,
  };
  // repeated .switchmodule.SwitchReading switchReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
  int switchreading_size() const;
  private:
  int _internal_switchreading_size() const;

  public:
  void clear_switchreading() ;
  ::switchmodule::SwitchReading* mutable_switchreading(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::switchmodule::SwitchReading >*
      mutable_switchreading();
  private:
  const ::switchmodule::SwitchReading& _internal_switchreading(int index) const;
  ::switchmodule::SwitchReading* _internal_add_switchreading();
  public:
  const ::switchmodule::SwitchReading& switchreading(int index) const;
  ::switchmodule::SwitchReading* add_switchreading();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::switchmodule::SwitchReading >&
      switchreading() const;
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  private:
  bool _internal_has_readingmessageinfo() const;

  public:
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);
  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* _internal_mutable_readingmessageinfo();
  public:
  void unsafe_arena_set_allocated_readingmessageinfo(
      ::commonmodule::ReadingMessageInfo* readingmessageinfo);
  ::commonmodule::ReadingMessageInfo* unsafe_arena_release_readingmessageinfo();
  // .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  private:
  bool _internal_has_protectedswitch() const;

  public:
  void clear_protectedswitch() ;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  PROTOBUF_NODISCARD ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);
  private:
  const ::switchmodule::ProtectedSwitch& _internal_protectedswitch() const;
  ::switchmodule::ProtectedSwitch* _internal_mutable_protectedswitch();
  public:
  void unsafe_arena_set_allocated_protectedswitch(
      ::switchmodule::ProtectedSwitch* protectedswitch);
  ::switchmodule::ProtectedSwitch* unsafe_arena_release_protectedswitch();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchReadingProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::switchmodule::SwitchReading > switchreading_;
    ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
    ::switchmodule::ProtectedSwitch* protectedswitch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchStatusXSWI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchStatusXSWI) */ {
 public:
  inline SwitchStatusXSWI() : SwitchStatusXSWI(nullptr) {}
  ~SwitchStatusXSWI() override;
  explicit PROTOBUF_CONSTEXPR SwitchStatusXSWI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchStatusXSWI(const SwitchStatusXSWI& from);
  SwitchStatusXSWI(SwitchStatusXSWI&& from) noexcept
    : SwitchStatusXSWI() {
    *this = ::std::move(from);
  }

  inline SwitchStatusXSWI& operator=(const SwitchStatusXSWI& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchStatusXSWI& operator=(SwitchStatusXSWI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchStatusXSWI& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchStatusXSWI* internal_default_instance() {
    return reinterpret_cast<const SwitchStatusXSWI*>(
               &_SwitchStatusXSWI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SwitchStatusXSWI& a, SwitchStatusXSWI& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchStatusXSWI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchStatusXSWI* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchStatusXSWI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchStatusXSWI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchStatusXSWI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchStatusXSWI& from) {
    SwitchStatusXSWI::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchStatusXSWI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchStatusXSWI";
  }
  protected:
  explicit SwitchStatusXSWI(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kDynamicTestFieldNumber = 2,
    kPosFieldNumber = 4,
    kProtectionPickupFieldNumber = 5,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  private:
  bool _internal_has_dynamictest() const;

  public:
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);
  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* _internal_mutable_dynamictest();
  public:
  void unsafe_arena_set_allocated_dynamictest(
      ::commonmodule::ENS_DynamicTestKind* dynamictest);
  ::commonmodule::ENS_DynamicTestKind* unsafe_arena_release_dynamictest();
  // .commonmodule.PhaseDPS Pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;

  public:
  void clear_pos() ;
  const ::commonmodule::PhaseDPS& pos() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseDPS* release_pos();
  ::commonmodule::PhaseDPS* mutable_pos();
  void set_allocated_pos(::commonmodule::PhaseDPS* pos);
  private:
  const ::commonmodule::PhaseDPS& _internal_pos() const;
  ::commonmodule::PhaseDPS* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::commonmodule::PhaseDPS* pos);
  ::commonmodule::PhaseDPS* unsafe_arena_release_pos();
  // .commonmodule.PhaseSPS ProtectionPickup = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectionpickup() const;
  private:
  bool _internal_has_protectionpickup() const;

  public:
  void clear_protectionpickup() ;
  const ::commonmodule::PhaseSPS& protectionpickup() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_protectionpickup();
  ::commonmodule::PhaseSPS* mutable_protectionpickup();
  void set_allocated_protectionpickup(::commonmodule::PhaseSPS* protectionpickup);
  private:
  const ::commonmodule::PhaseSPS& _internal_protectionpickup() const;
  ::commonmodule::PhaseSPS* _internal_mutable_protectionpickup();
  public:
  void unsafe_arena_set_allocated_protectionpickup(
      ::commonmodule::PhaseSPS* protectionpickup);
  ::commonmodule::PhaseSPS* unsafe_arena_release_protectionpickup();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchStatusXSWI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::ENS_DynamicTestKind* dynamictest_;
    ::commonmodule::PhaseDPS* pos_;
    ::commonmodule::PhaseSPS* protectionpickup_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchStatus) */ {
 public:
  inline SwitchStatus() : SwitchStatus(nullptr) {}
  ~SwitchStatus() override;
  explicit PROTOBUF_CONSTEXPR SwitchStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchStatus(const SwitchStatus& from);
  SwitchStatus(SwitchStatus&& from) noexcept
    : SwitchStatus() {
    *this = ::std::move(from);
  }

  inline SwitchStatus& operator=(const SwitchStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchStatus& operator=(SwitchStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchStatus* internal_default_instance() {
    return reinterpret_cast<const SwitchStatus*>(
               &_SwitchStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SwitchStatus& a, SwitchStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchStatus& from) {
    SwitchStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchStatus";
  }
  protected:
  explicit SwitchStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusValueFieldNumber = 1,
    kSwitchStatusXSWIFieldNumber = 2,
  };
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  private:
  bool _internal_has_statusvalue() const;

  public:
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);
  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* _internal_mutable_statusvalue();
  public:
  void unsafe_arena_set_allocated_statusvalue(
      ::commonmodule::StatusValue* statusvalue);
  ::commonmodule::StatusValue* unsafe_arena_release_statusvalue();
  // .switchmodule.SwitchStatusXSWI switchStatusXSWI = 2;
  bool has_switchstatusxswi() const;
  private:
  bool _internal_has_switchstatusxswi() const;

  public:
  void clear_switchstatusxswi() ;
  const ::switchmodule::SwitchStatusXSWI& switchstatusxswi() const;
  PROTOBUF_NODISCARD ::switchmodule::SwitchStatusXSWI* release_switchstatusxswi();
  ::switchmodule::SwitchStatusXSWI* mutable_switchstatusxswi();
  void set_allocated_switchstatusxswi(::switchmodule::SwitchStatusXSWI* switchstatusxswi);
  private:
  const ::switchmodule::SwitchStatusXSWI& _internal_switchstatusxswi() const;
  ::switchmodule::SwitchStatusXSWI* _internal_mutable_switchstatusxswi();
  public:
  void unsafe_arena_set_allocated_switchstatusxswi(
      ::switchmodule::SwitchStatusXSWI* switchstatusxswi);
  ::switchmodule::SwitchStatusXSWI* unsafe_arena_release_switchstatusxswi();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusValue* statusvalue_;
    ::switchmodule::SwitchStatusXSWI* switchstatusxswi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchStatusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchStatusProfile) */ {
 public:
  inline SwitchStatusProfile() : SwitchStatusProfile(nullptr) {}
  ~SwitchStatusProfile() override;
  explicit PROTOBUF_CONSTEXPR SwitchStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchStatusProfile(const SwitchStatusProfile& from);
  SwitchStatusProfile(SwitchStatusProfile&& from) noexcept
    : SwitchStatusProfile() {
    *this = ::std::move(from);
  }

  inline SwitchStatusProfile& operator=(const SwitchStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchStatusProfile& operator=(SwitchStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchStatusProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchStatusProfile*>(
               &_SwitchStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SwitchStatusProfile& a, SwitchStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchStatusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchStatusProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchStatusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchStatusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchStatusProfile& from) {
    SwitchStatusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchStatusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "switchmodule.SwitchStatusProfile";
  }
  protected:
  explicit SwitchStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kProtectedSwitchFieldNumber = 2,
    kSwitchStatusFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  private:
  bool _internal_has_statusmessageinfo() const;

  public:
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);
  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* _internal_mutable_statusmessageinfo();
  public:
  void unsafe_arena_set_allocated_statusmessageinfo(
      ::commonmodule::StatusMessageInfo* statusmessageinfo);
  ::commonmodule::StatusMessageInfo* unsafe_arena_release_statusmessageinfo();
  // .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  private:
  bool _internal_has_protectedswitch() const;

  public:
  void clear_protectedswitch() ;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  PROTOBUF_NODISCARD ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);
  private:
  const ::switchmodule::ProtectedSwitch& _internal_protectedswitch() const;
  ::switchmodule::ProtectedSwitch* _internal_mutable_protectedswitch();
  public:
  void unsafe_arena_set_allocated_protectedswitch(
      ::switchmodule::ProtectedSwitch* protectedswitch);
  ::switchmodule::ProtectedSwitch* unsafe_arena_release_protectedswitch();
  // .switchmodule.SwitchStatus switchStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchstatus() const;
  private:
  bool _internal_has_switchstatus() const;

  public:
  void clear_switchstatus() ;
  const ::switchmodule::SwitchStatus& switchstatus() const;
  PROTOBUF_NODISCARD ::switchmodule::SwitchStatus* release_switchstatus();
  ::switchmodule::SwitchStatus* mutable_switchstatus();
  void set_allocated_switchstatus(::switchmodule::SwitchStatus* switchstatus);
  private:
  const ::switchmodule::SwitchStatus& _internal_switchstatus() const;
  ::switchmodule::SwitchStatus* _internal_mutable_switchstatus();
  public:
  void unsafe_arena_set_allocated_switchstatus(
      ::switchmodule::SwitchStatus* switchstatus);
  ::switchmodule::SwitchStatus* unsafe_arena_release_switchstatus();
  // @@protoc_insertion_point(class_scope:switchmodule.SwitchStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusMessageInfo* statusmessageinfo_;
    ::switchmodule::ProtectedSwitch* protectedswitch_;
    ::switchmodule::SwitchStatus* switchstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SwitchDiscreteControlXSWI

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool SwitchDiscreteControlXSWI::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && _impl_.logicalnodeforcontrol_ != nullptr;
}
inline bool SwitchDiscreteControlXSWI::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline const ::commonmodule::LogicalNodeForControl& SwitchDiscreteControlXSWI::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& SwitchDiscreteControlXSWI::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void SwitchDiscreteControlXSWI::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* SwitchDiscreteControlXSWI::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* SwitchDiscreteControlXSWI::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* SwitchDiscreteControlXSWI::_internal_mutable_logicalnodeforcontrol() {
  
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaForAllocation());
    _impl_.logicalnodeforcontrol_ = p;
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* SwitchDiscreteControlXSWI::mutable_logicalnodeforcontrol() {
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
  return _msg;
}
inline void SwitchDiscreteControlXSWI::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol));
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
}

// .commonmodule.PhaseDPC Pos = 2;
inline bool SwitchDiscreteControlXSWI::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool SwitchDiscreteControlXSWI::has_pos() const {
  return _internal_has_pos();
}
inline const ::commonmodule::PhaseDPC& SwitchDiscreteControlXSWI::_internal_pos() const {
  const ::commonmodule::PhaseDPC* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseDPC&>(
      ::commonmodule::_PhaseDPC_default_instance_);
}
inline const ::commonmodule::PhaseDPC& SwitchDiscreteControlXSWI::pos() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlXSWI.Pos)
  return _internal_pos();
}
inline void SwitchDiscreteControlXSWI::unsafe_arena_set_allocated_pos(
    ::commonmodule::PhaseDPC* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControlXSWI.Pos)
}
inline ::commonmodule::PhaseDPC* SwitchDiscreteControlXSWI::release_pos() {
  
  ::commonmodule::PhaseDPC* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseDPC* SwitchDiscreteControlXSWI::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlXSWI.Pos)
  
  ::commonmodule::PhaseDPC* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseDPC* SwitchDiscreteControlXSWI::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseDPC>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::commonmodule::PhaseDPC* SwitchDiscreteControlXSWI::mutable_pos() {
  ::commonmodule::PhaseDPC* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlXSWI.Pos)
  return _msg;
}
inline void SwitchDiscreteControlXSWI::set_allocated_pos(::commonmodule::PhaseDPC* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }

  } else {

  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlXSWI.Pos)
}

// .commonmodule.ControlSPC ResetProtectionPickup = 3;
inline bool SwitchDiscreteControlXSWI::_internal_has_resetprotectionpickup() const {
  return this != internal_default_instance() && _impl_.resetprotectionpickup_ != nullptr;
}
inline bool SwitchDiscreteControlXSWI::has_resetprotectionpickup() const {
  return _internal_has_resetprotectionpickup();
}
inline const ::commonmodule::ControlSPC& SwitchDiscreteControlXSWI::_internal_resetprotectionpickup() const {
  const ::commonmodule::ControlSPC* p = _impl_.resetprotectionpickup_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& SwitchDiscreteControlXSWI::resetprotectionpickup() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlXSWI.ResetProtectionPickup)
  return _internal_resetprotectionpickup();
}
inline void SwitchDiscreteControlXSWI::unsafe_arena_set_allocated_resetprotectionpickup(
    ::commonmodule::ControlSPC* resetprotectionpickup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resetprotectionpickup_);
  }
  _impl_.resetprotectionpickup_ = resetprotectionpickup;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControlXSWI.ResetProtectionPickup)
}
inline ::commonmodule::ControlSPC* SwitchDiscreteControlXSWI::release_resetprotectionpickup() {
  
  ::commonmodule::ControlSPC* temp = _impl_.resetprotectionpickup_;
  _impl_.resetprotectionpickup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* SwitchDiscreteControlXSWI::unsafe_arena_release_resetprotectionpickup() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlXSWI.ResetProtectionPickup)
  
  ::commonmodule::ControlSPC* temp = _impl_.resetprotectionpickup_;
  _impl_.resetprotectionpickup_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* SwitchDiscreteControlXSWI::_internal_mutable_resetprotectionpickup() {
  
  if (_impl_.resetprotectionpickup_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.resetprotectionpickup_ = p;
  }
  return _impl_.resetprotectionpickup_;
}
inline ::commonmodule::ControlSPC* SwitchDiscreteControlXSWI::mutable_resetprotectionpickup() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_resetprotectionpickup();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlXSWI.ResetProtectionPickup)
  return _msg;
}
inline void SwitchDiscreteControlXSWI::set_allocated_resetprotectionpickup(::commonmodule::ControlSPC* resetprotectionpickup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resetprotectionpickup_);
  }
  if (resetprotectionpickup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resetprotectionpickup));
    if (message_arena != submessage_arena) {
      resetprotectionpickup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resetprotectionpickup, submessage_arena);
    }

  } else {

  }
  _impl_.resetprotectionpickup_ = resetprotectionpickup;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlXSWI.ResetProtectionPickup)
}

// -------------------------------------------------------------------

// SwitchDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool SwitchDiscreteControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool SwitchDiscreteControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& SwitchDiscreteControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& SwitchDiscreteControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControl.controlValue)
  return _internal_controlvalue();
}
inline void SwitchDiscreteControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControl.controlValue)
}
inline ::commonmodule::ControlValue* SwitchDiscreteControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* SwitchDiscreteControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* SwitchDiscreteControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* SwitchDiscreteControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControl.controlValue)
  return _msg;
}
inline void SwitchDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool SwitchDiscreteControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool SwitchDiscreteControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& SwitchDiscreteControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& SwitchDiscreteControl::check() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControl.check)
  return _internal_check();
}
inline void SwitchDiscreteControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControl.check)
}
inline ::commonmodule::CheckConditions* SwitchDiscreteControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* SwitchDiscreteControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* SwitchDiscreteControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* SwitchDiscreteControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControl.check)
  return _msg;
}
inline void SwitchDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControl.check)
}

// .switchmodule.SwitchDiscreteControlXSWI switchDiscreteControlXSWI = 3;
inline bool SwitchDiscreteControl::_internal_has_switchdiscretecontrolxswi() const {
  return this != internal_default_instance() && _impl_.switchdiscretecontrolxswi_ != nullptr;
}
inline bool SwitchDiscreteControl::has_switchdiscretecontrolxswi() const {
  return _internal_has_switchdiscretecontrolxswi();
}
inline void SwitchDiscreteControl::clear_switchdiscretecontrolxswi() {
  if (GetArenaForAllocation() == nullptr && _impl_.switchdiscretecontrolxswi_ != nullptr) {
    delete _impl_.switchdiscretecontrolxswi_;
  }
  _impl_.switchdiscretecontrolxswi_ = nullptr;
}
inline const ::switchmodule::SwitchDiscreteControlXSWI& SwitchDiscreteControl::_internal_switchdiscretecontrolxswi() const {
  const ::switchmodule::SwitchDiscreteControlXSWI* p = _impl_.switchdiscretecontrolxswi_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::SwitchDiscreteControlXSWI&>(
      ::switchmodule::_SwitchDiscreteControlXSWI_default_instance_);
}
inline const ::switchmodule::SwitchDiscreteControlXSWI& SwitchDiscreteControl::switchdiscretecontrolxswi() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
  return _internal_switchdiscretecontrolxswi();
}
inline void SwitchDiscreteControl::unsafe_arena_set_allocated_switchdiscretecontrolxswi(
    ::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.switchdiscretecontrolxswi_);
  }
  _impl_.switchdiscretecontrolxswi_ = switchdiscretecontrolxswi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
}
inline ::switchmodule::SwitchDiscreteControlXSWI* SwitchDiscreteControl::release_switchdiscretecontrolxswi() {
  
  ::switchmodule::SwitchDiscreteControlXSWI* temp = _impl_.switchdiscretecontrolxswi_;
  _impl_.switchdiscretecontrolxswi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::SwitchDiscreteControlXSWI* SwitchDiscreteControl::unsafe_arena_release_switchdiscretecontrolxswi() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
  
  ::switchmodule::SwitchDiscreteControlXSWI* temp = _impl_.switchdiscretecontrolxswi_;
  _impl_.switchdiscretecontrolxswi_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchDiscreteControlXSWI* SwitchDiscreteControl::_internal_mutable_switchdiscretecontrolxswi() {
  
  if (_impl_.switchdiscretecontrolxswi_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchDiscreteControlXSWI>(GetArenaForAllocation());
    _impl_.switchdiscretecontrolxswi_ = p;
  }
  return _impl_.switchdiscretecontrolxswi_;
}
inline ::switchmodule::SwitchDiscreteControlXSWI* SwitchDiscreteControl::mutable_switchdiscretecontrolxswi() {
  ::switchmodule::SwitchDiscreteControlXSWI* _msg = _internal_mutable_switchdiscretecontrolxswi();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
  return _msg;
}
inline void SwitchDiscreteControl::set_allocated_switchdiscretecontrolxswi(::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.switchdiscretecontrolxswi_;
  }
  if (switchdiscretecontrolxswi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(switchdiscretecontrolxswi);
    if (message_arena != submessage_arena) {
      switchdiscretecontrolxswi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, switchdiscretecontrolxswi, submessage_arena);
    }

  } else {

  }
  _impl_.switchdiscretecontrolxswi_ = switchdiscretecontrolxswi;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
}

// -------------------------------------------------------------------

// ProtectedSwitch

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool ProtectedSwitch::_internal_has_conductingequipment() const {
  return this != internal_default_instance() && _impl_.conductingequipment_ != nullptr;
}
inline bool ProtectedSwitch::has_conductingequipment() const {
  return _internal_has_conductingequipment();
}
inline const ::commonmodule::ConductingEquipment& ProtectedSwitch::_internal_conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& ProtectedSwitch::conductingequipment() const {
  // @@protoc_insertion_point(field_get:switchmodule.ProtectedSwitch.conductingEquipment)
  return _internal_conductingequipment();
}
inline void ProtectedSwitch::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* conductingequipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.ProtectedSwitch.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* ProtectedSwitch::release_conductingequipment() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* ProtectedSwitch::unsafe_arena_release_conductingequipment() {
  // @@protoc_insertion_point(field_release:switchmodule.ProtectedSwitch.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* ProtectedSwitch::_internal_mutable_conductingequipment() {
  
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.conductingequipment_ = p;
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* ProtectedSwitch::mutable_conductingequipment() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:switchmodule.ProtectedSwitch.conductingEquipment)
  return _msg;
}
inline void ProtectedSwitch::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  if (conductingequipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipment));
    if (message_arena != submessage_arena) {
      conductingequipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.ProtectedSwitch.conductingEquipment)
}

// -------------------------------------------------------------------

// SwitchDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchDiscreteControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool SwitchDiscreteControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& SwitchDiscreteControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& SwitchDiscreteControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void SwitchDiscreteControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* SwitchDiscreteControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SwitchDiscreteControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SwitchDiscreteControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* SwitchDiscreteControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
  return _msg;
}
inline void SwitchDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchDiscreteControlProfile::_internal_has_protectedswitch() const {
  return this != internal_default_instance() && _impl_.protectedswitch_ != nullptr;
}
inline bool SwitchDiscreteControlProfile::has_protectedswitch() const {
  return _internal_has_protectedswitch();
}
inline void SwitchDiscreteControlProfile::clear_protectedswitch() {
  if (GetArenaForAllocation() == nullptr && _impl_.protectedswitch_ != nullptr) {
    delete _impl_.protectedswitch_;
  }
  _impl_.protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchDiscreteControlProfile::_internal_protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = _impl_.protectedswitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::ProtectedSwitch&>(
      ::switchmodule::_ProtectedSwitch_default_instance_);
}
inline const ::switchmodule::ProtectedSwitch& SwitchDiscreteControlProfile::protectedswitch() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
  return _internal_protectedswitch();
}
inline void SwitchDiscreteControlProfile::unsafe_arena_set_allocated_protectedswitch(
    ::switchmodule::ProtectedSwitch* protectedswitch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectedswitch_);
  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
}
inline ::switchmodule::ProtectedSwitch* SwitchDiscreteControlProfile::release_protectedswitch() {
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchDiscreteControlProfile::unsafe_arena_release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchDiscreteControlProfile::_internal_mutable_protectedswitch() {
  
  if (_impl_.protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaForAllocation());
    _impl_.protectedswitch_ = p;
  }
  return _impl_.protectedswitch_;
}
inline ::switchmodule::ProtectedSwitch* SwitchDiscreteControlProfile::mutable_protectedswitch() {
  ::switchmodule::ProtectedSwitch* _msg = _internal_mutable_protectedswitch();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
  return _msg;
}
inline void SwitchDiscreteControlProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protectedswitch_;
  }
  if (protectedswitch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protectedswitch);
    if (message_arena != submessage_arena) {
      protectedswitch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }

  } else {

  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
}

// .switchmodule.SwitchDiscreteControl switchDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchDiscreteControlProfile::_internal_has_switchdiscretecontrol() const {
  return this != internal_default_instance() && _impl_.switchdiscretecontrol_ != nullptr;
}
inline bool SwitchDiscreteControlProfile::has_switchdiscretecontrol() const {
  return _internal_has_switchdiscretecontrol();
}
inline void SwitchDiscreteControlProfile::clear_switchdiscretecontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.switchdiscretecontrol_ != nullptr) {
    delete _impl_.switchdiscretecontrol_;
  }
  _impl_.switchdiscretecontrol_ = nullptr;
}
inline const ::switchmodule::SwitchDiscreteControl& SwitchDiscreteControlProfile::_internal_switchdiscretecontrol() const {
  const ::switchmodule::SwitchDiscreteControl* p = _impl_.switchdiscretecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::SwitchDiscreteControl&>(
      ::switchmodule::_SwitchDiscreteControl_default_instance_);
}
inline const ::switchmodule::SwitchDiscreteControl& SwitchDiscreteControlProfile::switchdiscretecontrol() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
  return _internal_switchdiscretecontrol();
}
inline void SwitchDiscreteControlProfile::unsafe_arena_set_allocated_switchdiscretecontrol(
    ::switchmodule::SwitchDiscreteControl* switchdiscretecontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.switchdiscretecontrol_);
  }
  _impl_.switchdiscretecontrol_ = switchdiscretecontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
}
inline ::switchmodule::SwitchDiscreteControl* SwitchDiscreteControlProfile::release_switchdiscretecontrol() {
  
  ::switchmodule::SwitchDiscreteControl* temp = _impl_.switchdiscretecontrol_;
  _impl_.switchdiscretecontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::SwitchDiscreteControl* SwitchDiscreteControlProfile::unsafe_arena_release_switchdiscretecontrol() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
  
  ::switchmodule::SwitchDiscreteControl* temp = _impl_.switchdiscretecontrol_;
  _impl_.switchdiscretecontrol_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchDiscreteControl* SwitchDiscreteControlProfile::_internal_mutable_switchdiscretecontrol() {
  
  if (_impl_.switchdiscretecontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchDiscreteControl>(GetArenaForAllocation());
    _impl_.switchdiscretecontrol_ = p;
  }
  return _impl_.switchdiscretecontrol_;
}
inline ::switchmodule::SwitchDiscreteControl* SwitchDiscreteControlProfile::mutable_switchdiscretecontrol() {
  ::switchmodule::SwitchDiscreteControl* _msg = _internal_mutable_switchdiscretecontrol();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
  return _msg;
}
inline void SwitchDiscreteControlProfile::set_allocated_switchdiscretecontrol(::switchmodule::SwitchDiscreteControl* switchdiscretecontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.switchdiscretecontrol_;
  }
  if (switchdiscretecontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(switchdiscretecontrol);
    if (message_arena != submessage_arena) {
      switchdiscretecontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, switchdiscretecontrol, submessage_arena);
    }

  } else {

  }
  _impl_.switchdiscretecontrol_ = switchdiscretecontrol;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
}

// -------------------------------------------------------------------

// SwitchEventXSWI

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool SwitchEventXSWI::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool SwitchEventXSWI::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SwitchEventXSWI::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SwitchEventXSWI::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void SwitchEventXSWI::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchEventXSWI::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchEventXSWI::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchEventXSWI::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchEventXSWI::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
  return _msg;
}
inline void SwitchEventXSWI::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool SwitchEventXSWI::_internal_has_dynamictest() const {
  return this != internal_default_instance() && _impl_.dynamictest_ != nullptr;
}
inline bool SwitchEventXSWI::has_dynamictest() const {
  return _internal_has_dynamictest();
}
inline const ::commonmodule::ENS_DynamicTestKind& SwitchEventXSWI::_internal_dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(
      ::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& SwitchEventXSWI::dynamictest() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventXSWI.DynamicTest)
  return _internal_dynamictest();
}
inline void SwitchEventXSWI::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* dynamictest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEventXSWI.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchEventXSWI::release_dynamictest() {
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchEventXSWI::unsafe_arena_release_dynamictest() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventXSWI.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchEventXSWI::_internal_mutable_dynamictest() {
  
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaForAllocation());
    _impl_.dynamictest_ = p;
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchEventXSWI::mutable_dynamictest() {
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventXSWI.DynamicTest)
  return _msg;
}
inline void SwitchEventXSWI::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  if (dynamictest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamictest));
    if (message_arena != submessage_arena) {
      dynamictest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }

  } else {

  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventXSWI.DynamicTest)
}

// .commonmodule.PhaseDPS Pos = 3;
inline bool SwitchEventXSWI::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool SwitchEventXSWI::has_pos() const {
  return _internal_has_pos();
}
inline const ::commonmodule::PhaseDPS& SwitchEventXSWI::_internal_pos() const {
  const ::commonmodule::PhaseDPS* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseDPS&>(
      ::commonmodule::_PhaseDPS_default_instance_);
}
inline const ::commonmodule::PhaseDPS& SwitchEventXSWI::pos() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventXSWI.Pos)
  return _internal_pos();
}
inline void SwitchEventXSWI::unsafe_arena_set_allocated_pos(
    ::commonmodule::PhaseDPS* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEventXSWI.Pos)
}
inline ::commonmodule::PhaseDPS* SwitchEventXSWI::release_pos() {
  
  ::commonmodule::PhaseDPS* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseDPS* SwitchEventXSWI::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventXSWI.Pos)
  
  ::commonmodule::PhaseDPS* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseDPS* SwitchEventXSWI::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseDPS>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::commonmodule::PhaseDPS* SwitchEventXSWI::mutable_pos() {
  ::commonmodule::PhaseDPS* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventXSWI.Pos)
  return _msg;
}
inline void SwitchEventXSWI::set_allocated_pos(::commonmodule::PhaseDPS* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }

  } else {

  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventXSWI.Pos)
}

// -------------------------------------------------------------------

// SwitchEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool SwitchEvent::_internal_has_eventvalue() const {
  return this != internal_default_instance() && _impl_.eventvalue_ != nullptr;
}
inline bool SwitchEvent::has_eventvalue() const {
  return _internal_has_eventvalue();
}
inline const ::commonmodule::EventValue& SwitchEvent::_internal_eventvalue() const {
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(
      ::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& SwitchEvent::eventvalue() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEvent.eventValue)
  return _internal_eventvalue();
}
inline void SwitchEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* eventvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEvent.eventValue)
}
inline ::commonmodule::EventValue* SwitchEvent::release_eventvalue() {
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventValue* SwitchEvent::unsafe_arena_release_eventvalue() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEvent.eventValue)
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* SwitchEvent::_internal_mutable_eventvalue() {
  
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaForAllocation());
    _impl_.eventvalue_ = p;
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* SwitchEvent::mutable_eventvalue() {
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEvent.eventValue)
  return _msg;
}
inline void SwitchEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  if (eventvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventvalue));
    if (message_arena != submessage_arena) {
      eventvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }

  } else {

  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEvent.eventValue)
}

// .switchmodule.SwitchEventXSWI switchEventXSWI = 2;
inline bool SwitchEvent::_internal_has_switcheventxswi() const {
  return this != internal_default_instance() && _impl_.switcheventxswi_ != nullptr;
}
inline bool SwitchEvent::has_switcheventxswi() const {
  return _internal_has_switcheventxswi();
}
inline void SwitchEvent::clear_switcheventxswi() {
  if (GetArenaForAllocation() == nullptr && _impl_.switcheventxswi_ != nullptr) {
    delete _impl_.switcheventxswi_;
  }
  _impl_.switcheventxswi_ = nullptr;
}
inline const ::switchmodule::SwitchEventXSWI& SwitchEvent::_internal_switcheventxswi() const {
  const ::switchmodule::SwitchEventXSWI* p = _impl_.switcheventxswi_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::SwitchEventXSWI&>(
      ::switchmodule::_SwitchEventXSWI_default_instance_);
}
inline const ::switchmodule::SwitchEventXSWI& SwitchEvent::switcheventxswi() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEvent.switchEventXSWI)
  return _internal_switcheventxswi();
}
inline void SwitchEvent::unsafe_arena_set_allocated_switcheventxswi(
    ::switchmodule::SwitchEventXSWI* switcheventxswi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.switcheventxswi_);
  }
  _impl_.switcheventxswi_ = switcheventxswi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEvent.switchEventXSWI)
}
inline ::switchmodule::SwitchEventXSWI* SwitchEvent::release_switcheventxswi() {
  
  ::switchmodule::SwitchEventXSWI* temp = _impl_.switcheventxswi_;
  _impl_.switcheventxswi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::SwitchEventXSWI* SwitchEvent::unsafe_arena_release_switcheventxswi() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEvent.switchEventXSWI)
  
  ::switchmodule::SwitchEventXSWI* temp = _impl_.switcheventxswi_;
  _impl_.switcheventxswi_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchEventXSWI* SwitchEvent::_internal_mutable_switcheventxswi() {
  
  if (_impl_.switcheventxswi_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchEventXSWI>(GetArenaForAllocation());
    _impl_.switcheventxswi_ = p;
  }
  return _impl_.switcheventxswi_;
}
inline ::switchmodule::SwitchEventXSWI* SwitchEvent::mutable_switcheventxswi() {
  ::switchmodule::SwitchEventXSWI* _msg = _internal_mutable_switcheventxswi();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEvent.switchEventXSWI)
  return _msg;
}
inline void SwitchEvent::set_allocated_switcheventxswi(::switchmodule::SwitchEventXSWI* switcheventxswi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.switcheventxswi_;
  }
  if (switcheventxswi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(switcheventxswi);
    if (message_arena != submessage_arena) {
      switcheventxswi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, switcheventxswi, submessage_arena);
    }

  } else {

  }
  _impl_.switcheventxswi_ = switcheventxswi;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEvent.switchEventXSWI)
}

// -------------------------------------------------------------------

// SwitchEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && _impl_.eventmessageinfo_ != nullptr;
}
inline bool SwitchEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& SwitchEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& SwitchEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void SwitchEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* SwitchEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventMessageInfo* SwitchEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* SwitchEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaForAllocation());
    _impl_.eventmessageinfo_ = p;
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* SwitchEventProfile::mutable_eventmessageinfo() {
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventProfile.eventMessageInfo)
  return _msg;
}
inline void SwitchEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo));
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventProfile.eventMessageInfo)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchEventProfile::_internal_has_protectedswitch() const {
  return this != internal_default_instance() && _impl_.protectedswitch_ != nullptr;
}
inline bool SwitchEventProfile::has_protectedswitch() const {
  return _internal_has_protectedswitch();
}
inline void SwitchEventProfile::clear_protectedswitch() {
  if (GetArenaForAllocation() == nullptr && _impl_.protectedswitch_ != nullptr) {
    delete _impl_.protectedswitch_;
  }
  _impl_.protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchEventProfile::_internal_protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = _impl_.protectedswitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::ProtectedSwitch&>(
      ::switchmodule::_ProtectedSwitch_default_instance_);
}
inline const ::switchmodule::ProtectedSwitch& SwitchEventProfile::protectedswitch() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventProfile.protectedSwitch)
  return _internal_protectedswitch();
}
inline void SwitchEventProfile::unsafe_arena_set_allocated_protectedswitch(
    ::switchmodule::ProtectedSwitch* protectedswitch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectedswitch_);
  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEventProfile.protectedSwitch)
}
inline ::switchmodule::ProtectedSwitch* SwitchEventProfile::release_protectedswitch() {
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchEventProfile::unsafe_arena_release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchEventProfile::_internal_mutable_protectedswitch() {
  
  if (_impl_.protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaForAllocation());
    _impl_.protectedswitch_ = p;
  }
  return _impl_.protectedswitch_;
}
inline ::switchmodule::ProtectedSwitch* SwitchEventProfile::mutable_protectedswitch() {
  ::switchmodule::ProtectedSwitch* _msg = _internal_mutable_protectedswitch();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventProfile.protectedSwitch)
  return _msg;
}
inline void SwitchEventProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protectedswitch_;
  }
  if (protectedswitch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protectedswitch);
    if (message_arena != submessage_arena) {
      protectedswitch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }

  } else {

  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventProfile.protectedSwitch)
}

// .switchmodule.SwitchEvent switchEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchEventProfile::_internal_has_switchevent() const {
  return this != internal_default_instance() && _impl_.switchevent_ != nullptr;
}
inline bool SwitchEventProfile::has_switchevent() const {
  return _internal_has_switchevent();
}
inline void SwitchEventProfile::clear_switchevent() {
  if (GetArenaForAllocation() == nullptr && _impl_.switchevent_ != nullptr) {
    delete _impl_.switchevent_;
  }
  _impl_.switchevent_ = nullptr;
}
inline const ::switchmodule::SwitchEvent& SwitchEventProfile::_internal_switchevent() const {
  const ::switchmodule::SwitchEvent* p = _impl_.switchevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::SwitchEvent&>(
      ::switchmodule::_SwitchEvent_default_instance_);
}
inline const ::switchmodule::SwitchEvent& SwitchEventProfile::switchevent() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventProfile.switchEvent)
  return _internal_switchevent();
}
inline void SwitchEventProfile::unsafe_arena_set_allocated_switchevent(
    ::switchmodule::SwitchEvent* switchevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.switchevent_);
  }
  _impl_.switchevent_ = switchevent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchEventProfile.switchEvent)
}
inline ::switchmodule::SwitchEvent* SwitchEventProfile::release_switchevent() {
  
  ::switchmodule::SwitchEvent* temp = _impl_.switchevent_;
  _impl_.switchevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::SwitchEvent* SwitchEventProfile::unsafe_arena_release_switchevent() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventProfile.switchEvent)
  
  ::switchmodule::SwitchEvent* temp = _impl_.switchevent_;
  _impl_.switchevent_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchEvent* SwitchEventProfile::_internal_mutable_switchevent() {
  
  if (_impl_.switchevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchEvent>(GetArenaForAllocation());
    _impl_.switchevent_ = p;
  }
  return _impl_.switchevent_;
}
inline ::switchmodule::SwitchEvent* SwitchEventProfile::mutable_switchevent() {
  ::switchmodule::SwitchEvent* _msg = _internal_mutable_switchevent();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventProfile.switchEvent)
  return _msg;
}
inline void SwitchEventProfile::set_allocated_switchevent(::switchmodule::SwitchEvent* switchevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.switchevent_;
  }
  if (switchevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(switchevent);
    if (message_arena != submessage_arena) {
      switchevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, switchevent, submessage_arena);
    }

  } else {

  }
  _impl_.switchevent_ = switchevent;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventProfile.switchEvent)
}

// -------------------------------------------------------------------

// SwitchReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool SwitchReading::_internal_has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && _impl_.conductingequipmentterminalreading_ != nullptr;
}
inline bool SwitchReading::has_conductingequipmentterminalreading() const {
  return _internal_has_conductingequipmentterminalreading();
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& SwitchReading::_internal_conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(
      ::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& SwitchReading::conductingequipmentterminalreading() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void SwitchReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SwitchReading::release_conductingequipmentterminalreading() {
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SwitchReading::unsafe_arena_release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SwitchReading::_internal_mutable_conductingequipmentterminalreading() {
  
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaForAllocation());
    _impl_.conductingequipmentterminalreading_ = p;
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SwitchReading::mutable_conductingequipmentterminalreading() {
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void SwitchReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipmentterminalreading));
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
}

// .commonmodule.ReadingMMXU diffReadingMMXU = 2;
inline bool SwitchReading::_internal_has_diffreadingmmxu() const {
  return this != internal_default_instance() && _impl_.diffreadingmmxu_ != nullptr;
}
inline bool SwitchReading::has_diffreadingmmxu() const {
  return _internal_has_diffreadingmmxu();
}
inline const ::commonmodule::ReadingMMXU& SwitchReading::_internal_diffreadingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.diffreadingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& SwitchReading::diffreadingmmxu() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.diffReadingMMXU)
  return _internal_diffreadingmmxu();
}
inline void SwitchReading::unsafe_arena_set_allocated_diffreadingmmxu(
    ::commonmodule::ReadingMMXU* diffreadingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diffreadingmmxu_);
  }
  _impl_.diffreadingmmxu_ = diffreadingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchReading.diffReadingMMXU)
}
inline ::commonmodule::ReadingMMXU* SwitchReading::release_diffreadingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.diffreadingmmxu_;
  _impl_.diffreadingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::unsafe_arena_release_diffreadingmmxu() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.diffReadingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.diffreadingmmxu_;
  _impl_.diffreadingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::_internal_mutable_diffreadingmmxu() {
  
  if (_impl_.diffreadingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.diffreadingmmxu_ = p;
  }
  return _impl_.diffreadingmmxu_;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::mutable_diffreadingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_diffreadingmmxu();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.diffReadingMMXU)
  return _msg;
}
inline void SwitchReading::set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diffreadingmmxu_);
  }
  if (diffreadingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diffreadingmmxu));
    if (message_arena != submessage_arena) {
      diffreadingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diffreadingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.diffreadingmmxu_ = diffreadingmmxu;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.diffReadingMMXU)
}

// .commonmodule.PhaseMMTN phaseMMTN = 3;
inline bool SwitchReading::_internal_has_phasemmtn() const {
  return this != internal_default_instance() && _impl_.phasemmtn_ != nullptr;
}
inline bool SwitchReading::has_phasemmtn() const {
  return _internal_has_phasemmtn();
}
inline const ::commonmodule::PhaseMMTN& SwitchReading::_internal_phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(
      ::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& SwitchReading::phasemmtn() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void SwitchReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* phasemmtn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* SwitchReading::release_phasemmtn() {
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseMMTN* SwitchReading::unsafe_arena_release_phasemmtn() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* SwitchReading::_internal_mutable_phasemmtn() {
  
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaForAllocation());
    _impl_.phasemmtn_ = p;
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* SwitchReading::mutable_phasemmtn() {
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.phaseMMTN)
  return _msg;
}
inline void SwitchReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  if (phasemmtn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phasemmtn));
    if (message_arena != submessage_arena) {
      phasemmtn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }

  } else {

  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 4;
inline bool SwitchReading::_internal_has_readingmmtr() const {
  return this != internal_default_instance() && _impl_.readingmmtr_ != nullptr;
}
inline bool SwitchReading::has_readingmmtr() const {
  return _internal_has_readingmmtr();
}
inline const ::commonmodule::ReadingMMTR& SwitchReading::_internal_readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(
      ::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& SwitchReading::readingmmtr() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void SwitchReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* readingmmtr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* SwitchReading::release_readingmmtr() {
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTR* SwitchReading::unsafe_arena_release_readingmmtr() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* SwitchReading::_internal_mutable_readingmmtr() {
  
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaForAllocation());
    _impl_.readingmmtr_ = p;
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* SwitchReading::mutable_readingmmtr() {
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.readingMMTR)
  return _msg;
}
inline void SwitchReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  if (readingmmtr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmtr));
    if (message_arena != submessage_arena) {
      readingmmtr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 5;
inline bool SwitchReading::_internal_has_readingmmxu() const {
  return this != internal_default_instance() && _impl_.readingmmxu_ != nullptr;
}
inline bool SwitchReading::has_readingmmxu() const {
  return _internal_has_readingmmxu();
}
inline const ::commonmodule::ReadingMMXU& SwitchReading::_internal_readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& SwitchReading::readingmmxu() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void SwitchReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* readingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* SwitchReading::release_readingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::unsafe_arena_release_readingmmxu() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::_internal_mutable_readingmmxu() {
  
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.readingmmxu_ = p;
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::mutable_readingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.readingMMXU)
  return _msg;
}
inline void SwitchReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  if (readingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmxu));
    if (message_arena != submessage_arena) {
      readingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.readingMMXU)
}

// -------------------------------------------------------------------

// SwitchReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchReadingProfile::_internal_has_readingmessageinfo() const {
  return this != internal_default_instance() && _impl_.readingmessageinfo_ != nullptr;
}
inline bool SwitchReadingProfile::has_readingmessageinfo() const {
  return _internal_has_readingmessageinfo();
}
inline const ::commonmodule::ReadingMessageInfo& SwitchReadingProfile::_internal_readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(
      ::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& SwitchReadingProfile::readingmessageinfo() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void SwitchReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* SwitchReadingProfile::release_readingmessageinfo() {
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* SwitchReadingProfile::unsafe_arena_release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* SwitchReadingProfile::_internal_mutable_readingmessageinfo() {
  
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaForAllocation());
    _impl_.readingmessageinfo_ = p;
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* SwitchReadingProfile::mutable_readingmessageinfo() {
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReadingProfile.readingMessageInfo)
  return _msg;
}
inline void SwitchReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmessageinfo));
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReadingProfile.readingMessageInfo)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchReadingProfile::_internal_has_protectedswitch() const {
  return this != internal_default_instance() && _impl_.protectedswitch_ != nullptr;
}
inline bool SwitchReadingProfile::has_protectedswitch() const {
  return _internal_has_protectedswitch();
}
inline void SwitchReadingProfile::clear_protectedswitch() {
  if (GetArenaForAllocation() == nullptr && _impl_.protectedswitch_ != nullptr) {
    delete _impl_.protectedswitch_;
  }
  _impl_.protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchReadingProfile::_internal_protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = _impl_.protectedswitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::ProtectedSwitch&>(
      ::switchmodule::_ProtectedSwitch_default_instance_);
}
inline const ::switchmodule::ProtectedSwitch& SwitchReadingProfile::protectedswitch() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReadingProfile.protectedSwitch)
  return _internal_protectedswitch();
}
inline void SwitchReadingProfile::unsafe_arena_set_allocated_protectedswitch(
    ::switchmodule::ProtectedSwitch* protectedswitch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectedswitch_);
  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchReadingProfile.protectedSwitch)
}
inline ::switchmodule::ProtectedSwitch* SwitchReadingProfile::release_protectedswitch() {
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchReadingProfile::unsafe_arena_release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReadingProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchReadingProfile::_internal_mutable_protectedswitch() {
  
  if (_impl_.protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaForAllocation());
    _impl_.protectedswitch_ = p;
  }
  return _impl_.protectedswitch_;
}
inline ::switchmodule::ProtectedSwitch* SwitchReadingProfile::mutable_protectedswitch() {
  ::switchmodule::ProtectedSwitch* _msg = _internal_mutable_protectedswitch();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReadingProfile.protectedSwitch)
  return _msg;
}
inline void SwitchReadingProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protectedswitch_;
  }
  if (protectedswitch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protectedswitch);
    if (message_arena != submessage_arena) {
      protectedswitch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }

  } else {

  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReadingProfile.protectedSwitch)
}

// repeated .switchmodule.SwitchReading switchReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
inline int SwitchReadingProfile::_internal_switchreading_size() const {
  return _impl_.switchreading_.size();
}
inline int SwitchReadingProfile::switchreading_size() const {
  return _internal_switchreading_size();
}
inline void SwitchReadingProfile::clear_switchreading() {
  _impl_.switchreading_.Clear();
}
inline ::switchmodule::SwitchReading* SwitchReadingProfile::mutable_switchreading(int index) {
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReadingProfile.switchReading)
  return _impl_.switchreading_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::switchmodule::SwitchReading >*
SwitchReadingProfile::mutable_switchreading() {
  // @@protoc_insertion_point(field_mutable_list:switchmodule.SwitchReadingProfile.switchReading)
  return &_impl_.switchreading_;
}
inline const ::switchmodule::SwitchReading& SwitchReadingProfile::_internal_switchreading(int index) const {
  return _impl_.switchreading_.Get(index);
}
inline const ::switchmodule::SwitchReading& SwitchReadingProfile::switchreading(int index) const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReadingProfile.switchReading)
  return _internal_switchreading(index);
}
inline ::switchmodule::SwitchReading* SwitchReadingProfile::_internal_add_switchreading() {
  return _impl_.switchreading_.Add();
}
inline ::switchmodule::SwitchReading* SwitchReadingProfile::add_switchreading() {
  ::switchmodule::SwitchReading* _add = _internal_add_switchreading();
  // @@protoc_insertion_point(field_add:switchmodule.SwitchReadingProfile.switchReading)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::switchmodule::SwitchReading >&
SwitchReadingProfile::switchreading() const {
  // @@protoc_insertion_point(field_list:switchmodule.SwitchReadingProfile.switchReading)
  return _impl_.switchreading_;
}

// -------------------------------------------------------------------

// SwitchStatusXSWI

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool SwitchStatusXSWI::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool SwitchStatusXSWI::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SwitchStatusXSWI::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SwitchStatusXSWI::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void SwitchStatusXSWI::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchStatusXSWI::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchStatusXSWI::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchStatusXSWI::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchStatusXSWI::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
  return _msg;
}
inline void SwitchStatusXSWI::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool SwitchStatusXSWI::_internal_has_dynamictest() const {
  return this != internal_default_instance() && _impl_.dynamictest_ != nullptr;
}
inline bool SwitchStatusXSWI::has_dynamictest() const {
  return _internal_has_dynamictest();
}
inline const ::commonmodule::ENS_DynamicTestKind& SwitchStatusXSWI::_internal_dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(
      ::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& SwitchStatusXSWI::dynamictest() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusXSWI.DynamicTest)
  return _internal_dynamictest();
}
inline void SwitchStatusXSWI::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* dynamictest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatusXSWI.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchStatusXSWI::release_dynamictest() {
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchStatusXSWI::unsafe_arena_release_dynamictest() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusXSWI.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchStatusXSWI::_internal_mutable_dynamictest() {
  
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaForAllocation());
    _impl_.dynamictest_ = p;
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchStatusXSWI::mutable_dynamictest() {
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusXSWI.DynamicTest)
  return _msg;
}
inline void SwitchStatusXSWI::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  if (dynamictest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamictest));
    if (message_arena != submessage_arena) {
      dynamictest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }

  } else {

  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusXSWI.DynamicTest)
}

// .commonmodule.PhaseDPS Pos = 4;
inline bool SwitchStatusXSWI::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool SwitchStatusXSWI::has_pos() const {
  return _internal_has_pos();
}
inline const ::commonmodule::PhaseDPS& SwitchStatusXSWI::_internal_pos() const {
  const ::commonmodule::PhaseDPS* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseDPS&>(
      ::commonmodule::_PhaseDPS_default_instance_);
}
inline const ::commonmodule::PhaseDPS& SwitchStatusXSWI::pos() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusXSWI.Pos)
  return _internal_pos();
}
inline void SwitchStatusXSWI::unsafe_arena_set_allocated_pos(
    ::commonmodule::PhaseDPS* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatusXSWI.Pos)
}
inline ::commonmodule::PhaseDPS* SwitchStatusXSWI::release_pos() {
  
  ::commonmodule::PhaseDPS* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseDPS* SwitchStatusXSWI::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusXSWI.Pos)
  
  ::commonmodule::PhaseDPS* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseDPS* SwitchStatusXSWI::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseDPS>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::commonmodule::PhaseDPS* SwitchStatusXSWI::mutable_pos() {
  ::commonmodule::PhaseDPS* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusXSWI.Pos)
  return _msg;
}
inline void SwitchStatusXSWI::set_allocated_pos(::commonmodule::PhaseDPS* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }

  } else {

  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusXSWI.Pos)
}

// .commonmodule.PhaseSPS ProtectionPickup = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatusXSWI::_internal_has_protectionpickup() const {
  return this != internal_default_instance() && _impl_.protectionpickup_ != nullptr;
}
inline bool SwitchStatusXSWI::has_protectionpickup() const {
  return _internal_has_protectionpickup();
}
inline const ::commonmodule::PhaseSPS& SwitchStatusXSWI::_internal_protectionpickup() const {
  const ::commonmodule::PhaseSPS* p = _impl_.protectionpickup_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& SwitchStatusXSWI::protectionpickup() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusXSWI.ProtectionPickup)
  return _internal_protectionpickup();
}
inline void SwitchStatusXSWI::unsafe_arena_set_allocated_protectionpickup(
    ::commonmodule::PhaseSPS* protectionpickup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectionpickup_);
  }
  _impl_.protectionpickup_ = protectionpickup;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatusXSWI.ProtectionPickup)
}
inline ::commonmodule::PhaseSPS* SwitchStatusXSWI::release_protectionpickup() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.protectionpickup_;
  _impl_.protectionpickup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* SwitchStatusXSWI::unsafe_arena_release_protectionpickup() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusXSWI.ProtectionPickup)
  
  ::commonmodule::PhaseSPS* temp = _impl_.protectionpickup_;
  _impl_.protectionpickup_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* SwitchStatusXSWI::_internal_mutable_protectionpickup() {
  
  if (_impl_.protectionpickup_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.protectionpickup_ = p;
  }
  return _impl_.protectionpickup_;
}
inline ::commonmodule::PhaseSPS* SwitchStatusXSWI::mutable_protectionpickup() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_protectionpickup();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusXSWI.ProtectionPickup)
  return _msg;
}
inline void SwitchStatusXSWI::set_allocated_protectionpickup(::commonmodule::PhaseSPS* protectionpickup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectionpickup_);
  }
  if (protectionpickup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(protectionpickup));
    if (message_arena != submessage_arena) {
      protectionpickup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectionpickup, submessage_arena);
    }

  } else {

  }
  _impl_.protectionpickup_ = protectionpickup;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusXSWI.ProtectionPickup)
}

// -------------------------------------------------------------------

// SwitchStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool SwitchStatus::_internal_has_statusvalue() const {
  return this != internal_default_instance() && _impl_.statusvalue_ != nullptr;
}
inline bool SwitchStatus::has_statusvalue() const {
  return _internal_has_statusvalue();
}
inline const ::commonmodule::StatusValue& SwitchStatus::_internal_statusvalue() const {
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(
      ::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& SwitchStatus::statusvalue() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatus.statusValue)
  return _internal_statusvalue();
}
inline void SwitchStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* statusvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatus.statusValue)
}
inline ::commonmodule::StatusValue* SwitchStatus::release_statusvalue() {
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusValue* SwitchStatus::unsafe_arena_release_statusvalue() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* SwitchStatus::_internal_mutable_statusvalue() {
  
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaForAllocation());
    _impl_.statusvalue_ = p;
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* SwitchStatus::mutable_statusvalue() {
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatus.statusValue)
  return _msg;
}
inline void SwitchStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  if (statusvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusvalue));
    if (message_arena != submessage_arena) {
      statusvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }

  } else {

  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatus.statusValue)
}

// .switchmodule.SwitchStatusXSWI switchStatusXSWI = 2;
inline bool SwitchStatus::_internal_has_switchstatusxswi() const {
  return this != internal_default_instance() && _impl_.switchstatusxswi_ != nullptr;
}
inline bool SwitchStatus::has_switchstatusxswi() const {
  return _internal_has_switchstatusxswi();
}
inline void SwitchStatus::clear_switchstatusxswi() {
  if (GetArenaForAllocation() == nullptr && _impl_.switchstatusxswi_ != nullptr) {
    delete _impl_.switchstatusxswi_;
  }
  _impl_.switchstatusxswi_ = nullptr;
}
inline const ::switchmodule::SwitchStatusXSWI& SwitchStatus::_internal_switchstatusxswi() const {
  const ::switchmodule::SwitchStatusXSWI* p = _impl_.switchstatusxswi_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::SwitchStatusXSWI&>(
      ::switchmodule::_SwitchStatusXSWI_default_instance_);
}
inline const ::switchmodule::SwitchStatusXSWI& SwitchStatus::switchstatusxswi() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatus.switchStatusXSWI)
  return _internal_switchstatusxswi();
}
inline void SwitchStatus::unsafe_arena_set_allocated_switchstatusxswi(
    ::switchmodule::SwitchStatusXSWI* switchstatusxswi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.switchstatusxswi_);
  }
  _impl_.switchstatusxswi_ = switchstatusxswi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatus.switchStatusXSWI)
}
inline ::switchmodule::SwitchStatusXSWI* SwitchStatus::release_switchstatusxswi() {
  
  ::switchmodule::SwitchStatusXSWI* temp = _impl_.switchstatusxswi_;
  _impl_.switchstatusxswi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::SwitchStatusXSWI* SwitchStatus::unsafe_arena_release_switchstatusxswi() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatus.switchStatusXSWI)
  
  ::switchmodule::SwitchStatusXSWI* temp = _impl_.switchstatusxswi_;
  _impl_.switchstatusxswi_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchStatusXSWI* SwitchStatus::_internal_mutable_switchstatusxswi() {
  
  if (_impl_.switchstatusxswi_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchStatusXSWI>(GetArenaForAllocation());
    _impl_.switchstatusxswi_ = p;
  }
  return _impl_.switchstatusxswi_;
}
inline ::switchmodule::SwitchStatusXSWI* SwitchStatus::mutable_switchstatusxswi() {
  ::switchmodule::SwitchStatusXSWI* _msg = _internal_mutable_switchstatusxswi();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatus.switchStatusXSWI)
  return _msg;
}
inline void SwitchStatus::set_allocated_switchstatusxswi(::switchmodule::SwitchStatusXSWI* switchstatusxswi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.switchstatusxswi_;
  }
  if (switchstatusxswi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(switchstatusxswi);
    if (message_arena != submessage_arena) {
      switchstatusxswi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, switchstatusxswi, submessage_arena);
    }

  } else {

  }
  _impl_.switchstatusxswi_ = switchstatusxswi;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatus.switchStatusXSWI)
}

// -------------------------------------------------------------------

// SwitchStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchStatusProfile::_internal_has_statusmessageinfo() const {
  return this != internal_default_instance() && _impl_.statusmessageinfo_ != nullptr;
}
inline bool SwitchStatusProfile::has_statusmessageinfo() const {
  return _internal_has_statusmessageinfo();
}
inline const ::commonmodule::StatusMessageInfo& SwitchStatusProfile::_internal_statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(
      ::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& SwitchStatusProfile::statusmessageinfo() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void SwitchStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* statusmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* SwitchStatusProfile::release_statusmessageinfo() {
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusMessageInfo* SwitchStatusProfile::unsafe_arena_release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* SwitchStatusProfile::_internal_mutable_statusmessageinfo() {
  
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaForAllocation());
    _impl_.statusmessageinfo_ = p;
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* SwitchStatusProfile::mutable_statusmessageinfo() {
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusProfile.statusMessageInfo)
  return _msg;
}
inline void SwitchStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusmessageinfo));
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusProfile.statusMessageInfo)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatusProfile::_internal_has_protectedswitch() const {
  return this != internal_default_instance() && _impl_.protectedswitch_ != nullptr;
}
inline bool SwitchStatusProfile::has_protectedswitch() const {
  return _internal_has_protectedswitch();
}
inline void SwitchStatusProfile::clear_protectedswitch() {
  if (GetArenaForAllocation() == nullptr && _impl_.protectedswitch_ != nullptr) {
    delete _impl_.protectedswitch_;
  }
  _impl_.protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchStatusProfile::_internal_protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = _impl_.protectedswitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::ProtectedSwitch&>(
      ::switchmodule::_ProtectedSwitch_default_instance_);
}
inline const ::switchmodule::ProtectedSwitch& SwitchStatusProfile::protectedswitch() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusProfile.protectedSwitch)
  return _internal_protectedswitch();
}
inline void SwitchStatusProfile::unsafe_arena_set_allocated_protectedswitch(
    ::switchmodule::ProtectedSwitch* protectedswitch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectedswitch_);
  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatusProfile.protectedSwitch)
}
inline ::switchmodule::ProtectedSwitch* SwitchStatusProfile::release_protectedswitch() {
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchStatusProfile::unsafe_arena_release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = _impl_.protectedswitch_;
  _impl_.protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchStatusProfile::_internal_mutable_protectedswitch() {
  
  if (_impl_.protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaForAllocation());
    _impl_.protectedswitch_ = p;
  }
  return _impl_.protectedswitch_;
}
inline ::switchmodule::ProtectedSwitch* SwitchStatusProfile::mutable_protectedswitch() {
  ::switchmodule::ProtectedSwitch* _msg = _internal_mutable_protectedswitch();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusProfile.protectedSwitch)
  return _msg;
}
inline void SwitchStatusProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protectedswitch_;
  }
  if (protectedswitch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protectedswitch);
    if (message_arena != submessage_arena) {
      protectedswitch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }

  } else {

  }
  _impl_.protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusProfile.protectedSwitch)
}

// .switchmodule.SwitchStatus switchStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatusProfile::_internal_has_switchstatus() const {
  return this != internal_default_instance() && _impl_.switchstatus_ != nullptr;
}
inline bool SwitchStatusProfile::has_switchstatus() const {
  return _internal_has_switchstatus();
}
inline void SwitchStatusProfile::clear_switchstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.switchstatus_ != nullptr) {
    delete _impl_.switchstatus_;
  }
  _impl_.switchstatus_ = nullptr;
}
inline const ::switchmodule::SwitchStatus& SwitchStatusProfile::_internal_switchstatus() const {
  const ::switchmodule::SwitchStatus* p = _impl_.switchstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::switchmodule::SwitchStatus&>(
      ::switchmodule::_SwitchStatus_default_instance_);
}
inline const ::switchmodule::SwitchStatus& SwitchStatusProfile::switchstatus() const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusProfile.switchStatus)
  return _internal_switchstatus();
}
inline void SwitchStatusProfile::unsafe_arena_set_allocated_switchstatus(
    ::switchmodule::SwitchStatus* switchstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.switchstatus_);
  }
  _impl_.switchstatus_ = switchstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:switchmodule.SwitchStatusProfile.switchStatus)
}
inline ::switchmodule::SwitchStatus* SwitchStatusProfile::release_switchstatus() {
  
  ::switchmodule::SwitchStatus* temp = _impl_.switchstatus_;
  _impl_.switchstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::switchmodule::SwitchStatus* SwitchStatusProfile::unsafe_arena_release_switchstatus() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusProfile.switchStatus)
  
  ::switchmodule::SwitchStatus* temp = _impl_.switchstatus_;
  _impl_.switchstatus_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchStatus* SwitchStatusProfile::_internal_mutable_switchstatus() {
  
  if (_impl_.switchstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchStatus>(GetArenaForAllocation());
    _impl_.switchstatus_ = p;
  }
  return _impl_.switchstatus_;
}
inline ::switchmodule::SwitchStatus* SwitchStatusProfile::mutable_switchstatus() {
  ::switchmodule::SwitchStatus* _msg = _internal_mutable_switchstatus();
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusProfile.switchStatus)
  return _msg;
}
inline void SwitchStatusProfile::set_allocated_switchstatus(::switchmodule::SwitchStatus* switchstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.switchstatus_;
  }
  if (switchstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(switchstatus);
    if (message_arena != submessage_arena) {
      switchstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, switchstatus, submessage_arena);
    }

  } else {

  }
  _impl_.switchstatus_ = switchstatus;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusProfile.switchStatus)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace switchmodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_switchmodule_2fswitchmodule_2eproto_2epb_2eh
