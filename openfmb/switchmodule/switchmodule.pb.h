// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: switchmodule/switchmodule.proto

#ifndef PROTOBUF_INCLUDED_switchmodule_2fswitchmodule_2eproto
#define PROTOBUF_INCLUDED_switchmodule_2fswitchmodule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "uml.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_switchmodule_2fswitchmodule_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_switchmodule_2fswitchmodule_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_switchmodule_2fswitchmodule_2eproto();
namespace switchmodule {
class ProtectedSwitch;
class ProtectedSwitchDefaultTypeInternal;
extern ProtectedSwitchDefaultTypeInternal _ProtectedSwitch_default_instance_;
class SwitchControl;
class SwitchControlDefaultTypeInternal;
extern SwitchControlDefaultTypeInternal _SwitchControl_default_instance_;
class SwitchControlFSCC;
class SwitchControlFSCCDefaultTypeInternal;
extern SwitchControlFSCCDefaultTypeInternal _SwitchControlFSCC_default_instance_;
class SwitchControlProfile;
class SwitchControlProfileDefaultTypeInternal;
extern SwitchControlProfileDefaultTypeInternal _SwitchControlProfile_default_instance_;
class SwitchDiscreteControl;
class SwitchDiscreteControlDefaultTypeInternal;
extern SwitchDiscreteControlDefaultTypeInternal _SwitchDiscreteControl_default_instance_;
class SwitchDiscreteControlProfile;
class SwitchDiscreteControlProfileDefaultTypeInternal;
extern SwitchDiscreteControlProfileDefaultTypeInternal _SwitchDiscreteControlProfile_default_instance_;
class SwitchDiscreteControlXSWI;
class SwitchDiscreteControlXSWIDefaultTypeInternal;
extern SwitchDiscreteControlXSWIDefaultTypeInternal _SwitchDiscreteControlXSWI_default_instance_;
class SwitchEvent;
class SwitchEventDefaultTypeInternal;
extern SwitchEventDefaultTypeInternal _SwitchEvent_default_instance_;
class SwitchEventProfile;
class SwitchEventProfileDefaultTypeInternal;
extern SwitchEventProfileDefaultTypeInternal _SwitchEventProfile_default_instance_;
class SwitchEventXSWI;
class SwitchEventXSWIDefaultTypeInternal;
extern SwitchEventXSWIDefaultTypeInternal _SwitchEventXSWI_default_instance_;
class SwitchReading;
class SwitchReadingDefaultTypeInternal;
extern SwitchReadingDefaultTypeInternal _SwitchReading_default_instance_;
class SwitchReadingProfile;
class SwitchReadingProfileDefaultTypeInternal;
extern SwitchReadingProfileDefaultTypeInternal _SwitchReadingProfile_default_instance_;
class SwitchStatus;
class SwitchStatusDefaultTypeInternal;
extern SwitchStatusDefaultTypeInternal _SwitchStatus_default_instance_;
class SwitchStatusProfile;
class SwitchStatusProfileDefaultTypeInternal;
extern SwitchStatusProfileDefaultTypeInternal _SwitchStatusProfile_default_instance_;
class SwitchStatusXSWI;
class SwitchStatusXSWIDefaultTypeInternal;
extern SwitchStatusXSWIDefaultTypeInternal _SwitchStatusXSWI_default_instance_;
}  // namespace switchmodule
namespace google {
namespace protobuf {
template<> ::switchmodule::ProtectedSwitch* Arena::CreateMaybeMessage<::switchmodule::ProtectedSwitch>(Arena*);
template<> ::switchmodule::SwitchControl* Arena::CreateMaybeMessage<::switchmodule::SwitchControl>(Arena*);
template<> ::switchmodule::SwitchControlFSCC* Arena::CreateMaybeMessage<::switchmodule::SwitchControlFSCC>(Arena*);
template<> ::switchmodule::SwitchControlProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchControlProfile>(Arena*);
template<> ::switchmodule::SwitchDiscreteControl* Arena::CreateMaybeMessage<::switchmodule::SwitchDiscreteControl>(Arena*);
template<> ::switchmodule::SwitchDiscreteControlProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchDiscreteControlProfile>(Arena*);
template<> ::switchmodule::SwitchDiscreteControlXSWI* Arena::CreateMaybeMessage<::switchmodule::SwitchDiscreteControlXSWI>(Arena*);
template<> ::switchmodule::SwitchEvent* Arena::CreateMaybeMessage<::switchmodule::SwitchEvent>(Arena*);
template<> ::switchmodule::SwitchEventProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchEventProfile>(Arena*);
template<> ::switchmodule::SwitchEventXSWI* Arena::CreateMaybeMessage<::switchmodule::SwitchEventXSWI>(Arena*);
template<> ::switchmodule::SwitchReading* Arena::CreateMaybeMessage<::switchmodule::SwitchReading>(Arena*);
template<> ::switchmodule::SwitchReadingProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchReadingProfile>(Arena*);
template<> ::switchmodule::SwitchStatus* Arena::CreateMaybeMessage<::switchmodule::SwitchStatus>(Arena*);
template<> ::switchmodule::SwitchStatusProfile* Arena::CreateMaybeMessage<::switchmodule::SwitchStatusProfile>(Arena*);
template<> ::switchmodule::SwitchStatusXSWI* Arena::CreateMaybeMessage<::switchmodule::SwitchStatusXSWI>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace switchmodule {

// ===================================================================

class SwitchDiscreteControlXSWI :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchDiscreteControlXSWI) */ {
 public:
  SwitchDiscreteControlXSWI();
  virtual ~SwitchDiscreteControlXSWI();

  SwitchDiscreteControlXSWI(const SwitchDiscreteControlXSWI& from);

  inline SwitchDiscreteControlXSWI& operator=(const SwitchDiscreteControlXSWI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchDiscreteControlXSWI(SwitchDiscreteControlXSWI&& from) noexcept
    : SwitchDiscreteControlXSWI() {
    *this = ::std::move(from);
  }

  inline SwitchDiscreteControlXSWI& operator=(SwitchDiscreteControlXSWI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchDiscreteControlXSWI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchDiscreteControlXSWI* internal_default_instance() {
    return reinterpret_cast<const SwitchDiscreteControlXSWI*>(
               &_SwitchDiscreteControlXSWI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SwitchDiscreteControlXSWI* other);
  friend void swap(SwitchDiscreteControlXSWI& a, SwitchDiscreteControlXSWI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchDiscreteControlXSWI* New() const final {
    return CreateMaybeMessage<SwitchDiscreteControlXSWI>(nullptr);
  }

  SwitchDiscreteControlXSWI* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchDiscreteControlXSWI>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchDiscreteControlXSWI& from);
  void MergeFrom(const SwitchDiscreteControlXSWI& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchDiscreteControlXSWI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol();
  static const int kLogicalNodeForControlFieldNumber = 1;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);

  // .commonmodule.ControlDPC Pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::commonmodule::ControlDPC& pos() const;
  ::commonmodule::ControlDPC* release_pos();
  ::commonmodule::ControlDPC* mutable_pos();
  void set_allocated_pos(::commonmodule::ControlDPC* pos);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchDiscreteControlXSWI)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
  ::commonmodule::ControlDPC* pos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchDiscreteControl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchDiscreteControl) */ {
 public:
  SwitchDiscreteControl();
  virtual ~SwitchDiscreteControl();

  SwitchDiscreteControl(const SwitchDiscreteControl& from);

  inline SwitchDiscreteControl& operator=(const SwitchDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchDiscreteControl(SwitchDiscreteControl&& from) noexcept
    : SwitchDiscreteControl() {
    *this = ::std::move(from);
  }

  inline SwitchDiscreteControl& operator=(SwitchDiscreteControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchDiscreteControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchDiscreteControl* internal_default_instance() {
    return reinterpret_cast<const SwitchDiscreteControl*>(
               &_SwitchDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SwitchDiscreteControl* other);
  friend void swap(SwitchDiscreteControl& a, SwitchDiscreteControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchDiscreteControl* New() const final {
    return CreateMaybeMessage<SwitchDiscreteControl>(nullptr);
  }

  SwitchDiscreteControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchDiscreteControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchDiscreteControl& from);
  void MergeFrom(const SwitchDiscreteControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchDiscreteControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue();
  static const int kControlValueFieldNumber = 1;
  const ::commonmodule::ControlValue& controlvalue() const;
  ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);

  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 2;
  const ::commonmodule::CheckConditions& check() const;
  ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);

  // .switchmodule.SwitchDiscreteControlXSWI switchDiscreteControlXSWI = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchdiscretecontrolxswi() const;
  void clear_switchdiscretecontrolxswi();
  static const int kSwitchDiscreteControlXSWIFieldNumber = 3;
  const ::switchmodule::SwitchDiscreteControlXSWI& switchdiscretecontrolxswi() const;
  ::switchmodule::SwitchDiscreteControlXSWI* release_switchdiscretecontrolxswi();
  ::switchmodule::SwitchDiscreteControlXSWI* mutable_switchdiscretecontrolxswi();
  void set_allocated_switchdiscretecontrolxswi(::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchDiscreteControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlValue* controlvalue_;
  ::commonmodule::CheckConditions* check_;
  ::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class ProtectedSwitch :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.ProtectedSwitch) */ {
 public:
  ProtectedSwitch();
  virtual ~ProtectedSwitch();

  ProtectedSwitch(const ProtectedSwitch& from);

  inline ProtectedSwitch& operator=(const ProtectedSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtectedSwitch(ProtectedSwitch&& from) noexcept
    : ProtectedSwitch() {
    *this = ::std::move(from);
  }

  inline ProtectedSwitch& operator=(ProtectedSwitch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProtectedSwitch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtectedSwitch* internal_default_instance() {
    return reinterpret_cast<const ProtectedSwitch*>(
               &_ProtectedSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProtectedSwitch* other);
  friend void swap(ProtectedSwitch& a, ProtectedSwitch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtectedSwitch* New() const final {
    return CreateMaybeMessage<ProtectedSwitch>(nullptr);
  }

  ProtectedSwitch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtectedSwitch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtectedSwitch& from);
  void MergeFrom(const ProtectedSwitch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtectedSwitch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment();
  static const int kConductingEquipmentFieldNumber = 1;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);

  // @@protoc_insertion_point(class_scope:switchmodule.ProtectedSwitch)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipment* conductingequipment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchDiscreteControlProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchDiscreteControlProfile) */ {
 public:
  SwitchDiscreteControlProfile();
  virtual ~SwitchDiscreteControlProfile();

  SwitchDiscreteControlProfile(const SwitchDiscreteControlProfile& from);

  inline SwitchDiscreteControlProfile& operator=(const SwitchDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchDiscreteControlProfile(SwitchDiscreteControlProfile&& from) noexcept
    : SwitchDiscreteControlProfile() {
    *this = ::std::move(from);
  }

  inline SwitchDiscreteControlProfile& operator=(SwitchDiscreteControlProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchDiscreteControlProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchDiscreteControlProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchDiscreteControlProfile*>(
               &_SwitchDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SwitchDiscreteControlProfile* other);
  friend void swap(SwitchDiscreteControlProfile& a, SwitchDiscreteControlProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchDiscreteControlProfile* New() const final {
    return CreateMaybeMessage<SwitchDiscreteControlProfile>(nullptr);
  }

  SwitchDiscreteControlProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchDiscreteControlProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchDiscreteControlProfile& from);
  void MergeFrom(const SwitchDiscreteControlProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchDiscreteControlProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo();
  static const int kControlMessageInfoFieldNumber = 1;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  void clear_protectedswitch();
  static const int kProtectedSwitchFieldNumber = 3;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);

  // .switchmodule.SwitchDiscreteControl switchDiscreteControl = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchdiscretecontrol() const;
  void clear_switchdiscretecontrol();
  static const int kSwitchDiscreteControlFieldNumber = 4;
  const ::switchmodule::SwitchDiscreteControl& switchdiscretecontrol() const;
  ::switchmodule::SwitchDiscreteControl* release_switchdiscretecontrol();
  ::switchmodule::SwitchDiscreteControl* mutable_switchdiscretecontrol();
  void set_allocated_switchdiscretecontrol(::switchmodule::SwitchDiscreteControl* switchdiscretecontrol);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchDiscreteControlProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlMessageInfo* controlmessageinfo_;
  ::commonmodule::IED* ied_;
  ::switchmodule::ProtectedSwitch* protectedswitch_;
  ::switchmodule::SwitchDiscreteControl* switchdiscretecontrol_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchEventXSWI :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchEventXSWI) */ {
 public:
  SwitchEventXSWI();
  virtual ~SwitchEventXSWI();

  SwitchEventXSWI(const SwitchEventXSWI& from);

  inline SwitchEventXSWI& operator=(const SwitchEventXSWI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchEventXSWI(SwitchEventXSWI&& from) noexcept
    : SwitchEventXSWI() {
    *this = ::std::move(from);
  }

  inline SwitchEventXSWI& operator=(SwitchEventXSWI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchEventXSWI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchEventXSWI* internal_default_instance() {
    return reinterpret_cast<const SwitchEventXSWI*>(
               &_SwitchEventXSWI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SwitchEventXSWI* other);
  friend void swap(SwitchEventXSWI& a, SwitchEventXSWI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchEventXSWI* New() const final {
    return CreateMaybeMessage<SwitchEventXSWI>(nullptr);
  }

  SwitchEventXSWI* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchEventXSWI>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchEventXSWI& from);
  void MergeFrom(const SwitchEventXSWI& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchEventXSWI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  void clear_dynamictest();
  static const int kDynamicTestFieldNumber = 2;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);

  // .commonmodule.StatusDPS Pos = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  const ::commonmodule::StatusDPS& pos() const;
  ::commonmodule::StatusDPS* release_pos();
  ::commonmodule::StatusDPS* mutable_pos();
  void set_allocated_pos(::commonmodule::StatusDPS* pos);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchEventXSWI)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::ENS_DynamicTestKind* dynamictest_;
  ::commonmodule::StatusDPS* pos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchEvent) */ {
 public:
  SwitchEvent();
  virtual ~SwitchEvent();

  SwitchEvent(const SwitchEvent& from);

  inline SwitchEvent& operator=(const SwitchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchEvent(SwitchEvent&& from) noexcept
    : SwitchEvent() {
    *this = ::std::move(from);
  }

  inline SwitchEvent& operator=(SwitchEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchEvent* internal_default_instance() {
    return reinterpret_cast<const SwitchEvent*>(
               &_SwitchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SwitchEvent* other);
  friend void swap(SwitchEvent& a, SwitchEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchEvent* New() const final {
    return CreateMaybeMessage<SwitchEvent>(nullptr);
  }

  SwitchEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchEvent& from);
  void MergeFrom(const SwitchEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  void clear_eventvalue();
  static const int kEventValueFieldNumber = 1;
  const ::commonmodule::EventValue& eventvalue() const;
  ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);

  // .switchmodule.SwitchEventXSWI switchEventXSWI = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switcheventxswi() const;
  void clear_switcheventxswi();
  static const int kSwitchEventXSWIFieldNumber = 2;
  const ::switchmodule::SwitchEventXSWI& switcheventxswi() const;
  ::switchmodule::SwitchEventXSWI* release_switcheventxswi();
  ::switchmodule::SwitchEventXSWI* mutable_switcheventxswi();
  void set_allocated_switcheventxswi(::switchmodule::SwitchEventXSWI* switcheventxswi);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventValue* eventvalue_;
  ::switchmodule::SwitchEventXSWI* switcheventxswi_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchEventProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchEventProfile) */ {
 public:
  SwitchEventProfile();
  virtual ~SwitchEventProfile();

  SwitchEventProfile(const SwitchEventProfile& from);

  inline SwitchEventProfile& operator=(const SwitchEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchEventProfile(SwitchEventProfile&& from) noexcept
    : SwitchEventProfile() {
    *this = ::std::move(from);
  }

  inline SwitchEventProfile& operator=(SwitchEventProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchEventProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchEventProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchEventProfile*>(
               &_SwitchEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SwitchEventProfile* other);
  friend void swap(SwitchEventProfile& a, SwitchEventProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchEventProfile* New() const final {
    return CreateMaybeMessage<SwitchEventProfile>(nullptr);
  }

  SwitchEventProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchEventProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchEventProfile& from);
  void MergeFrom(const SwitchEventProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchEventProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  void clear_eventmessageinfo();
  static const int kEventMessageInfoFieldNumber = 1;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  void clear_protectedswitch();
  static const int kProtectedSwitchFieldNumber = 3;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);

  // .switchmodule.SwitchEvent switchEvent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchevent() const;
  void clear_switchevent();
  static const int kSwitchEventFieldNumber = 4;
  const ::switchmodule::SwitchEvent& switchevent() const;
  ::switchmodule::SwitchEvent* release_switchevent();
  ::switchmodule::SwitchEvent* mutable_switchevent();
  void set_allocated_switchevent(::switchmodule::SwitchEvent* switchevent);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchEventProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventMessageInfo* eventmessageinfo_;
  ::commonmodule::IED* ied_;
  ::switchmodule::ProtectedSwitch* protectedswitch_;
  ::switchmodule::SwitchEvent* switchevent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchReading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchReading) */ {
 public:
  SwitchReading();
  virtual ~SwitchReading();

  SwitchReading(const SwitchReading& from);

  inline SwitchReading& operator=(const SwitchReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchReading(SwitchReading&& from) noexcept
    : SwitchReading() {
    *this = ::std::move(from);
  }

  inline SwitchReading& operator=(SwitchReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchReading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchReading* internal_default_instance() {
    return reinterpret_cast<const SwitchReading*>(
               &_SwitchReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SwitchReading* other);
  friend void swap(SwitchReading& a, SwitchReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchReading* New() const final {
    return CreateMaybeMessage<SwitchReading>(nullptr);
  }

  SwitchReading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchReading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchReading& from);
  void MergeFrom(const SwitchReading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  void clear_conductingequipmentterminalreading();
  static const int kConductingEquipmentTerminalReadingFieldNumber = 1;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);

  // .commonmodule.ReadingMMXU diffReadingMMXU = 2;
  bool has_diffreadingmmxu() const;
  void clear_diffreadingmmxu();
  static const int kDiffReadingMMXUFieldNumber = 2;
  const ::commonmodule::ReadingMMXU& diffreadingmmxu() const;
  ::commonmodule::ReadingMMXU* release_diffreadingmmxu();
  ::commonmodule::ReadingMMXU* mutable_diffreadingmmxu();
  void set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu);

  // .commonmodule.PhaseMMTN phaseMMTN = 3;
  bool has_phasemmtn() const;
  void clear_phasemmtn();
  static const int kPhaseMMTNFieldNumber = 3;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);

  // .commonmodule.ReadingMMTR readingMMTR = 4;
  bool has_readingmmtr() const;
  void clear_readingmmtr();
  static const int kReadingMMTRFieldNumber = 4;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);

  // .commonmodule.ReadingMMXU readingMMXU = 5;
  bool has_readingmmxu() const;
  void clear_readingmmxu();
  static const int kReadingMMXUFieldNumber = 5;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchReading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
  ::commonmodule::ReadingMMXU* diffreadingmmxu_;
  ::commonmodule::PhaseMMTN* phasemmtn_;
  ::commonmodule::ReadingMMTR* readingmmtr_;
  ::commonmodule::ReadingMMXU* readingmmxu_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchReadingProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchReadingProfile) */ {
 public:
  SwitchReadingProfile();
  virtual ~SwitchReadingProfile();

  SwitchReadingProfile(const SwitchReadingProfile& from);

  inline SwitchReadingProfile& operator=(const SwitchReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchReadingProfile(SwitchReadingProfile&& from) noexcept
    : SwitchReadingProfile() {
    *this = ::std::move(from);
  }

  inline SwitchReadingProfile& operator=(SwitchReadingProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchReadingProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchReadingProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchReadingProfile*>(
               &_SwitchReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SwitchReadingProfile* other);
  friend void swap(SwitchReadingProfile& a, SwitchReadingProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchReadingProfile* New() const final {
    return CreateMaybeMessage<SwitchReadingProfile>(nullptr);
  }

  SwitchReadingProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchReadingProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchReadingProfile& from);
  void MergeFrom(const SwitchReadingProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchReadingProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .switchmodule.SwitchReading switchReading = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
  int switchreading_size() const;
  void clear_switchreading();
  static const int kSwitchReadingFieldNumber = 4;
  ::switchmodule::SwitchReading* mutable_switchreading(int index);
  ::google::protobuf::RepeatedPtrField< ::switchmodule::SwitchReading >*
      mutable_switchreading();
  const ::switchmodule::SwitchReading& switchreading(int index) const;
  ::switchmodule::SwitchReading* add_switchreading();
  const ::google::protobuf::RepeatedPtrField< ::switchmodule::SwitchReading >&
      switchreading() const;

  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  void clear_readingmessageinfo();
  static const int kReadingMessageInfoFieldNumber = 1;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  void clear_protectedswitch();
  static const int kProtectedSwitchFieldNumber = 3;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchReadingProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::switchmodule::SwitchReading > switchreading_;
  ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
  ::commonmodule::IED* ied_;
  ::switchmodule::ProtectedSwitch* protectedswitch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchStatusXSWI :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchStatusXSWI) */ {
 public:
  SwitchStatusXSWI();
  virtual ~SwitchStatusXSWI();

  SwitchStatusXSWI(const SwitchStatusXSWI& from);

  inline SwitchStatusXSWI& operator=(const SwitchStatusXSWI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchStatusXSWI(SwitchStatusXSWI&& from) noexcept
    : SwitchStatusXSWI() {
    *this = ::std::move(from);
  }

  inline SwitchStatusXSWI& operator=(SwitchStatusXSWI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchStatusXSWI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchStatusXSWI* internal_default_instance() {
    return reinterpret_cast<const SwitchStatusXSWI*>(
               &_SwitchStatusXSWI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SwitchStatusXSWI* other);
  friend void swap(SwitchStatusXSWI& a, SwitchStatusXSWI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchStatusXSWI* New() const final {
    return CreateMaybeMessage<SwitchStatusXSWI>(nullptr);
  }

  SwitchStatusXSWI* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchStatusXSWI>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchStatusXSWI& from);
  void MergeFrom(const SwitchStatusXSWI& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchStatusXSWI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  void clear_dynamictest();
  static const int kDynamicTestFieldNumber = 2;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);

  // .commonmodule.StatusDPS Pos = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  const ::commonmodule::StatusDPS& pos() const;
  ::commonmodule::StatusDPS* release_pos();
  ::commonmodule::StatusDPS* mutable_pos();
  void set_allocated_pos(::commonmodule::StatusDPS* pos);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchStatusXSWI)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::ENS_DynamicTestKind* dynamictest_;
  ::commonmodule::StatusDPS* pos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchStatus) */ {
 public:
  SwitchStatus();
  virtual ~SwitchStatus();

  SwitchStatus(const SwitchStatus& from);

  inline SwitchStatus& operator=(const SwitchStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchStatus(SwitchStatus&& from) noexcept
    : SwitchStatus() {
    *this = ::std::move(from);
  }

  inline SwitchStatus& operator=(SwitchStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchStatus* internal_default_instance() {
    return reinterpret_cast<const SwitchStatus*>(
               &_SwitchStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SwitchStatus* other);
  friend void swap(SwitchStatus& a, SwitchStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchStatus* New() const final {
    return CreateMaybeMessage<SwitchStatus>(nullptr);
  }

  SwitchStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchStatus& from);
  void MergeFrom(const SwitchStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  void clear_statusvalue();
  static const int kStatusValueFieldNumber = 1;
  const ::commonmodule::StatusValue& statusvalue() const;
  ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);

  // .switchmodule.SwitchStatusXSWI switchStatusXSWI = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchstatusxswi() const;
  void clear_switchstatusxswi();
  static const int kSwitchStatusXSWIFieldNumber = 2;
  const ::switchmodule::SwitchStatusXSWI& switchstatusxswi() const;
  ::switchmodule::SwitchStatusXSWI* release_switchstatusxswi();
  ::switchmodule::SwitchStatusXSWI* mutable_switchstatusxswi();
  void set_allocated_switchstatusxswi(::switchmodule::SwitchStatusXSWI* switchstatusxswi);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusValue* statusvalue_;
  ::switchmodule::SwitchStatusXSWI* switchstatusxswi_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchStatusProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchStatusProfile) */ {
 public:
  SwitchStatusProfile();
  virtual ~SwitchStatusProfile();

  SwitchStatusProfile(const SwitchStatusProfile& from);

  inline SwitchStatusProfile& operator=(const SwitchStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchStatusProfile(SwitchStatusProfile&& from) noexcept
    : SwitchStatusProfile() {
    *this = ::std::move(from);
  }

  inline SwitchStatusProfile& operator=(SwitchStatusProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchStatusProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchStatusProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchStatusProfile*>(
               &_SwitchStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SwitchStatusProfile* other);
  friend void swap(SwitchStatusProfile& a, SwitchStatusProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchStatusProfile* New() const final {
    return CreateMaybeMessage<SwitchStatusProfile>(nullptr);
  }

  SwitchStatusProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchStatusProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchStatusProfile& from);
  void MergeFrom(const SwitchStatusProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchStatusProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  void clear_statusmessageinfo();
  static const int kStatusMessageInfoFieldNumber = 1;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  void clear_protectedswitch();
  static const int kProtectedSwitchFieldNumber = 3;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);

  // .switchmodule.SwitchStatus switchStatus = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchstatus() const;
  void clear_switchstatus();
  static const int kSwitchStatusFieldNumber = 4;
  const ::switchmodule::SwitchStatus& switchstatus() const;
  ::switchmodule::SwitchStatus* release_switchstatus();
  ::switchmodule::SwitchStatus* mutable_switchstatus();
  void set_allocated_switchstatus(::switchmodule::SwitchStatus* switchstatus);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchStatusProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusMessageInfo* statusmessageinfo_;
  ::commonmodule::IED* ied_;
  ::switchmodule::ProtectedSwitch* protectedswitch_;
  ::switchmodule::SwitchStatus* switchstatus_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchControlFSCC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchControlFSCC) */ {
 public:
  SwitchControlFSCC();
  virtual ~SwitchControlFSCC();

  SwitchControlFSCC(const SwitchControlFSCC& from);

  inline SwitchControlFSCC& operator=(const SwitchControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchControlFSCC(SwitchControlFSCC&& from) noexcept
    : SwitchControlFSCC() {
    *this = ::std::move(from);
  }

  inline SwitchControlFSCC& operator=(SwitchControlFSCC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchControlFSCC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchControlFSCC* internal_default_instance() {
    return reinterpret_cast<const SwitchControlFSCC*>(
               &_SwitchControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SwitchControlFSCC* other);
  friend void swap(SwitchControlFSCC& a, SwitchControlFSCC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchControlFSCC* New() const final {
    return CreateMaybeMessage<SwitchControlFSCC>(nullptr);
  }

  SwitchControlFSCC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchControlFSCC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchControlFSCC& from);
  void MergeFrom(const SwitchControlFSCC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchControlFSCC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol();
  static const int kLogicalNodeForControlFieldNumber = 1;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);

  // .commonmodule.SwitchControlScheduleFSCH switchControlScheduleFSCH = 2;
  bool has_switchcontrolschedulefsch() const;
  void clear_switchcontrolschedulefsch();
  static const int kSwitchControlScheduleFSCHFieldNumber = 2;
  const ::commonmodule::SwitchControlScheduleFSCH& switchcontrolschedulefsch() const;
  ::commonmodule::SwitchControlScheduleFSCH* release_switchcontrolschedulefsch();
  ::commonmodule::SwitchControlScheduleFSCH* mutable_switchcontrolschedulefsch();
  void set_allocated_switchcontrolschedulefsch(::commonmodule::SwitchControlScheduleFSCH* switchcontrolschedulefsch);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchControlFSCC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
  ::commonmodule::SwitchControlScheduleFSCH* switchcontrolschedulefsch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchControl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchControl) */ {
 public:
  SwitchControl();
  virtual ~SwitchControl();

  SwitchControl(const SwitchControl& from);

  inline SwitchControl& operator=(const SwitchControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchControl(SwitchControl&& from) noexcept
    : SwitchControl() {
    *this = ::std::move(from);
  }

  inline SwitchControl& operator=(SwitchControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchControl* internal_default_instance() {
    return reinterpret_cast<const SwitchControl*>(
               &_SwitchControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(SwitchControl* other);
  friend void swap(SwitchControl& a, SwitchControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchControl* New() const final {
    return CreateMaybeMessage<SwitchControl>(nullptr);
  }

  SwitchControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchControl& from);
  void MergeFrom(const SwitchControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue();
  static const int kControlValueFieldNumber = 1;
  const ::commonmodule::ControlValue& controlvalue() const;
  ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);

  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 2;
  const ::commonmodule::CheckConditions& check() const;
  ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);

  // .switchmodule.SwitchControlFSCC SwitchControlFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchcontrolfscc() const;
  void clear_switchcontrolfscc();
  static const int kSwitchControlFSCCFieldNumber = 3;
  const ::switchmodule::SwitchControlFSCC& switchcontrolfscc() const;
  ::switchmodule::SwitchControlFSCC* release_switchcontrolfscc();
  ::switchmodule::SwitchControlFSCC* mutable_switchcontrolfscc();
  void set_allocated_switchcontrolfscc(::switchmodule::SwitchControlFSCC* switchcontrolfscc);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlValue* controlvalue_;
  ::commonmodule::CheckConditions* check_;
  ::switchmodule::SwitchControlFSCC* switchcontrolfscc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchControlProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:switchmodule.SwitchControlProfile) */ {
 public:
  SwitchControlProfile();
  virtual ~SwitchControlProfile();

  SwitchControlProfile(const SwitchControlProfile& from);

  inline SwitchControlProfile& operator=(const SwitchControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchControlProfile(SwitchControlProfile&& from) noexcept
    : SwitchControlProfile() {
    *this = ::std::move(from);
  }

  inline SwitchControlProfile& operator=(SwitchControlProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchControlProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchControlProfile* internal_default_instance() {
    return reinterpret_cast<const SwitchControlProfile*>(
               &_SwitchControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(SwitchControlProfile* other);
  friend void swap(SwitchControlProfile& a, SwitchControlProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchControlProfile* New() const final {
    return CreateMaybeMessage<SwitchControlProfile>(nullptr);
  }

  SwitchControlProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchControlProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchControlProfile& from);
  void MergeFrom(const SwitchControlProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchControlProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo();
  static const int kControlMessageInfoFieldNumber = 1;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);

  // .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 2;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_protectedswitch() const;
  void clear_protectedswitch();
  static const int kProtectedSwitchFieldNumber = 3;
  const ::switchmodule::ProtectedSwitch& protectedswitch() const;
  ::switchmodule::ProtectedSwitch* release_protectedswitch();
  ::switchmodule::ProtectedSwitch* mutable_protectedswitch();
  void set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch);

  // .switchmodule.SwitchControl switchControl = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_switchcontrol() const;
  void clear_switchcontrol();
  static const int kSwitchControlFieldNumber = 4;
  const ::switchmodule::SwitchControl& switchcontrol() const;
  ::switchmodule::SwitchControl* release_switchcontrol();
  ::switchmodule::SwitchControl* mutable_switchcontrol();
  void set_allocated_switchcontrol(::switchmodule::SwitchControl* switchcontrol);

  // @@protoc_insertion_point(class_scope:switchmodule.SwitchControlProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlMessageInfo* controlmessageinfo_;
  ::commonmodule::IED* ied_;
  ::switchmodule::ProtectedSwitch* protectedswitch_;
  ::switchmodule::SwitchControl* switchcontrol_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_switchmodule_2fswitchmodule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SwitchDiscreteControlXSWI

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool SwitchDiscreteControlXSWI::has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && logicalnodeforcontrol_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForControl& SwitchDiscreteControlXSWI::logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = logicalnodeforcontrol_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForControl*>(
      &::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline ::commonmodule::LogicalNodeForControl* SwitchDiscreteControlXSWI::release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = logicalnodeforcontrol_;
  logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* SwitchDiscreteControlXSWI::mutable_logicalnodeforcontrol() {
  
  if (logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaNoVirtual());
    logicalnodeforcontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
  return logicalnodeforcontrol_;
}
inline void SwitchDiscreteControlXSWI::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlXSWI.logicalNodeForControl)
}

// .commonmodule.ControlDPC Pos = 2;
inline bool SwitchDiscreteControlXSWI::has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline const ::commonmodule::ControlDPC& SwitchDiscreteControlXSWI::pos() const {
  const ::commonmodule::ControlDPC* p = pos_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlXSWI.Pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SwitchDiscreteControlXSWI::release_pos() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlXSWI.Pos)
  
  ::commonmodule::ControlDPC* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SwitchDiscreteControlXSWI::mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlXSWI.Pos)
  return pos_;
}
inline void SwitchDiscreteControlXSWI::set_allocated_pos(::commonmodule::ControlDPC* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlXSWI.Pos)
}

// -------------------------------------------------------------------

// SwitchDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool SwitchDiscreteControl::has_controlvalue() const {
  return this != internal_default_instance() && controlvalue_ != nullptr;
}
inline const ::commonmodule::ControlValue& SwitchDiscreteControl::controlvalue() const {
  const ::commonmodule::ControlValue* p = controlvalue_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControl.controlValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlValue*>(
      &::commonmodule::_ControlValue_default_instance_);
}
inline ::commonmodule::ControlValue* SwitchDiscreteControl::release_controlvalue() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControl.controlValue)
  
  ::commonmodule::ControlValue* temp = controlvalue_;
  controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* SwitchDiscreteControl::mutable_controlvalue() {
  
  if (controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaNoVirtual());
    controlvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControl.controlValue)
  return controlvalue_;
}
inline void SwitchDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlvalue_);
  }
  if (controlvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }
    
  } else {
    
  }
  controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool SwitchDiscreteControl::has_check() const {
  return this != internal_default_instance() && check_ != nullptr;
}
inline const ::commonmodule::CheckConditions& SwitchDiscreteControl::check() const {
  const ::commonmodule::CheckConditions* p = check_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControl.check)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CheckConditions*>(
      &::commonmodule::_CheckConditions_default_instance_);
}
inline ::commonmodule::CheckConditions* SwitchDiscreteControl::release_check() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControl.check)
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* SwitchDiscreteControl::mutable_check() {
  
  if (check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaNoVirtual());
    check_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControl.check)
  return check_;
}
inline void SwitchDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(check_);
  }
  if (check) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControl.check)
}

// .switchmodule.SwitchDiscreteControlXSWI switchDiscreteControlXSWI = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchDiscreteControl::has_switchdiscretecontrolxswi() const {
  return this != internal_default_instance() && switchdiscretecontrolxswi_ != nullptr;
}
inline void SwitchDiscreteControl::clear_switchdiscretecontrolxswi() {
  if (GetArenaNoVirtual() == nullptr && switchdiscretecontrolxswi_ != nullptr) {
    delete switchdiscretecontrolxswi_;
  }
  switchdiscretecontrolxswi_ = nullptr;
}
inline const ::switchmodule::SwitchDiscreteControlXSWI& SwitchDiscreteControl::switchdiscretecontrolxswi() const {
  const ::switchmodule::SwitchDiscreteControlXSWI* p = switchdiscretecontrolxswi_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchDiscreteControlXSWI*>(
      &::switchmodule::_SwitchDiscreteControlXSWI_default_instance_);
}
inline ::switchmodule::SwitchDiscreteControlXSWI* SwitchDiscreteControl::release_switchdiscretecontrolxswi() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
  
  ::switchmodule::SwitchDiscreteControlXSWI* temp = switchdiscretecontrolxswi_;
  switchdiscretecontrolxswi_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchDiscreteControlXSWI* SwitchDiscreteControl::mutable_switchdiscretecontrolxswi() {
  
  if (switchdiscretecontrolxswi_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchDiscreteControlXSWI>(GetArenaNoVirtual());
    switchdiscretecontrolxswi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
  return switchdiscretecontrolxswi_;
}
inline void SwitchDiscreteControl::set_allocated_switchdiscretecontrolxswi(::switchmodule::SwitchDiscreteControlXSWI* switchdiscretecontrolxswi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switchdiscretecontrolxswi_;
  }
  if (switchdiscretecontrolxswi) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchdiscretecontrolxswi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchdiscretecontrolxswi, submessage_arena);
    }
    
  } else {
    
  }
  switchdiscretecontrolxswi_ = switchdiscretecontrolxswi;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControl.switchDiscreteControlXSWI)
}

// -------------------------------------------------------------------

// ProtectedSwitch

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool ProtectedSwitch::has_conductingequipment() const {
  return this != internal_default_instance() && conductingequipment_ != nullptr;
}
inline const ::commonmodule::ConductingEquipment& ProtectedSwitch::conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = conductingequipment_;
  // @@protoc_insertion_point(field_get:switchmodule.ProtectedSwitch.conductingEquipment)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipment*>(
      &::commonmodule::_ConductingEquipment_default_instance_);
}
inline ::commonmodule::ConductingEquipment* ProtectedSwitch::release_conductingequipment() {
  // @@protoc_insertion_point(field_release:switchmodule.ProtectedSwitch.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = conductingequipment_;
  conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* ProtectedSwitch::mutable_conductingequipment() {
  
  if (conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaNoVirtual());
    conductingequipment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.ProtectedSwitch.conductingEquipment)
  return conductingequipment_;
}
inline void ProtectedSwitch::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipment_);
  }
  if (conductingequipment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.ProtectedSwitch.conductingEquipment)
}

// -------------------------------------------------------------------

// SwitchDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchDiscreteControlProfile::has_controlmessageinfo() const {
  return this != internal_default_instance() && controlmessageinfo_ != nullptr;
}
inline const ::commonmodule::ControlMessageInfo& SwitchDiscreteControlProfile::controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = controlmessageinfo_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlMessageInfo*>(
      &::commonmodule::_ControlMessageInfo_default_instance_);
}
inline ::commonmodule::ControlMessageInfo* SwitchDiscreteControlProfile::release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SwitchDiscreteControlProfile::mutable_controlmessageinfo() {
  
  if (controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaNoVirtual());
    controlmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
  return controlmessageinfo_;
}
inline void SwitchDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlProfile.controlMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchDiscreteControlProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SwitchDiscreteControlProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SwitchDiscreteControlProfile::release_ied() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SwitchDiscreteControlProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlProfile.ied)
  return ied_;
}
inline void SwitchDiscreteControlProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlProfile.ied)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchDiscreteControlProfile::has_protectedswitch() const {
  return this != internal_default_instance() && protectedswitch_ != nullptr;
}
inline void SwitchDiscreteControlProfile::clear_protectedswitch() {
  if (GetArenaNoVirtual() == nullptr && protectedswitch_ != nullptr) {
    delete protectedswitch_;
  }
  protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchDiscreteControlProfile::protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = protectedswitch_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::ProtectedSwitch*>(
      &::switchmodule::_ProtectedSwitch_default_instance_);
}
inline ::switchmodule::ProtectedSwitch* SwitchDiscreteControlProfile::release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = protectedswitch_;
  protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchDiscreteControlProfile::mutable_protectedswitch() {
  
  if (protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaNoVirtual());
    protectedswitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
  return protectedswitch_;
}
inline void SwitchDiscreteControlProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protectedswitch_;
  }
  if (protectedswitch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protectedswitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }
    
  } else {
    
  }
  protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlProfile.protectedSwitch)
}

// .switchmodule.SwitchDiscreteControl switchDiscreteControl = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchDiscreteControlProfile::has_switchdiscretecontrol() const {
  return this != internal_default_instance() && switchdiscretecontrol_ != nullptr;
}
inline void SwitchDiscreteControlProfile::clear_switchdiscretecontrol() {
  if (GetArenaNoVirtual() == nullptr && switchdiscretecontrol_ != nullptr) {
    delete switchdiscretecontrol_;
  }
  switchdiscretecontrol_ = nullptr;
}
inline const ::switchmodule::SwitchDiscreteControl& SwitchDiscreteControlProfile::switchdiscretecontrol() const {
  const ::switchmodule::SwitchDiscreteControl* p = switchdiscretecontrol_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchDiscreteControl*>(
      &::switchmodule::_SwitchDiscreteControl_default_instance_);
}
inline ::switchmodule::SwitchDiscreteControl* SwitchDiscreteControlProfile::release_switchdiscretecontrol() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
  
  ::switchmodule::SwitchDiscreteControl* temp = switchdiscretecontrol_;
  switchdiscretecontrol_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchDiscreteControl* SwitchDiscreteControlProfile::mutable_switchdiscretecontrol() {
  
  if (switchdiscretecontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchDiscreteControl>(GetArenaNoVirtual());
    switchdiscretecontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
  return switchdiscretecontrol_;
}
inline void SwitchDiscreteControlProfile::set_allocated_switchdiscretecontrol(::switchmodule::SwitchDiscreteControl* switchdiscretecontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switchdiscretecontrol_;
  }
  if (switchdiscretecontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchdiscretecontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchdiscretecontrol, submessage_arena);
    }
    
  } else {
    
  }
  switchdiscretecontrol_ = switchdiscretecontrol;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchDiscreteControlProfile.switchDiscreteControl)
}

// -------------------------------------------------------------------

// SwitchEventXSWI

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool SwitchEventXSWI::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SwitchEventXSWI::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchEventXSWI::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchEventXSWI::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void SwitchEventXSWI::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventXSWI.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool SwitchEventXSWI::has_dynamictest() const {
  return this != internal_default_instance() && dynamictest_ != nullptr;
}
inline const ::commonmodule::ENS_DynamicTestKind& SwitchEventXSWI::dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = dynamictest_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventXSWI.DynamicTest)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind*>(
      &::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchEventXSWI::release_dynamictest() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventXSWI.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = dynamictest_;
  dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchEventXSWI::mutable_dynamictest() {
  
  if (dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaNoVirtual());
    dynamictest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventXSWI.DynamicTest)
  return dynamictest_;
}
inline void SwitchEventXSWI::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dynamictest_);
  }
  if (dynamictest) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamictest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }
    
  } else {
    
  }
  dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventXSWI.DynamicTest)
}

// .commonmodule.StatusDPS Pos = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchEventXSWI::has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline const ::commonmodule::StatusDPS& SwitchEventXSWI::pos() const {
  const ::commonmodule::StatusDPS* p = pos_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventXSWI.Pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusDPS*>(
      &::commonmodule::_StatusDPS_default_instance_);
}
inline ::commonmodule::StatusDPS* SwitchEventXSWI::release_pos() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventXSWI.Pos)
  
  ::commonmodule::StatusDPS* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* SwitchEventXSWI::mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventXSWI.Pos)
  return pos_;
}
inline void SwitchEventXSWI::set_allocated_pos(::commonmodule::StatusDPS* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventXSWI.Pos)
}

// -------------------------------------------------------------------

// SwitchEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool SwitchEvent::has_eventvalue() const {
  return this != internal_default_instance() && eventvalue_ != nullptr;
}
inline const ::commonmodule::EventValue& SwitchEvent::eventvalue() const {
  const ::commonmodule::EventValue* p = eventvalue_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEvent.eventValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventValue*>(
      &::commonmodule::_EventValue_default_instance_);
}
inline ::commonmodule::EventValue* SwitchEvent::release_eventvalue() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEvent.eventValue)
  
  ::commonmodule::EventValue* temp = eventvalue_;
  eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* SwitchEvent::mutable_eventvalue() {
  
  if (eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaNoVirtual());
    eventvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEvent.eventValue)
  return eventvalue_;
}
inline void SwitchEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventvalue_);
  }
  if (eventvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }
    
  } else {
    
  }
  eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEvent.eventValue)
}

// .switchmodule.SwitchEventXSWI switchEventXSWI = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchEvent::has_switcheventxswi() const {
  return this != internal_default_instance() && switcheventxswi_ != nullptr;
}
inline void SwitchEvent::clear_switcheventxswi() {
  if (GetArenaNoVirtual() == nullptr && switcheventxswi_ != nullptr) {
    delete switcheventxswi_;
  }
  switcheventxswi_ = nullptr;
}
inline const ::switchmodule::SwitchEventXSWI& SwitchEvent::switcheventxswi() const {
  const ::switchmodule::SwitchEventXSWI* p = switcheventxswi_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEvent.switchEventXSWI)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchEventXSWI*>(
      &::switchmodule::_SwitchEventXSWI_default_instance_);
}
inline ::switchmodule::SwitchEventXSWI* SwitchEvent::release_switcheventxswi() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEvent.switchEventXSWI)
  
  ::switchmodule::SwitchEventXSWI* temp = switcheventxswi_;
  switcheventxswi_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchEventXSWI* SwitchEvent::mutable_switcheventxswi() {
  
  if (switcheventxswi_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchEventXSWI>(GetArenaNoVirtual());
    switcheventxswi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEvent.switchEventXSWI)
  return switcheventxswi_;
}
inline void SwitchEvent::set_allocated_switcheventxswi(::switchmodule::SwitchEventXSWI* switcheventxswi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switcheventxswi_;
  }
  if (switcheventxswi) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switcheventxswi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switcheventxswi, submessage_arena);
    }
    
  } else {
    
  }
  switcheventxswi_ = switcheventxswi;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEvent.switchEventXSWI)
}

// -------------------------------------------------------------------

// SwitchEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchEventProfile::has_eventmessageinfo() const {
  return this != internal_default_instance() && eventmessageinfo_ != nullptr;
}
inline const ::commonmodule::EventMessageInfo& SwitchEventProfile::eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = eventmessageinfo_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventProfile.eventMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventMessageInfo*>(
      &::commonmodule::_EventMessageInfo_default_instance_);
}
inline ::commonmodule::EventMessageInfo* SwitchEventProfile::release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* SwitchEventProfile::mutable_eventmessageinfo() {
  
  if (eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaNoVirtual());
    eventmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventProfile.eventMessageInfo)
  return eventmessageinfo_;
}
inline void SwitchEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventProfile.eventMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchEventProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SwitchEventProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SwitchEventProfile::release_ied() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SwitchEventProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventProfile.ied)
  return ied_;
}
inline void SwitchEventProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventProfile.ied)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchEventProfile::has_protectedswitch() const {
  return this != internal_default_instance() && protectedswitch_ != nullptr;
}
inline void SwitchEventProfile::clear_protectedswitch() {
  if (GetArenaNoVirtual() == nullptr && protectedswitch_ != nullptr) {
    delete protectedswitch_;
  }
  protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchEventProfile::protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = protectedswitch_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventProfile.protectedSwitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::ProtectedSwitch*>(
      &::switchmodule::_ProtectedSwitch_default_instance_);
}
inline ::switchmodule::ProtectedSwitch* SwitchEventProfile::release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = protectedswitch_;
  protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchEventProfile::mutable_protectedswitch() {
  
  if (protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaNoVirtual());
    protectedswitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventProfile.protectedSwitch)
  return protectedswitch_;
}
inline void SwitchEventProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protectedswitch_;
  }
  if (protectedswitch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protectedswitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }
    
  } else {
    
  }
  protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventProfile.protectedSwitch)
}

// .switchmodule.SwitchEvent switchEvent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchEventProfile::has_switchevent() const {
  return this != internal_default_instance() && switchevent_ != nullptr;
}
inline void SwitchEventProfile::clear_switchevent() {
  if (GetArenaNoVirtual() == nullptr && switchevent_ != nullptr) {
    delete switchevent_;
  }
  switchevent_ = nullptr;
}
inline const ::switchmodule::SwitchEvent& SwitchEventProfile::switchevent() const {
  const ::switchmodule::SwitchEvent* p = switchevent_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchEventProfile.switchEvent)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchEvent*>(
      &::switchmodule::_SwitchEvent_default_instance_);
}
inline ::switchmodule::SwitchEvent* SwitchEventProfile::release_switchevent() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchEventProfile.switchEvent)
  
  ::switchmodule::SwitchEvent* temp = switchevent_;
  switchevent_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchEvent* SwitchEventProfile::mutable_switchevent() {
  
  if (switchevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchEvent>(GetArenaNoVirtual());
    switchevent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchEventProfile.switchEvent)
  return switchevent_;
}
inline void SwitchEventProfile::set_allocated_switchevent(::switchmodule::SwitchEvent* switchevent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switchevent_;
  }
  if (switchevent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchevent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchevent, submessage_arena);
    }
    
  } else {
    
  }
  switchevent_ = switchevent;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchEventProfile.switchEvent)
}

// -------------------------------------------------------------------

// SwitchReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool SwitchReading::has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && conductingequipmentterminalreading_ != nullptr;
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& SwitchReading::conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = conductingequipmentterminalreading_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading*>(
      &::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SwitchReading::release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = conductingequipmentterminalreading_;
  conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* SwitchReading::mutable_conductingequipmentterminalreading() {
  
  if (conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaNoVirtual());
    conductingequipmentterminalreading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
  return conductingequipmentterminalreading_;
}
inline void SwitchReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.conductingEquipmentTerminalReading)
}

// .commonmodule.ReadingMMXU diffReadingMMXU = 2;
inline bool SwitchReading::has_diffreadingmmxu() const {
  return this != internal_default_instance() && diffreadingmmxu_ != nullptr;
}
inline const ::commonmodule::ReadingMMXU& SwitchReading::diffreadingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = diffreadingmmxu_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.diffReadingMMXU)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMXU*>(
      &::commonmodule::_ReadingMMXU_default_instance_);
}
inline ::commonmodule::ReadingMMXU* SwitchReading::release_diffreadingmmxu() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.diffReadingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = diffreadingmmxu_;
  diffreadingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::mutable_diffreadingmmxu() {
  
  if (diffreadingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaNoVirtual());
    diffreadingmmxu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.diffReadingMMXU)
  return diffreadingmmxu_;
}
inline void SwitchReading::set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(diffreadingmmxu_);
  }
  if (diffreadingmmxu) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      diffreadingmmxu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, diffreadingmmxu, submessage_arena);
    }
    
  } else {
    
  }
  diffreadingmmxu_ = diffreadingmmxu;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.diffReadingMMXU)
}

// .commonmodule.PhaseMMTN phaseMMTN = 3;
inline bool SwitchReading::has_phasemmtn() const {
  return this != internal_default_instance() && phasemmtn_ != nullptr;
}
inline const ::commonmodule::PhaseMMTN& SwitchReading::phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = phasemmtn_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.phaseMMTN)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::PhaseMMTN*>(
      &::commonmodule::_PhaseMMTN_default_instance_);
}
inline ::commonmodule::PhaseMMTN* SwitchReading::release_phasemmtn() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = phasemmtn_;
  phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* SwitchReading::mutable_phasemmtn() {
  
  if (phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaNoVirtual());
    phasemmtn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.phaseMMTN)
  return phasemmtn_;
}
inline void SwitchReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(phasemmtn_);
  }
  if (phasemmtn) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phasemmtn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }
    
  } else {
    
  }
  phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 4;
inline bool SwitchReading::has_readingmmtr() const {
  return this != internal_default_instance() && readingmmtr_ != nullptr;
}
inline const ::commonmodule::ReadingMMTR& SwitchReading::readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = readingmmtr_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.readingMMTR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTR*>(
      &::commonmodule::_ReadingMMTR_default_instance_);
}
inline ::commonmodule::ReadingMMTR* SwitchReading::release_readingmmtr() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = readingmmtr_;
  readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* SwitchReading::mutable_readingmmtr() {
  
  if (readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaNoVirtual());
    readingmmtr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.readingMMTR)
  return readingmmtr_;
}
inline void SwitchReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmtr_);
  }
  if (readingmmtr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmtr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }
    
  } else {
    
  }
  readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 5;
inline bool SwitchReading::has_readingmmxu() const {
  return this != internal_default_instance() && readingmmxu_ != nullptr;
}
inline const ::commonmodule::ReadingMMXU& SwitchReading::readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = readingmmxu_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReading.readingMMXU)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMXU*>(
      &::commonmodule::_ReadingMMXU_default_instance_);
}
inline ::commonmodule::ReadingMMXU* SwitchReading::release_readingmmxu() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = readingmmxu_;
  readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* SwitchReading::mutable_readingmmxu() {
  
  if (readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaNoVirtual());
    readingmmxu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReading.readingMMXU)
  return readingmmxu_;
}
inline void SwitchReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmxu_);
  }
  if (readingmmxu) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmxu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }
    
  } else {
    
  }
  readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReading.readingMMXU)
}

// -------------------------------------------------------------------

// SwitchReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchReadingProfile::has_readingmessageinfo() const {
  return this != internal_default_instance() && readingmessageinfo_ != nullptr;
}
inline const ::commonmodule::ReadingMessageInfo& SwitchReadingProfile::readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = readingmessageinfo_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReadingProfile.readingMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMessageInfo*>(
      &::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline ::commonmodule::ReadingMessageInfo* SwitchReadingProfile::release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = readingmessageinfo_;
  readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* SwitchReadingProfile::mutable_readingmessageinfo() {
  
  if (readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaNoVirtual());
    readingmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReadingProfile.readingMessageInfo)
  return readingmessageinfo_;
}
inline void SwitchReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReadingProfile.readingMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchReadingProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SwitchReadingProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReadingProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SwitchReadingProfile::release_ied() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReadingProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SwitchReadingProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReadingProfile.ied)
  return ied_;
}
inline void SwitchReadingProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReadingProfile.ied)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchReadingProfile::has_protectedswitch() const {
  return this != internal_default_instance() && protectedswitch_ != nullptr;
}
inline void SwitchReadingProfile::clear_protectedswitch() {
  if (GetArenaNoVirtual() == nullptr && protectedswitch_ != nullptr) {
    delete protectedswitch_;
  }
  protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchReadingProfile::protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = protectedswitch_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReadingProfile.protectedSwitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::ProtectedSwitch*>(
      &::switchmodule::_ProtectedSwitch_default_instance_);
}
inline ::switchmodule::ProtectedSwitch* SwitchReadingProfile::release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchReadingProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = protectedswitch_;
  protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchReadingProfile::mutable_protectedswitch() {
  
  if (protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaNoVirtual());
    protectedswitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReadingProfile.protectedSwitch)
  return protectedswitch_;
}
inline void SwitchReadingProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protectedswitch_;
  }
  if (protectedswitch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protectedswitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }
    
  } else {
    
  }
  protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchReadingProfile.protectedSwitch)
}

// repeated .switchmodule.SwitchReading switchReading = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
inline int SwitchReadingProfile::switchreading_size() const {
  return switchreading_.size();
}
inline void SwitchReadingProfile::clear_switchreading() {
  switchreading_.Clear();
}
inline ::switchmodule::SwitchReading* SwitchReadingProfile::mutable_switchreading(int index) {
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchReadingProfile.switchReading)
  return switchreading_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::switchmodule::SwitchReading >*
SwitchReadingProfile::mutable_switchreading() {
  // @@protoc_insertion_point(field_mutable_list:switchmodule.SwitchReadingProfile.switchReading)
  return &switchreading_;
}
inline const ::switchmodule::SwitchReading& SwitchReadingProfile::switchreading(int index) const {
  // @@protoc_insertion_point(field_get:switchmodule.SwitchReadingProfile.switchReading)
  return switchreading_.Get(index);
}
inline ::switchmodule::SwitchReading* SwitchReadingProfile::add_switchreading() {
  // @@protoc_insertion_point(field_add:switchmodule.SwitchReadingProfile.switchReading)
  return switchreading_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::switchmodule::SwitchReading >&
SwitchReadingProfile::switchreading() const {
  // @@protoc_insertion_point(field_list:switchmodule.SwitchReadingProfile.switchReading)
  return switchreading_;
}

// -------------------------------------------------------------------

// SwitchStatusXSWI

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool SwitchStatusXSWI::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& SwitchStatusXSWI::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchStatusXSWI::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* SwitchStatusXSWI::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void SwitchStatusXSWI::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusXSWI.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool SwitchStatusXSWI::has_dynamictest() const {
  return this != internal_default_instance() && dynamictest_ != nullptr;
}
inline const ::commonmodule::ENS_DynamicTestKind& SwitchStatusXSWI::dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = dynamictest_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusXSWI.DynamicTest)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind*>(
      &::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchStatusXSWI::release_dynamictest() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusXSWI.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = dynamictest_;
  dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* SwitchStatusXSWI::mutable_dynamictest() {
  
  if (dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaNoVirtual());
    dynamictest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusXSWI.DynamicTest)
  return dynamictest_;
}
inline void SwitchStatusXSWI::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dynamictest_);
  }
  if (dynamictest) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamictest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }
    
  } else {
    
  }
  dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusXSWI.DynamicTest)
}

// .commonmodule.StatusDPS Pos = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatusXSWI::has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline const ::commonmodule::StatusDPS& SwitchStatusXSWI::pos() const {
  const ::commonmodule::StatusDPS* p = pos_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusXSWI.Pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusDPS*>(
      &::commonmodule::_StatusDPS_default_instance_);
}
inline ::commonmodule::StatusDPS* SwitchStatusXSWI::release_pos() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusXSWI.Pos)
  
  ::commonmodule::StatusDPS* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* SwitchStatusXSWI::mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusXSWI.Pos)
  return pos_;
}
inline void SwitchStatusXSWI::set_allocated_pos(::commonmodule::StatusDPS* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusXSWI.Pos)
}

// -------------------------------------------------------------------

// SwitchStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool SwitchStatus::has_statusvalue() const {
  return this != internal_default_instance() && statusvalue_ != nullptr;
}
inline const ::commonmodule::StatusValue& SwitchStatus::statusvalue() const {
  const ::commonmodule::StatusValue* p = statusvalue_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatus.statusValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusValue*>(
      &::commonmodule::_StatusValue_default_instance_);
}
inline ::commonmodule::StatusValue* SwitchStatus::release_statusvalue() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = statusvalue_;
  statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* SwitchStatus::mutable_statusvalue() {
  
  if (statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaNoVirtual());
    statusvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatus.statusValue)
  return statusvalue_;
}
inline void SwitchStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusvalue_);
  }
  if (statusvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }
    
  } else {
    
  }
  statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatus.statusValue)
}

// .switchmodule.SwitchStatusXSWI switchStatusXSWI = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatus::has_switchstatusxswi() const {
  return this != internal_default_instance() && switchstatusxswi_ != nullptr;
}
inline void SwitchStatus::clear_switchstatusxswi() {
  if (GetArenaNoVirtual() == nullptr && switchstatusxswi_ != nullptr) {
    delete switchstatusxswi_;
  }
  switchstatusxswi_ = nullptr;
}
inline const ::switchmodule::SwitchStatusXSWI& SwitchStatus::switchstatusxswi() const {
  const ::switchmodule::SwitchStatusXSWI* p = switchstatusxswi_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatus.switchStatusXSWI)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchStatusXSWI*>(
      &::switchmodule::_SwitchStatusXSWI_default_instance_);
}
inline ::switchmodule::SwitchStatusXSWI* SwitchStatus::release_switchstatusxswi() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatus.switchStatusXSWI)
  
  ::switchmodule::SwitchStatusXSWI* temp = switchstatusxswi_;
  switchstatusxswi_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchStatusXSWI* SwitchStatus::mutable_switchstatusxswi() {
  
  if (switchstatusxswi_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchStatusXSWI>(GetArenaNoVirtual());
    switchstatusxswi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatus.switchStatusXSWI)
  return switchstatusxswi_;
}
inline void SwitchStatus::set_allocated_switchstatusxswi(::switchmodule::SwitchStatusXSWI* switchstatusxswi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switchstatusxswi_;
  }
  if (switchstatusxswi) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchstatusxswi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchstatusxswi, submessage_arena);
    }
    
  } else {
    
  }
  switchstatusxswi_ = switchstatusxswi;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatus.switchStatusXSWI)
}

// -------------------------------------------------------------------

// SwitchStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchStatusProfile::has_statusmessageinfo() const {
  return this != internal_default_instance() && statusmessageinfo_ != nullptr;
}
inline const ::commonmodule::StatusMessageInfo& SwitchStatusProfile::statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = statusmessageinfo_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusProfile.statusMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusMessageInfo*>(
      &::commonmodule::_StatusMessageInfo_default_instance_);
}
inline ::commonmodule::StatusMessageInfo* SwitchStatusProfile::release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = statusmessageinfo_;
  statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* SwitchStatusProfile::mutable_statusmessageinfo() {
  
  if (statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaNoVirtual());
    statusmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusProfile.statusMessageInfo)
  return statusmessageinfo_;
}
inline void SwitchStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusProfile.statusMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatusProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SwitchStatusProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SwitchStatusProfile::release_ied() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SwitchStatusProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusProfile.ied)
  return ied_;
}
inline void SwitchStatusProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusProfile.ied)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatusProfile::has_protectedswitch() const {
  return this != internal_default_instance() && protectedswitch_ != nullptr;
}
inline void SwitchStatusProfile::clear_protectedswitch() {
  if (GetArenaNoVirtual() == nullptr && protectedswitch_ != nullptr) {
    delete protectedswitch_;
  }
  protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchStatusProfile::protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = protectedswitch_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusProfile.protectedSwitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::ProtectedSwitch*>(
      &::switchmodule::_ProtectedSwitch_default_instance_);
}
inline ::switchmodule::ProtectedSwitch* SwitchStatusProfile::release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = protectedswitch_;
  protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchStatusProfile::mutable_protectedswitch() {
  
  if (protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaNoVirtual());
    protectedswitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusProfile.protectedSwitch)
  return protectedswitch_;
}
inline void SwitchStatusProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protectedswitch_;
  }
  if (protectedswitch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protectedswitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }
    
  } else {
    
  }
  protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusProfile.protectedSwitch)
}

// .switchmodule.SwitchStatus switchStatus = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchStatusProfile::has_switchstatus() const {
  return this != internal_default_instance() && switchstatus_ != nullptr;
}
inline void SwitchStatusProfile::clear_switchstatus() {
  if (GetArenaNoVirtual() == nullptr && switchstatus_ != nullptr) {
    delete switchstatus_;
  }
  switchstatus_ = nullptr;
}
inline const ::switchmodule::SwitchStatus& SwitchStatusProfile::switchstatus() const {
  const ::switchmodule::SwitchStatus* p = switchstatus_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchStatusProfile.switchStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchStatus*>(
      &::switchmodule::_SwitchStatus_default_instance_);
}
inline ::switchmodule::SwitchStatus* SwitchStatusProfile::release_switchstatus() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchStatusProfile.switchStatus)
  
  ::switchmodule::SwitchStatus* temp = switchstatus_;
  switchstatus_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchStatus* SwitchStatusProfile::mutable_switchstatus() {
  
  if (switchstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchStatus>(GetArenaNoVirtual());
    switchstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchStatusProfile.switchStatus)
  return switchstatus_;
}
inline void SwitchStatusProfile::set_allocated_switchstatus(::switchmodule::SwitchStatus* switchstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switchstatus_;
  }
  if (switchstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchstatus, submessage_arena);
    }
    
  } else {
    
  }
  switchstatus_ = switchstatus;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchStatusProfile.switchStatus)
}

// -------------------------------------------------------------------

// SwitchControlFSCC

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool SwitchControlFSCC::has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && logicalnodeforcontrol_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForControl& SwitchControlFSCC::logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = logicalnodeforcontrol_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControlFSCC.logicalNodeForControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForControl*>(
      &::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline ::commonmodule::LogicalNodeForControl* SwitchControlFSCC::release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControlFSCC.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = logicalnodeforcontrol_;
  logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* SwitchControlFSCC::mutable_logicalnodeforcontrol() {
  
  if (logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaNoVirtual());
    logicalnodeforcontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControlFSCC.logicalNodeForControl)
  return logicalnodeforcontrol_;
}
inline void SwitchControlFSCC::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControlFSCC.logicalNodeForControl)
}

// .commonmodule.SwitchControlScheduleFSCH switchControlScheduleFSCH = 2;
inline bool SwitchControlFSCC::has_switchcontrolschedulefsch() const {
  return this != internal_default_instance() && switchcontrolschedulefsch_ != nullptr;
}
inline const ::commonmodule::SwitchControlScheduleFSCH& SwitchControlFSCC::switchcontrolschedulefsch() const {
  const ::commonmodule::SwitchControlScheduleFSCH* p = switchcontrolschedulefsch_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControlFSCC.switchControlScheduleFSCH)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::SwitchControlScheduleFSCH*>(
      &::commonmodule::_SwitchControlScheduleFSCH_default_instance_);
}
inline ::commonmodule::SwitchControlScheduleFSCH* SwitchControlFSCC::release_switchcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControlFSCC.switchControlScheduleFSCH)
  
  ::commonmodule::SwitchControlScheduleFSCH* temp = switchcontrolschedulefsch_;
  switchcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::commonmodule::SwitchControlScheduleFSCH* SwitchControlFSCC::mutable_switchcontrolschedulefsch() {
  
  if (switchcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::SwitchControlScheduleFSCH>(GetArenaNoVirtual());
    switchcontrolschedulefsch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControlFSCC.switchControlScheduleFSCH)
  return switchcontrolschedulefsch_;
}
inline void SwitchControlFSCC::set_allocated_switchcontrolschedulefsch(::commonmodule::SwitchControlScheduleFSCH* switchcontrolschedulefsch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(switchcontrolschedulefsch_);
  }
  if (switchcontrolschedulefsch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchcontrolschedulefsch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchcontrolschedulefsch, submessage_arena);
    }
    
  } else {
    
  }
  switchcontrolschedulefsch_ = switchcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControlFSCC.switchControlScheduleFSCH)
}

// -------------------------------------------------------------------

// SwitchControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool SwitchControl::has_controlvalue() const {
  return this != internal_default_instance() && controlvalue_ != nullptr;
}
inline const ::commonmodule::ControlValue& SwitchControl::controlvalue() const {
  const ::commonmodule::ControlValue* p = controlvalue_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControl.controlValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlValue*>(
      &::commonmodule::_ControlValue_default_instance_);
}
inline ::commonmodule::ControlValue* SwitchControl::release_controlvalue() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControl.controlValue)
  
  ::commonmodule::ControlValue* temp = controlvalue_;
  controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* SwitchControl::mutable_controlvalue() {
  
  if (controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaNoVirtual());
    controlvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControl.controlValue)
  return controlvalue_;
}
inline void SwitchControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlvalue_);
  }
  if (controlvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }
    
  } else {
    
  }
  controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool SwitchControl::has_check() const {
  return this != internal_default_instance() && check_ != nullptr;
}
inline const ::commonmodule::CheckConditions& SwitchControl::check() const {
  const ::commonmodule::CheckConditions* p = check_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControl.check)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CheckConditions*>(
      &::commonmodule::_CheckConditions_default_instance_);
}
inline ::commonmodule::CheckConditions* SwitchControl::release_check() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControl.check)
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* SwitchControl::mutable_check() {
  
  if (check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaNoVirtual());
    check_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControl.check)
  return check_;
}
inline void SwitchControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(check_);
  }
  if (check) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControl.check)
}

// .switchmodule.SwitchControlFSCC SwitchControlFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchControl::has_switchcontrolfscc() const {
  return this != internal_default_instance() && switchcontrolfscc_ != nullptr;
}
inline void SwitchControl::clear_switchcontrolfscc() {
  if (GetArenaNoVirtual() == nullptr && switchcontrolfscc_ != nullptr) {
    delete switchcontrolfscc_;
  }
  switchcontrolfscc_ = nullptr;
}
inline const ::switchmodule::SwitchControlFSCC& SwitchControl::switchcontrolfscc() const {
  const ::switchmodule::SwitchControlFSCC* p = switchcontrolfscc_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControl.SwitchControlFSCC)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchControlFSCC*>(
      &::switchmodule::_SwitchControlFSCC_default_instance_);
}
inline ::switchmodule::SwitchControlFSCC* SwitchControl::release_switchcontrolfscc() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControl.SwitchControlFSCC)
  
  ::switchmodule::SwitchControlFSCC* temp = switchcontrolfscc_;
  switchcontrolfscc_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchControlFSCC* SwitchControl::mutable_switchcontrolfscc() {
  
  if (switchcontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchControlFSCC>(GetArenaNoVirtual());
    switchcontrolfscc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControl.SwitchControlFSCC)
  return switchcontrolfscc_;
}
inline void SwitchControl::set_allocated_switchcontrolfscc(::switchmodule::SwitchControlFSCC* switchcontrolfscc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switchcontrolfscc_;
  }
  if (switchcontrolfscc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchcontrolfscc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchcontrolfscc, submessage_arena);
    }
    
  } else {
    
  }
  switchcontrolfscc_ = switchcontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControl.SwitchControlFSCC)
}

// -------------------------------------------------------------------

// SwitchControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool SwitchControlProfile::has_controlmessageinfo() const {
  return this != internal_default_instance() && controlmessageinfo_ != nullptr;
}
inline const ::commonmodule::ControlMessageInfo& SwitchControlProfile::controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = controlmessageinfo_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControlProfile.controlMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlMessageInfo*>(
      &::commonmodule::_ControlMessageInfo_default_instance_);
}
inline ::commonmodule::ControlMessageInfo* SwitchControlProfile::release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* SwitchControlProfile::mutable_controlmessageinfo() {
  
  if (controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaNoVirtual());
    controlmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControlProfile.controlMessageInfo)
  return controlmessageinfo_;
}
inline void SwitchControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControlProfile.controlMessageInfo)
}

// .commonmodule.IED ied = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchControlProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& SwitchControlProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControlProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* SwitchControlProfile::release_ied() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControlProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* SwitchControlProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControlProfile.ied)
  return ied_;
}
inline void SwitchControlProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControlProfile.ied)
}

// .switchmodule.ProtectedSwitch protectedSwitch = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchControlProfile::has_protectedswitch() const {
  return this != internal_default_instance() && protectedswitch_ != nullptr;
}
inline void SwitchControlProfile::clear_protectedswitch() {
  if (GetArenaNoVirtual() == nullptr && protectedswitch_ != nullptr) {
    delete protectedswitch_;
  }
  protectedswitch_ = nullptr;
}
inline const ::switchmodule::ProtectedSwitch& SwitchControlProfile::protectedswitch() const {
  const ::switchmodule::ProtectedSwitch* p = protectedswitch_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControlProfile.protectedSwitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::ProtectedSwitch*>(
      &::switchmodule::_ProtectedSwitch_default_instance_);
}
inline ::switchmodule::ProtectedSwitch* SwitchControlProfile::release_protectedswitch() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControlProfile.protectedSwitch)
  
  ::switchmodule::ProtectedSwitch* temp = protectedswitch_;
  protectedswitch_ = nullptr;
  return temp;
}
inline ::switchmodule::ProtectedSwitch* SwitchControlProfile::mutable_protectedswitch() {
  
  if (protectedswitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::ProtectedSwitch>(GetArenaNoVirtual());
    protectedswitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControlProfile.protectedSwitch)
  return protectedswitch_;
}
inline void SwitchControlProfile::set_allocated_protectedswitch(::switchmodule::ProtectedSwitch* protectedswitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protectedswitch_;
  }
  if (protectedswitch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protectedswitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, protectedswitch, submessage_arena);
    }
    
  } else {
    
  }
  protectedswitch_ = protectedswitch;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControlProfile.protectedSwitch)
}

// .switchmodule.SwitchControl switchControl = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchControlProfile::has_switchcontrol() const {
  return this != internal_default_instance() && switchcontrol_ != nullptr;
}
inline void SwitchControlProfile::clear_switchcontrol() {
  if (GetArenaNoVirtual() == nullptr && switchcontrol_ != nullptr) {
    delete switchcontrol_;
  }
  switchcontrol_ = nullptr;
}
inline const ::switchmodule::SwitchControl& SwitchControlProfile::switchcontrol() const {
  const ::switchmodule::SwitchControl* p = switchcontrol_;
  // @@protoc_insertion_point(field_get:switchmodule.SwitchControlProfile.switchControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::switchmodule::SwitchControl*>(
      &::switchmodule::_SwitchControl_default_instance_);
}
inline ::switchmodule::SwitchControl* SwitchControlProfile::release_switchcontrol() {
  // @@protoc_insertion_point(field_release:switchmodule.SwitchControlProfile.switchControl)
  
  ::switchmodule::SwitchControl* temp = switchcontrol_;
  switchcontrol_ = nullptr;
  return temp;
}
inline ::switchmodule::SwitchControl* SwitchControlProfile::mutable_switchcontrol() {
  
  if (switchcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::switchmodule::SwitchControl>(GetArenaNoVirtual());
    switchcontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:switchmodule.SwitchControlProfile.switchControl)
  return switchcontrol_;
}
inline void SwitchControlProfile::set_allocated_switchcontrol(::switchmodule::SwitchControl* switchcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete switchcontrol_;
  }
  if (switchcontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      switchcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, switchcontrol, submessage_arena);
    }
    
  } else {
    
  }
  switchcontrol_ = switchcontrol;
  // @@protoc_insertion_point(field_set_allocated:switchmodule.SwitchControlProfile.switchControl)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace switchmodule

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_switchmodule_2fswitchmodule_2eproto
